<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2023.07.25随笔</title>
    <url>/2023/07/25/2023-07-25%E9%9A%8F%E7%AC%94/</url>
    <content><![CDATA[<p><img src="/../images/IMG_0095.jpeg" alt="IMG_0095"><br>0x00 前言</p>
<p>今天总算是把博客搭建好了，其中遇到一堆奇怪的问题和各种各样的bug。。。(图为7.21大雨前的三公山)</p>
<span id="more"></span>

<p>最近面试的项目还不知道从何下手，每次准备去做的时候又想开摆，真是折磨啊，我发现我到现在写日记还是在纯记流水账哈哈哈哈哈哈</p>
]]></content>
      <categories>
        <category>随笔</category>
        <category>日记</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>2023.07.26随笔</title>
    <url>/2023/07/26/2023-07-26%E9%9A%8F%E7%AC%94/</url>
    <content><![CDATA[<p><img src="/../images/IMG_0155.jpeg" alt="IMG_0155"></p>
<p>0x00 前言</p>
<p>每天感觉浑身无力，做事没有干劲，犹如一具行尸走肉，这个榴莲披萨薄脆还挺好吃。</p>
<span id="more"></span>
]]></content>
      <categories>
        <category>随笔</category>
        <category>日记</category>
      </categories>
      <tags>
        <tag>吃</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis简易手册</title>
    <url>/2023/08/23/Redis%E7%AE%80%E6%98%93%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<p><img src="/../images/download.png" alt="download"></p>
<p>0x00 前言</p>
<p>近期在B站看到一个1小时教学Redis，全程没有废话，粗略过了一遍，并对其主要知识点进行总结。</p>
<p>【【GeekHour】一小时Redis教程-哔哩哔哩】 <a href="https://b23.tv/MzEWwWh">https://b23.tv/MzEWwWh</a></p>
<span id="more"></span>

<p>以下是一些常用的Redis命令，使用Markdown语法进行总结：</p>
<h3 id="连接与配置"><a href="#连接与配置" class="headerlink" title="连接与配置"></a>连接与配置</h3><ul>
<li>连接到Redis服务器：<code>redis-cli</code></li>
<li>显示Redis服务器信息：<code>INFO</code></li>
<li>查看配置文件的路径：<code>CONFIG GET dir</code></li>
<li>修改配置项：<code>CONFIG SET &lt;config-name&gt; &lt;value&gt;</code></li>
<li>查看Redis版本：<code>redis-server -v</code></li>
</ul>
<h3 id="键操作"><a href="#键操作" class="headerlink" title="键操作"></a>键操作</h3><ul>
<li>设置键值对：<code>SET &lt;key&gt; &lt;value&gt;</code></li>
<li>获取键对应的值：<code>GET &lt;key&gt;</code></li>
<li>删除键值对：<code>DEL &lt;key&gt;</code></li>
<li>检查键是否存在：<code>EXISTS &lt;key&gt;</code></li>
<li>设置键的过期时间（秒）：<code>EXPIRE &lt;key&gt; &lt;seconds&gt;</code></li>
<li>移除键的过期时间：<code>PERSIST &lt;key&gt;</code></li>
<li>查看键的剩余过期时间（秒）：<code>TTL &lt;key&gt;</code></li>
</ul>
<h3 id="列表操作"><a href="#列表操作" class="headerlink" title="列表操作"></a>列表操作</h3><ul>
<li>向列表头部添加元素：<code>LPUSH &lt;key&gt; &lt;value&gt;</code></li>
<li>向列表尾部添加元素：<code>RPUSH &lt;key&gt; &lt;value&gt;</code></li>
<li>获取列表长度：<code>LLEN &lt;key&gt;</code></li>
<li>获取列表指定范围的元素：<code>LRANGE &lt;key&gt; &lt;start&gt; &lt;end&gt;</code></li>
<li>弹出并返回列表头部元素：<code>LPOP &lt;key&gt;</code></li>
<li>弹出并返回列表尾部元素：<code>RPOP &lt;key&gt;</code></li>
</ul>
<h3 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a>集合操作</h3><ul>
<li>向集合添加一个元素：<code>SADD &lt;key&gt; &lt;member&gt;</code></li>
<li>获取集合的所有成员：<code>SMEMBERS &lt;key&gt;</code></li>
<li>检查元素是否是集合的成员：<code>SISMEMBER &lt;key&gt; &lt;member&gt;</code></li>
<li>移除集合中的一个元素：<code>SREM &lt;key&gt; &lt;member&gt;</code></li>
<li>计算集合的交集、并集或差集：<code>SINTER</code>, <code>SUNION</code>, <code>SDIFF</code></li>
</ul>
<h3 id="哈希操作"><a href="#哈希操作" class="headerlink" title="哈希操作"></a>哈希操作</h3><ul>
<li>设置哈希字段值：<code>HSET &lt;key&gt; &lt;field&gt; &lt;value&gt;</code></li>
<li>获取哈希字段值：<code>HGET &lt;key&gt; &lt;field&gt;</code></li>
<li>获取哈希所有字段和值：<code>HGETALL &lt;key&gt;</code></li>
<li>删除哈希字段：<code>HDEL &lt;key&gt; &lt;field&gt;</code></li>
<li>查看哈希字段数量：<code>HLEN &lt;key&gt;</code></li>
</ul>
<h3 id="有序集合操作"><a href="#有序集合操作" class="headerlink" title="有序集合操作"></a>有序集合操作</h3><ul>
<li>向有序集合添加成员及分数：<code>ZADD &lt;key&gt; &lt;score&gt; &lt;member&gt;</code></li>
<li>获取有序集合的成员列表：<code>ZRANGE &lt;key&gt; &lt;start&gt; &lt;end&gt;</code></li>
<li>根据分数范围获取有序集合的成员：<code>ZRANGEBYSCORE &lt;key&gt; &lt;min&gt; &lt;max&gt;</code></li>
<li>获取有序集合的成员数量：<code>ZCARD &lt;key&gt;</code></li>
<li>移除有序集合中的成员：<code>ZREM &lt;key&gt; &lt;member&gt;</code></li>
</ul>
<h3 id="发布与订阅"><a href="#发布与订阅" class="headerlink" title="发布与订阅"></a>发布与订阅</h3><ul>
<li>订阅频道：<code>SUBSCRIBE &lt;channel&gt;</code></li>
<li>取消订阅频道：<code>UNSUBSCRIBE &lt;channel&gt;</code></li>
<li>发布消息到频道：<code>PUBLISH &lt;channel&gt; &lt;message&gt;</code></li>
</ul>
<h3 id="排序和排名"><a href="#排序和排名" class="headerlink" title="排序和排名"></a>排序和排名</h3><ul>
<li>按分数升序排列有序集合的成员：<code>ZREVRANGE &lt;key&gt; &lt;start&gt; &lt;end&gt;</code></li>
<li>获取有序集合中成员的排名：<code>ZRANK &lt;key&gt; &lt;member&gt;</code></li>
<li>获取有序集合中成员的分数：<code>ZSCORE &lt;key&gt; &lt;member&gt;</code></li>
</ul>
<h3 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h3><ul>
<li>使用通配符查找键名：<code>KEYS &lt;pattern&gt;</code></li>
<li>批量删除符合条件的键：<code>DEL &lt;pattern&gt;</code></li>
<li>列出匹配的键名：<code>SCAN &lt;cursor&gt; MATCH &lt;pattern&gt; COUNT &lt;count&gt;</code></li>
</ul>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><ul>
<li>开启事务：<code>MULTI</code></li>
<li>执行事务：<code>EXEC</code></li>
<li>取消事务：<code>DISCARD</code></li>
</ul>
<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><ul>
<li>使用管道执行多个命令：可以通过一次网络往返执行多个命令以提高性能，使用<code>PIPELINE</code></li>
</ul>
<h3 id="信息统计"><a href="#信息统计" class="headerlink" title="信息统计"></a>信息统计</h3><ul>
<li>查看内存使用情况：<code>MEMORY STATS</code></li>
<li>查看服务器状态：<code>INFO SERVER</code></li>
<li>查看客户端列表：<code>CLIENT LIST</code></li>
</ul>
<h3 id="备份和恢复"><a href="#备份和恢复" class="headerlink" title="备份和恢复"></a>备份和恢复</h3><ul>
<li>创建数据快照：<code>SAVE</code></li>
<li>在后台创建数据快照：<code>BGSAVE</code></li>
<li>恢复数据：将快照文件复制到Redis数据目录并重启服务器</li>
</ul>
<h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><ul>
<li>设置访问密码：<code>CONFIG SET requirepass &lt;password&gt;</code></li>
<li>验证密码：<code>AUTH &lt;password&gt;</code></li>
</ul>
<h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><ul>
<li>创建Redis集群：使用Redis Cluster</li>
<li>查看集群节点信息：<code>CLUSTER NODES</code></li>
<li>手动切换主节点：<code>CLUSTER FAILOVER</code></li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li>发送一个即时命令到服务器以查看性能统计信息：<code>INFO COMMANDSTATS</code></li>
<li>监视键的变化：<code>MONITOR</code></li>
<li>配置Redis服务器以接受远程连接：修改<code>redis.conf</code>文件中的<code>bind</code>选项</li>
</ul>
<h3 id="在C-中使用Redis"><a href="#在C-中使用Redis" class="headerlink" title="在C++中使用Redis"></a>在C++中使用Redis</h3><p>在C++中使用Redis通常需要使用Redis C++客户端库，其中最常用的是hiredis和cpp_redis。以下是在C++中使用Redis的基本步骤以及一些常见操作：</p>
<p><strong>步骤1：安装Redis C++客户端库</strong></p>
<p>首先安装Redis C++客户端库，最常见的选择是hiredis和cpp_redis。您可以使用包管理器（如apt、brew、vcpkg）来安装这些库，或者从官方GitHub存储库手动构建它们。</p>
<p><strong>步骤2：包含头文件</strong></p>
<p>在您的C++代码中，包含适当的Redis客户端库头文件。例如使用cpp_redis则需要包含以下头文件：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cpp_redis/cpp_redis&gt;</span></span></span><br></pre></td></tr></table></figure>

<p><strong>步骤3：建立与Redis的连接</strong></p>
<p>在代码中，使用客户端库提供的函数来建立与Redis服务器的连接。这通常涉及创建一个客户端对象并配置连接参数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cpp_redis::client client;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置连接参数</span></span><br><span class="line">client.<span class="built_in">connect</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">6379</span>);</span><br></pre></td></tr></table></figure>

<p><strong>步骤4：执行Redis命令</strong></p>
<p>使用客户端库提供的函数执行Redis命令。以下是一些常见的示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置键值对</span></span><br><span class="line">client.<span class="built_in">set</span>(<span class="string">&quot;my_key&quot;</span>, <span class="string">&quot;my_value&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取键的值</span></span><br><span class="line">client.<span class="built_in">get</span>(<span class="string">&quot;my_key&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行哈希操作</span></span><br><span class="line">client.<span class="built_in">hset</span>(<span class="string">&quot;my_hash&quot;</span>, <span class="string">&quot;field1&quot;</span>, <span class="string">&quot;value1&quot;</span>);</span><br><span class="line">client.<span class="built_in">hget</span>(<span class="string">&quot;my_hash&quot;</span>, <span class="string">&quot;field1&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>步骤5：提交命令和处理响应</strong></p>
<p>提交Redis命令并处理响应。可以使用回调函数或阻塞方式等不同的方法来处理响应：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 提交命令</span></span><br><span class="line">client.<span class="built_in">sync_commit</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理响应（回调方式）</span></span><br><span class="line">client.<span class="built_in">get</span>(<span class="string">&quot;my_key&quot;</span>, [](cpp_redis::reply&amp; reply) &#123;</span><br><span class="line">    <span class="keyword">if</span> (reply.<span class="built_in">is_string</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; reply.<span class="built_in">as_string</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理响应（阻塞方式）</span></span><br><span class="line">cpp_redis::reply reply = client.<span class="built_in">sync_commit</span>();</span><br><span class="line"><span class="keyword">if</span> (reply.<span class="built_in">is_string</span>()) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; reply.<span class="built_in">as_string</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤6：关闭连接</strong></p>
<p>在使用完Redis之后，确保关闭与Redis服务器的连接以释放资源：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">client.<span class="built_in">disconnect</span>();</span><br></pre></td></tr></table></figure>

<p>要了解更多详细信息和示例，请查阅Redis C++客户端库的文档。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>知识手册</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo常用命令</title>
    <url>/2023/01/23/hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p><img src="/../images/download-2776003.png" alt="download-2776003"></p>
<h1 id="Hexo-常用命令手册"><a href="#Hexo-常用命令手册" class="headerlink" title="Hexo 常用命令手册"></a>Hexo 常用命令手册</h1><p>本功能手册提供了Hexo静态网站生成器的常用命令列表，以及它们的功能和用法说明。</p>
<span id="more"></span>

<h2 id="1-hexo-init-lt-folder-gt"><a href="#1-hexo-init-lt-folder-gt" class="headerlink" title="1. hexo init &lt;folder&gt;"></a>1. hexo init &lt;folder&gt;</h2><p><strong>功能：</strong> 初始化新的Hexo站点。</p>
<p><strong>用法：</strong> 初始化Hexo站点时，需指定一个文件夹名称作为参数。此命令会在指定文件夹内生成站点文件结构和配置。</p>
<h2 id="2-hexo-new-lt-title-gt"><a href="#2-hexo-new-lt-title-gt" class="headerlink" title="2. hexo new &lt;title&gt;"></a>2. hexo new &lt;title&gt;</h2><p><strong>功能：</strong> 创建新的博客文章。</p>
<p><strong>用法：</strong> 使用此命令创建博客文章，需提供文章标题作为参数。Hexo会自动生成对应的Markdown文件，供编写文章内容。</p>
<h2 id="3-hexo-generate-或-hexo-g"><a href="#3-hexo-generate-或-hexo-g" class="headerlink" title="3. hexo generate 或 hexo g"></a>3. hexo generate 或 hexo g</h2><p><strong>功能：</strong> 生成静态网站文件。</p>
<p><strong>用法：</strong> 使用此命令将source文件夹中的Markdown文件转化成HTML，生成静态页面。生成的文件存储在public文件夹中。</p>
<h2 id="4-hexo-server-或-hexo-s"><a href="#4-hexo-server-或-hexo-s" class="headerlink" title="4. hexo server 或 hexo s"></a>4. hexo server 或 hexo s</h2><p><strong>功能：</strong> 启动本地服务器，以便本地预览博客。</p>
<p><strong>用法：</strong> 默认情况下，此命令在本地启动服务器，可通过浏览器访问<a href="http://localhost:4000查看生成的网站。">http://localhost:4000查看生成的网站。</a></p>
<h2 id="5-hexo-deploy"><a href="#5-hexo-deploy" class="headerlink" title="5. hexo deploy"></a>5. hexo deploy</h2><p><strong>功能：</strong> 部署生成的静态网站到托管平台。</p>
<p><strong>用法：</strong> 在Hexo配置文件中设置部署信息，使用此命令将网站内容上传至托管平台，如GitHub Pages或自定义服务器。</p>
<h2 id="6-hexo-clean"><a href="#6-hexo-clean" class="headerlink" title="6. hexo clean"></a>6. hexo clean</h2><p><strong>功能：</strong> 清除Hexo生成的临时文件和缓存。</p>
<p><strong>用法：</strong> 通常用于解决问题或重新生成整个网站。清理后，可再次运行<code>hexo generate</code>重新生成网站。</p>
<h2 id="7-hexo-new-page-lt-name-gt"><a href="#7-hexo-new-page-lt-name-gt" class="headerlink" title="7. hexo new page &lt;name&gt;"></a>7. hexo new page &lt;name&gt;</h2><p><strong>功能：</strong> 创建新的页面。</p>
<p><strong>用法：</strong> 类似于创建文章，但页面通常用于静态内容，如“关于”或“联系”页面。它们存储在<code>source/_pages</code>目录中。</p>
<h2 id="8-hexo-list"><a href="#8-hexo-list" class="headerlink" title="8. hexo list"></a>8. hexo list</h2><p><strong>功能：</strong> 列出所有已创建的文章和页面。</p>
<p><strong>用法：</strong> 可查看当前站点的所有内容。</p>
<h2 id="9-hexo-publish-lt-title-gt"><a href="#9-hexo-publish-lt-title-gt" class="headerlink" title="9. hexo publish &lt;title&gt;"></a>9. hexo publish &lt;title&gt;</h2><p><strong>功能：</strong> 发布一篇草稿。</p>
<p><strong>用法：</strong> 提供文章标题作为参数，Hexo将草稿文件从<code>source/_drafts</code>移动到<code>source/_posts</code>目录，发布文章。</p>
<h2 id="10-hexo-draft-lt-title-gt"><a href="#10-hexo-draft-lt-title-gt" class="headerlink" title="10. hexo draft &lt;title&gt;"></a>10. hexo draft &lt;title&gt;</h2><p><strong>功能：</strong> 创建新的草稿文章。</p>
<p><strong>用法：</strong> 草稿是未发布的文章，存储在<code>source/_drafts</code>目录中，以后可使用<code>hexo publish</code>命令发布。</p>
<h2 id="11-hexo-new-draft-lt-title-gt"><a href="#11-hexo-new-draft-lt-title-gt" class="headerlink" title="11. hexo new draft &lt;title&gt;"></a>11. hexo new draft &lt;title&gt;</h2><p><strong>功能：</strong> 创建并同时发布一篇草稿文章。</p>
<p><strong>用法：</strong> 与上述命令不同，此命令创建文章后将其移动到<code>source/_posts</code>目录，即发布状态。</p>
<h2 id="12-hexo-server-d-或-hexo-s-d"><a href="#12-hexo-server-d-或-hexo-s-d" class="headerlink" title="12. hexo server -d 或 hexo s -d"></a>12. hexo server -d 或 hexo s -d</h2><p><strong>功能：</strong> 启动本地服务器并监听文件变化。</p>
<p><strong>用法：</strong> 编辑博客内容时，Hexo检测文件更改，并自动重新生成网站，可实时预览修改。</p>
<h2 id="13-hexo-generate-–watch-或-hexo-g-–watch"><a href="#13-hexo-generate-–watch-或-hexo-g-–watch" class="headerlink" title="13. hexo generate –watch 或 hexo g –watch"></a>13. hexo generate –watch 或 hexo g –watch</h2><p><strong>功能：</strong> 生成静态网站并监听文件变化。</p>
<p><strong>用法：</strong> 类似于上一个命令，但只生成网站，不启动服务器。适用于生成后手动刷新预览的情况。</p>
<p>这些是Hexo静态网站生成器的常用命令，用于创建、管理和部署静态博客网站。根据需求，可进一步探索Hexo文档以获取关于配置和高级命令的信息。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>知识手册</tag>
      </tags>
  </entry>
  <entry>
    <title>简易网盘项目00</title>
    <url>/2023/07/27/%E7%AE%80%E6%98%93%E7%BD%91%E7%9B%98%E9%A1%B9%E7%9B%AE00/</url>
    <content><![CDATA[<p><img src="/../images/v2-770576ab3a108d44200a78910080cc5e_1440w.jpg" alt="v2-770576ab3a108d44200a78910080cc5e_1440w"></p>
<p>0x00 前言</p>
<p>此项目准备用于应付近期的面试，作为一种简易的Web Server项目，可能需要4-5期迭代开发。本项目将尽可能还原市面上主流的网盘所具有的功能。</p>
<span id="more"></span>

<h2 id="0x01-第一期开发总纲"><a href="#0x01-第一期开发总纲" class="headerlink" title="0x01 第一期开发总纲"></a>0x01 第一期开发总纲</h2><p>第一期主要需要实现的功能有服务器端实现命令解析，可能涉及的命令包括：</p>
<ol>
<li>cd							    进入服务器对应目录</li>
<li>ls				  			   列出当前路径下的所有文件</li>
<li>pwd					   	  显示当前所处路径</li>
<li>puts filename		     上传本地文件到服务器</li>
<li>get filename				下载服务器文件到本地</li>
<li>rm filename			   删除服务器上的某文件</li>
<li>mkdir dirname		   创建文件夹</li>
<li>非法命令            			不响应</li>
</ol>
<h2 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h2><h2 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h2><h2 id="0x04"><a href="#0x04" class="headerlink" title="0x04"></a>0x04</h2>]]></content>
  </entry>
  <entry>
    <title>为什么是127.0.0.1</title>
    <url>/2022/10/12/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF127-0-0-1/</url>
    <content><![CDATA[<p>0x00 前言</p>
<p>刚学习网络时，总看到书上配置的ip地址总是127.0.0.1，遂查找网络进行扫盲。</p>
<span id="more"></span>

<p>IP地址 127.0.0.1 是一个特殊的地址，通常被称为”本地主机”或”回环地址”（Loopback Address）。这个地址是为了在计算机上进行自我测试和本地通信而设计的，具有以下重要特点：</p>
<ol>
<li><p><strong>只在本地使用</strong>：IP地址 127.0.0.1 只能在同一台计算机内部使用，不能被用于跨计算机的网络通信。这是因为它被用于回送到计算机本身的网络数据。</p>
</li>
<li><p><strong>自我测试</strong>：开发人员可以在本地主机上测试网络应用程序，而无需连接到外部网络或依赖外部服务器。这有助于确保应用程序在没有网络连接的情况下也能正常工作。</p>
</li>
<li><p><strong>无需网络硬件</strong>：使用回环地址，您可以在没有网络连接的情况下测试应用程序，因为数据不会离开计算机。</p>
</li>
<li><p><strong>简单的配置</strong>：回环地址不需要任何特殊配置或硬件支持。它通常在任何支持TCP&#x2F;IP协议的计算机上都可用。</p>
</li>
<li><p><strong>标准化</strong>：回环地址 127.0.0.1 是一个标准化的IPv4回环地址。IPv6的回环地址是 “::1”。</p>
</li>
<li><p><strong>用途广泛</strong>：回环地址在本地开发、测试网络应用程序、诊断网络问题等方面被广泛使用。它也在系统中的某些本地服务中使用，以便这些服务可以在不涉及网络的情况下与其他应用程序通信。</p>
</li>
</ol>
<p>总之，IP地址 127.0.0.1 是为了在计算机上进行本地测试和通信而设计的，它允许应用程序在不需要外部网络连接的情况下进行自我测试和开发。它在开发和调试网络应用程序时非常有用。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>C++面试题总结</title>
    <url>/2023/05/08/C-%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93%EF%BC%88%E4%B9%B1%E5%BA%8F%E7%89%88%EF%BC%89/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>平时积累的面试题，还没归纳整理，先弄个乱序版，后面有时间再重新按知识点排序一下</p>
<span id="more"></span>

<h3 id="什么是C语言？它有哪些主要特点？"><a href="#什么是C语言？它有哪些主要特点？" class="headerlink" title="什么是C语言？它有哪些主要特点？"></a>什么是C语言？它有哪些主要特点？</h3><p><strong>回答：</strong> C语言是一种通用的、过程化的编程语言。它的主要特点包括：</p>
<ul>
<li><strong>简洁性：</strong> C语言的语法相对简单，易于学习和理解。</li>
<li><strong>可移植性：</strong> C代码可以在不同的计算机平台上编译和运行，只需进行少量修改。</li>
<li><strong>高性能：</strong> C语言代码通常具有很高的执行速度，因为它接近底层硬件。</li>
<li><strong>强大的标准库：</strong> C标准库提供了许多常用的函数，用于文件操作、内存管理、输入&#x2F;输出等。</li>
<li><strong>指针支持：</strong> C语言支持指针，允许直接访问内存地址，因此具有更高的灵活性。</li>
</ul>
<h3 id="什么是C-语言？它与C语言有什么不同？"><a href="#什么是C-语言？它与C语言有什么不同？" class="headerlink" title="什么是C++语言？它与C语言有什么不同？"></a>什么是C++语言？它与C语言有什么不同？</h3><p><strong>回答：</strong> C++是一种多范式编程语言，它是C语言的扩展，包括了面向对象编程（OOP）的特性。与C语言相比，C++的主要不同之处包括：</p>
<ul>
<li><strong>面向对象编程：</strong> C++支持类和对象，允许使用封装、继承和多态等OOP特性。</li>
<li><strong>标准模板库（STL）：</strong> C++提供了STL，包括容器、算法和迭代器等，使代码更易于编写和维护。</li>
<li><strong>异常处理：</strong> C++支持异常处理，可以捕获和处理运行时错误。</li>
<li><strong>函数重载：</strong> C++允许定义多个同名函数，但参数类型或数量不同，称为函数重载。</li>
<li><strong>命名空间：</strong> C++引入了命名空间概念，用于组织和管理代码。</li>
</ul>
<h3 id="什么是指针？如何使用指针？"><a href="#什么是指针？如何使用指针？" class="headerlink" title="什么是指针？如何使用指针？"></a>什么是指针？如何使用指针？</h3><p><strong>回答：</strong> 指针是一种用于存储变量地址的数据类型。指针通常用于以下操作：</p>
<ul>
<li><p><strong>声明指针：</strong> 使用<code>*</code>运算符声明指针变量，例如：<code>int *ptr;</code>声明一个指向整数的指针。</p>
</li>
<li><p><strong>初始化指针：</strong> 将指针指向特定变量的地址，例如：<code>ptr = &amp;myVar;</code>将指针<code>ptr</code>指向<code>myVar</code>的地址。</p>
</li>
<li><p><strong>访问变量：</strong> 使用指针间接访问变量的值，例如：<code>int x = *ptr;</code>将指针<code>ptr</code>指向的值赋给<code>x</code>。</p>
</li>
<li><p><strong>指针算术：</strong> 指针支持算术运算，例如：<code>ptr++</code>将指针向后移动一个位置。</p>
</li>
<li><p><strong>空指针：</strong> 使用<code>nullptr</code>（C++11及以上）或<code>NULL</code>（旧标准）表示空指针，即不指向任何变量的指针。</p>
</li>
</ul>
<p>指针是C&#x2F;C++中强大但需要谨慎使用的特性，因为它们可以直接操作内存。</p>
<h3 id="什么是动态内存分配？如何在C-x2F-C-中执行动态内存分配和释放？"><a href="#什么是动态内存分配？如何在C-x2F-C-中执行动态内存分配和释放？" class="headerlink" title="什么是动态内存分配？如何在C&#x2F;C++中执行动态内存分配和释放？"></a>什么是动态内存分配？如何在C&#x2F;C++中执行动态内存分配和释放？</h3><p><strong>回答：</strong> 动态内存分配是在程序运行时分配内存，以存储数据结构，而不是在编译时分配。在C&#x2F;C++中，可以使用以下函数执行动态内存分配和释放：</p>
<ul>
<li><p><strong>C中的动态内存分配：</strong></p>
<ul>
<li><code>malloc(size_t size)</code>：分配指定大小的内存块，并返回指向首字节的指针。</li>
<li><code>calloc(size_t num, size_t size)</code>：分配指定数量和大小的内存块，初始化为零。</li>
<li><code>realloc(void* ptr, size_t new_size)</code>：重新分配已分配内存的大小。</li>
<li><code>free(void* ptr)</code>：释放先前分配的内存。</li>
</ul>
</li>
<li><p><strong>C++中的动态内存分配：</strong></p>
<ul>
<li><code>new type</code>：分配指定类型的内存，返回指向该类型的指针。</li>
<li><code>new type[n]</code>：分配数组类型的内存。</li>
<li><code>delete ptr</code>：释放由<code>new</code>分配的内存。</li>
<li><code>delete[] ptr</code>：释放由<code>new[]</code>分配的内存。</li>
</ul>
</li>
</ul>
<p>必须谨慎使用动态内存分配，以避免内存泄漏和悬挂指针。</p>
<h3 id="什么是类和对象？如何在C-中定义类和创建对象？"><a href="#什么是类和对象？如何在C-中定义类和创建对象？" class="headerlink" title="什么是类和对象？如何在C++中定义类和创建对象？"></a>什么是类和对象？如何在C++中定义类和创建对象？</h3><p><strong>回答：</strong> 类是C++中面向对象编程的基本概念，它是一种用户自定义的数据类型，用于封装数据和操作。对象是类的实例，它是具体的数据结构，可以执行类中定义的操作。</p>
<p>在C++中定义类和创建对象的步骤如下：</p>
<p>定义类：使用<code>class</code>关键字定义类，声明类的数据成员和成员函数。例如：</p>
   <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> myVar;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>创建对象：在程序中使用类名创建对象，例如：</p>
   <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">MyClass obj;</span><br></pre></td></tr></table></figure>

<p>访问对象成员：使用点运算符(<code>.</code>)访问对象的数据成员和成员函数，例如：</p>
   <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">obj.myVar = <span class="number">42</span>;</span><br><span class="line">obj.<span class="built_in">myFunction</span>();</span><br></pre></td></tr></table></figure>

<p>类和对象允许将相关数据和操作封装在一起，提高了代码的可维护性和可重用性。</p>
<h3 id="什么是构造函数和析构函数？它们有什么作用？"><a href="#什么是构造函数和析构函数？它们有什么作用？" class="headerlink" title="什么是构造函数和析构函数？它们有什么作用？"></a>什么是构造函数和析构函数？它们有什么作用？</h3><p><strong>回答：</strong> 构造函数和析构函数是C++类的特殊成员函数，用于对象的初始化和清理。</p>
<ul>
<li><p><strong>构造函数（Constructor）：</strong> 构造函数在对象创建时自动调用，用于初始化对象的数据成员。构造函数的名称与类名相同，没有返回类型。</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() &#123;</span><br><span class="line">        <span class="comment">// 构造函数的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>析构函数（Destructor）：</strong> 析构函数在对象销毁时自动调用，用于清理资源。析构函数的名称与类名相同，前面加上<code>~</code>。</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123;</span><br><span class="line">        <span class="comment">// 析构函数的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>构造函数确保对象在使用前处于一种有效状态，而析构函数可用于释放对象使用的资源，如内存或打开的文件。</p>
<h3 id="什么是继承？如何在C-中实现继承？"><a href="#什么是继承？如何在C-中实现继承？" class="headerlink" title="什么是继承？如何在C++中实现继承？"></a>什么是继承？如何在C++中实现继承？</h3><p><strong>回答：</strong> 继承是面向对象编程中的一个重要概念，它允许创建一个新类（子类或派生类），以重用现有类（基类或父类）的属性和方法。在C++中，可以使用以下方式实现继承：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ParentClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> parentVar;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">parentFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 父类的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChildClass</span> : <span class="keyword">public</span> ParentClass &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> childVar;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">childFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 子类的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>ChildClass</code>继承了<code>ParentClass</code>，子类拥有父类的数据成员和方法。</p>
</li>
<li><p><code>public</code>关键字表示继承的访问权限，<code>public</code>表示子类可以访问父类的公有成员。</p>
</li>
</ul>
<p>继承允许代码重用、扩展现有类的功能，以及创建层次化的类结构。</p>
<h3 id="什么是多态性（Polymorphism）？如何在C-中实现多态性？"><a href="#什么是多态性（Polymorphism）？如何在C-中实现多态性？" class="headerlink" title="什么是多态性（Polymorphism）？如何在C++中实现多态性？"></a>什么是多态性（Polymorphism）？如何在C++中实现多态性？</h3><p><strong>回答：</strong> 多态性是面向对象编程的一个特性，它允许不同对象对相同的方法产生不同的行为。在C++中，多态性可以通过函数重载和虚函数实现。</p>
<ul>
<li><p><strong>函数重载：</strong> 函数重载允许在同一个类中定义多个同名函数，但参数类型或数量不同。编译器根据调用时的参数类型来选择正确的函数。</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyMath</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">add</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>虚函数和运行时多态性：</strong> 虚函数是基类中声明为<code>virtual</code>的成员函数。子类可以重写（覆盖）基类的虚函数，并在运行时调用相应的子类版本。</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 基类的虚函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 子类的虚函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>多态性允许以通用的方式操作对象，而不必关心其具体类型。这提高了代码的灵活性和可扩展性。</p>
<h3 id="什么是模板（Template）？如何在C-中使用模板？"><a href="#什么是模板（Template）？如何在C-中使用模板？" class="headerlink" title="什么是模板（Template）？如何在C++中使用模板？"></a>什么是模板（Template）？如何在C++中使用模板？</h3><p><strong>回答：</strong> 模板是C++中一种通用编程工具，允许编写通用代码，适用于不同的数据类型。C++中有两种主要类型的模板：</p>
<ul>
<li><p><strong>函数模板：</strong> 允许编写通用函数，可以适用于不同类型的参数。</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>类模板：</strong> 允许编写通用类，可以适用于不同类型的成员。</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyContainer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T value;</span><br><span class="line">    <span class="built_in">MyContainer</span>(T val) : <span class="built_in">value</span>(val) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>模板通过参数化类型来实现通用性，使得代码更具通用性和可重用性。</p>
<h3 id="什么是RAII（资源获取即初始化）？它在C-中有什么作用？"><a href="#什么是RAII（资源获取即初始化）？它在C-中有什么作用？" class="headerlink" title="什么是RAII（资源获取即初始化）？它在C++中有什么作用？"></a>什么是RAII（资源获取即初始化）？它在C++中有什么作用？</h3><p><strong>回答：</strong> RAII是一种C++编程惯例，它强调资源管理与对象生命周期的绑定。RAII的核心思想是，资源的获取应该在对象构造期间进行，而释放应该在对象析构期间进行。这可以确保资源在任何情况下都会得到正确释放，以避免资源泄漏。</p>
<p>RAII最常见的用法之一是使用析构函数来释放动态分配的内存。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyResource</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyResource</span>() &#123;</span><br><span class="line">        <span class="comment">// 获取资源的操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">MyResource</span>() &#123;</span><br><span class="line">        <span class="comment">// 释放资源的操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用RAII，可以确保在对象离开作用域时资源被正确释放，即使发生异常或提前退出函数也可以。这种技术还可用于管理文件句柄、互斥锁等资源。</p>
<h3 id="什么是指针和引用的区别？在什么情况下应该使用哪个？"><a href="#什么是指针和引用的区别？在什么情况下应该使用哪个？" class="headerlink" title="什么是指针和引用的区别？在什么情况下应该使用哪个？"></a>什么是指针和引用的区别？在什么情况下应该使用哪个？</h3><p><strong>回答：</strong> 指针和引用都用于处理变量的间接访问，但它们有一些重要的区别：</p>
<ul>
<li><p><strong>指针（Pointer）：</strong></p>
<ul>
<li>指针是一个变量，其值是另一个变量的地址。</li>
<li>指针可以重新分配给不同的变量，因此它是可变的。</li>
<li>指针需要显式解引用才能访问存储在地址中的值。</li>
<li>指针可以为空（null）。</li>
<li>指针通常用于动态内存分配、数据结构和在函数中传递参数时。</li>
</ul>
</li>
<li><p><strong>引用（Reference）：</strong></p>
<ul>
<li>引用是一个别名，它引用了另一个变量。</li>
<li>引用在创建后不能重新绑定到其他变量，因此它是不可变的。</li>
<li>引用不需要显式解引用，因为它本身就是所引用变量的别名。</li>
<li>引用不能为空，它必须引用一个已存在的变量。</li>
<li>引用通常用于函数参数、返回值和避免复制大对象的开销。</li>
</ul>
</li>
</ul>
<p>在选择使用指针还是引用时，应考虑以下因素：</p>
<ul>
<li>如果需要能够重新分配引用或者引用为空，应使用指针。</li>
<li>如果不需要重新分配引用，并且要避免复制大对象的开销，应使用引用。</li>
<li>对于函数参数，如果不需要修改传递的值，通常使用引用或者常量引用（<code>const</code>引用）更安全，因为它们不会改变原始值。</li>
</ul>
<h3 id="什么是头文件（Header-File）？为什么在C-x2F-C-中使用头文件？"><a href="#什么是头文件（Header-File）？为什么在C-x2F-C-中使用头文件？" class="headerlink" title="什么是头文件（Header File）？为什么在C&#x2F;C++中使用头文件？"></a>什么是头文件（Header File）？为什么在C&#x2F;C++中使用头文件？</h3><p><strong>回答：</strong> 头文件是包含C&#x2F;C++程序中声明和定义的信息的文件，通常具有<code>.h</code>（C）或<code>.hpp</code>（C++）的扩展名。头文件的主要作用是：</p>
<ul>
<li><p><strong>分离接口和实现：</strong> 头文件包含函数和类的声明，但通常不包含实际的函数或类的实现。这有助于分离接口定义（头文件）和实现（源文件），以便于代码组织和维护。</p>
</li>
<li><p><strong>重复使用代码：</strong> 头文件允许在多个源文件中共享相同的函数和类声明，以便重复使用代码。</p>
</li>
<li><p><strong>编译优化：</strong> 使用头文件可以提供编译器优化的机会，因为它可以在编译不同源文件之前查看头文件的内容。</p>
</li>
<li><p><strong>编译检查：</strong> 头文件中的声明允许编译器进行类型检查，以捕获潜在的错误。</p>
</li>
</ul>
<p>通常，头文件包含函数原型、类声明、宏定义、常量和全局变量的声明。源文件（<code>.c</code>或<code>.cpp</code>）包含函数和类的实现。</p>
<h3 id="什么是内联函数（Inline-Function）？如何定义内联函数？"><a href="#什么是内联函数（Inline-Function）？如何定义内联函数？" class="headerlink" title="什么是内联函数（Inline Function）？如何定义内联函数？"></a>什么是内联函数（Inline Function）？如何定义内联函数？</h3><p><strong>回答：</strong> 内联函数是C&#x2F;C++中的一种编译器指示，用于请求将函数的代码嵌入到函数调用的地方，而不是通过函数调用的方式执行它。内联函数通常用于小型函数，以提高执行效率，因为函数调用会涉及额外的开销。</p>
<p>在C++中，可以通过在函数声明前加上<code>inline</code>关键字来定义内联函数，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内联函数的优点包括：</p>
<ul>
<li>减少了函数调用的开销，因为代码直接嵌入到调用处。</li>
<li>可以提高程序的性能，特别是对于频繁调用的小型函数。</li>
<li>有助于减小可执行文件的大小。</li>
</ul>
<p>然而，内联函数的使用应谨慎，因为过多的内联函数可能会导致可执行文件变得庞大。编译器通常会根据函数的大小和复杂性来决定是否将其内联。</p>
<h3 id="什么是多线程？如何在C-x2F-C-中创建和管理多线程？"><a href="#什么是多线程？如何在C-x2F-C-中创建和管理多线程？" class="headerlink" title="什么是多线程？如何在C&#x2F;C++中创建和管理多线程？"></a>什么是多线程？如何在C&#x2F;C++中创建和管理多线程？</h3><p><strong>回答：</strong> 多线程是一种并发编程技术，允许程序同时执行多个线程，每个线程都有自己的执行流和局部状态。多线程可以提高程序的性能和响应性，特别是在多核处理器上。</p>
<p>在C&#x2F;C++中，可以使用以下库来创建和管理多线程：</p>
<ul>
<li><p><strong>C语言中的线程（pthread）：</strong> 使用POSIX线程库可以在C中创建多线程。示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">thread_function</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="comment">// 线程函数的代码</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> thread;</span><br><span class="line">    pthread_create(&amp;thread, <span class="literal">NULL</span>, thread_function, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(thread, <span class="literal">NULL</span>); <span class="comment">// 等待线程结束</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>C++标准库中的线程：</strong> C++11引入了<code>std::thread</code>，允许在C++中创建多线程。示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 线程函数的代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">thread1</span><span class="params">(thread_function)</span></span>;</span><br><span class="line">    thread1.<span class="built_in">join</span>(); <span class="comment">// 等待线程结束</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>多线程编程需要谨慎处理共享资源的同步和互斥问题，以避免竞态条件和死锁等问题。</p>
<h3 id="什么是异常处理？在C-中如何处理异常？"><a href="#什么是异常处理？在C-中如何处理异常？" class="headerlink" title="什么是异常处理？在C++中如何处理异常？"></a>什么是异常处理？在C++中如何处理异常？</h3><p><strong>回答：</strong> 异常处理</p>
<p>是一种在程序运行时检测和响应错误的机制，以避免程序崩溃或产生不可预测的行为。在C++中，异常处理使用<code>try</code>、<code>catch</code>和<code>throw</code>关键字来实现。</p>
<ul>
<li><code>try</code>块用于包装可能抛出异常的代码块。</li>
<li><code>catch</code>块用于捕获和处理异常。可以有多个<code>catch</code>块，每个块可以处理不同类型的异常。</li>
<li><code>throw</code>语句用于抛出异常，可以抛出任何类型的异常。</li>
</ul>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Divide by zero&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">int</span> result = <span class="built_in">divide</span>(<span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>异常处理允许程序在遇到错误时进行安全退出或执行恢复操作。在设计函数时，应该考虑可能抛出的异常类型，并提供适当的异常处理机制。</p>
<h3 id="什么是析构函数（Destructor）？为什么它重要？"><a href="#什么是析构函数（Destructor）？为什么它重要？" class="headerlink" title="什么是析构函数（Destructor）？为什么它重要？"></a>什么是析构函数（Destructor）？为什么它重要？</h3><p><strong>回答：</strong> 析构函数是C++类的特殊成员函数，用于对象的清理和资源释放。析构函数的名称与类名相同，前面加上<code>~</code>符号。</p>
<p>析构函数在以下情况下重要：</p>
<ul>
<li><p><strong>资源释放：</strong> 析构函数用于释放对象在其生命周期中分配的资源，如内存、文件句柄、数据库连接等。这有助于避免资源泄漏。</p>
</li>
<li><p><strong>对象生命周期控制：</strong> 析构函数确定了对象在销毁时应采取的行动，例如关闭文件或释放锁定。</p>
</li>
<li><p><strong>异常处理：</strong> 析构函数可以用于处理对象生命周期中的异常情况，确保资源在异常时得到释放。</p>
</li>
<li><p><strong>子类析构函数：</strong> 在继承中，基类的析构函数通常是虚的，以确保在销毁子类对象时正确调用基类析构函数，从而实现多态的析构。</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() &#123;</span><br><span class="line">        <span class="comment">// 构造函数的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123;</span><br><span class="line">        <span class="comment">// 析构函数的代码，用于释放资源</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>确保在需要时正确实现析构函数，以避免资源泄漏和不稳定的程序行为。</p>
<h3 id="什么是预处理器（Preprocessor）？它在C-x2F-C-中有什么作用？"><a href="#什么是预处理器（Preprocessor）？它在C-x2F-C-中有什么作用？" class="headerlink" title="什么是预处理器（Preprocessor）？它在C&#x2F;C++中有什么作用？"></a>什么是预处理器（Preprocessor）？它在C&#x2F;C++中有什么作用？</h3><p><strong>回答：</strong> 预处理器是C&#x2F;C++编译过程中的一个独立阶段，用于在实际编译之前处理源代码。预处理器的主要作用包括：</p>
<ul>
<li><p><strong>宏替换：</strong> 预处理器可以替换源代码中的宏定义，例如使用<code>#define</code>定义的宏常量或宏函数。</p>
</li>
<li><p><strong>文件包含：</strong> 预处理器使用<code>#include</code>指令将其他文件的内容插入源文件中，允许代码的模块化组织。</p>
</li>
<li><p><strong>条件编译：</strong> 预处理器使用条件编译指令，如<code>#ifdef</code>和<code>#ifndef</code>，可以根据条件选择性地包含或排除代码块。</p>
</li>
<li><p><strong>注释删除：</strong> 预处理器删除源代码中的注释，以减小编译后的可执行文件的大小。</p>
</li>
<li><p><strong>其他：</strong> 预处理器还支持其他功能，如条件编译、宏展开等。</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_VALUE 100 <span class="comment">// 宏定义</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  <span class="comment">// 文件包含</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">    <span class="comment">// 调试代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> value = MAX_VALUE; <span class="comment">// 宏替换</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>预处理器通过生成经过处理的源代码，然后将其传递给编译器进行编译，起到了代码预处理和条件编译的作用。</p>
<h3 id="什么是静态链接（Static-Linking）和动态链接（Dynamic-Linking）？它们有什么区别？"><a href="#什么是静态链接（Static-Linking）和动态链接（Dynamic-Linking）？它们有什么区别？" class="headerlink" title="什么是静态链接（Static Linking）和动态链接（Dynamic Linking）？它们有什么区别？"></a>什么是静态链接（Static Linking）和动态链接（Dynamic Linking）？它们有什么区别？</h3><p><strong>回答：</strong> 静态链接和动态链接是用于将程序模块（如库和函数）与应用程序代码组合在一起的两种不同方法。</p>
<ul>
<li><p><strong>静态链接：</strong></p>
<ul>
<li>在静态链接中，编译器将所有需要的库和函数的代码复制到最终的可执行文件中。</li>
<li>可执行文件独立于外部库，无需依赖外部库的存在。</li>
<li>可执行文件较大，因为它包含了所有必要的代码。</li>
<li>静态链接的程序在运行时不需要外部库文件，因此更易于分发和部署。</li>
</ul>
</li>
<li><p><strong>动态链接：</strong></p>
<ul>
<li>在动态链接中，应用程序在运行时加载所需的库和函数。</li>
<li>可执行文件较小，因为它只包含链接到库的引用。</li>
<li>库文件（如DLL或共享对象）必须在运行时存在，否则程序将无法执行。</li>
<li>动态链接减小了可执行文件的大小，并允许库的更新和共享。</li>
</ul>
</li>
</ul>
<p>区别：</p>
<ul>
<li><strong>可执行文件大小：</strong> 静态链接生成较大的可执行文件，而动态链接生成较小的可执行文件。</li>
<li><strong>部署和更新：</strong> 静态链接程序更容易部署，因为它不需要外部库文件，但更新时需要重新编译。动态链接程序更容易更新，但需要确保所需的库文件可用。</li>
<li><strong>性能：</strong> 通常情况下，静态链接的性能</li>
</ul>
<p>略高于动态链接，因为所有代码都包含在可执行文件中，无需运行时加载。</p>
<p>选择静态链接或动态链接取决于项目的需求和目标。一些操作系统和开发环境支持同时使用两者，以实现最佳的灵活性和性能。</p>
<h3 id="什么是多继承（Multiple-Inheritance）？在C-中如何实现多继承？"><a href="#什么是多继承（Multiple-Inheritance）？在C-中如何实现多继承？" class="headerlink" title="什么是多继承（Multiple Inheritance）？在C++中如何实现多继承？"></a>什么是多继承（Multiple Inheritance）？在C++中如何实现多继承？</h3><p><strong>回答：</strong> 多继承是C++中一种面向对象编程的特性，允许一个类继承多个基类的特性和行为。在C++中，可以通过以下方式实现多继承：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BaseClass1</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// BaseClass1 的成员函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaseClass2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// BaseClass2 的成员函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DerivedClass</span> : <span class="keyword">public</span> BaseClass1, <span class="keyword">public</span> BaseClass2 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// DerivedClass 的成员函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>DerivedClass</code>从<code>BaseClass1</code>和<code>BaseClass2</code>继承了成员函数<code>func1</code>和<code>func2</code>。</li>
<li>多继承允许一个类拥有多个父类，但需要注意解决潜在的二义性问题。例如，如果两个基类都有相同名称的成员函数，需要使用作用域解析符号来指定调用哪个版本。</li>
</ul>
<p>多继承可以提供更丰富的代码复用和组织，但也可能导致复杂性增加，因为需要处理潜在的二义性和命名冲突。</p>
<h3 id="什么是智能指针（Smart-Pointer）？它们在C-中的作用是什么？"><a href="#什么是智能指针（Smart-Pointer）？它们在C-中的作用是什么？" class="headerlink" title="什么是智能指针（Smart Pointer）？它们在C++中的作用是什么？"></a>什么是智能指针（Smart Pointer）？它们在C++中的作用是什么？</h3><p><strong>回答：</strong> 智能指针是C++中的一种数据类型，用于管理动态分配的内存，以防止内存泄漏和悬挂指针等问题。C++标准库提供了两种主要类型的智能指针：<code>std::shared_ptr</code>和<code>std::unique_ptr</code>。</p>
<ul>
<li><p><strong><code>std::shared_ptr</code>：</strong></p>
<ul>
<li>允许多个智能指针共享同一块内存。</li>
<li>使用引用计数来跟踪共享对象的引用数，当引用计数为零时，自动释放内存。</li>
<li>适用于多个指针需要访问相同对象的情况。</li>
</ul>
</li>
<li><p><strong><code>std::unique_ptr</code>：</strong></p>
<ul>
<li>限制只有一个智能指针可以拥有和管理特定内存块。</li>
<li>适用于单一所有权的情况，可以确保内存的独占性。</li>
<li>移动语义允许将所有权从一个<code>unique_ptr</code>转移给另一个。</li>
</ul>
</li>
</ul>
<p>智能指针的作用包括：</p>
<ul>
<li><p><strong>自动内存管理：</strong> 智能指针负责在对象不再需要时释放内存，从而避免内存泄漏。</p>
</li>
<li><p><strong>资源管理：</strong> 除了内存，智能指针还可以用于管理其他资源，如文件句柄和数据库连接。</p>
</li>
<li><p><strong>避免悬挂指针：</strong> 智能指针的生命周期与所管理的对象相关联，当对象不再存在时，智能指针会自动置为<code>nullptr</code>，避免悬挂指针的问题。</p>
</li>
</ul>
<p>使用智能指针可以提高代码的可维护性和安全性，减少手动内存管理的错误。</p>
<h3 id="什么是虚函数（Virtual-Function）？它在C-中有什么作用？"><a href="#什么是虚函数（Virtual-Function）？它在C-中有什么作用？" class="headerlink" title="什么是虚函数（Virtual Function）？它在C++中有什么作用？"></a>什么是虚函数（Virtual Function）？它在C++中有什么作用？</h3><p><strong>回答：</strong> 虚函数是C++中一种用于实现多态性（polymorphism）的重要特性。虚函数允许子类（派生类）重写（覆盖）基类（父类）中的同名函数，从而在运行时实现动态绑定。以下是虚函数的关键概念和作用：</p>
<ul>
<li><strong>虚函数声明：</strong> 在基类中，可以通过在函数声明前面添加<code>virtual</code>关键字来声明虚函数。子类可以选择性地重写这些虚函数。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">myFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 基类虚函数的实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>函数覆盖：</strong> 子类可以覆盖基类的虚函数，提供自己的实现。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 子类覆盖的虚函数实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>动态绑定：</strong> 当通过基类指针或引用调用虚函数时，实际执行的是派生类的版本。这个机制称为动态绑定，它使多态性成为可能。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Base* ptr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">ptr-&gt;<span class="built_in">myFunction</span>(); <span class="comment">// 调用Derived类的实现</span></span><br></pre></td></tr></table></figure>

<p>虚函数的作用在于实现了多态性，允许通过基类接口操作派生类对象，同时保持了运行时的灵活性和可扩展性。</p>
<h3 id="什么是模板元编程（Template-Metaprogramming）？在C-中如何使用模板元编程？"><a href="#什么是模板元编程（Template-Metaprogramming）？在C-中如何使用模板元编程？" class="headerlink" title="什么是模板元编程（Template Metaprogramming）？在C++中如何使用模板元编程？"></a>什么是模板元编程（Template Metaprogramming）？在C++中如何使用模板元编程？</h3><p><strong>回答：</strong> 模板元编程是一种使用C++模板系统来进行编程的技术，它允许在编译时执行计算和生成代码。模板元编程的核心思想是利用模板特化、递归和编译期常量等功能来进行元编程，生成通用、高性能的代码。</p>
<p>模板元编程的应用包括：</p>
<ul>
<li><strong>泛型编程：</strong> 通过模板编写通用的数据结构和算法，可以在编译时根据不同类型生成高效的代码。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>编译时计算：</strong> 模板元编程可以在编译时执行计算，生成常量表达式的结果。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = N * Factorial&lt;N - <span class="number">1</span>&gt;::value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span>&lt;<span class="number">0</span>&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>元编程技巧：</strong> 模板元编程还可以用于元编程技巧，如类型萃取、类型转换等。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TypeTrait</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">bool</span> is_integer = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TypeTrait</span>&lt;<span class="type">int</span>&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">bool</span> is_integer = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>模板元编程的主要优势在于它在编译时执行，因此可以产生高性能的代码，并在类型安全和泛型性方面提供了强大的工具。但它也可能导致复杂的代码和编译错误，因此需要谨慎使用。</p>
<h3 id="什么是移动语义（Move-Semantics）？它在C-中有什么作用？"><a href="#什么是移动语义（Move-Semantics）？它在C-中有什么作用？" class="headerlink" title="什么是移动语义（Move Semantics）？它在C++中有什么作用？"></a>什么是移动语义（Move Semantics）？它在C++中有什么作用？</h3><p><strong>回答：</strong> 移动语义是C++11引入的一个特性，旨在提高程序性能，特别是在处理大型数据结构时。移动语义允许将资源的所有权从一个对象转移到另一个对象，而无需复制数据。这主要通过移动构造函数和移动赋值运算符来实现。</p>
<p>移动语义的关键概念包括：</p>
<ul>
<li><strong>移动构造函数（Move Constructor）：</strong> 移动构造函数允许从一个临时对象或右值引用（通常是即将销毁的对象）中“窃取”资源，而不是复制资源。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyString</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyString</span>(MyString&amp;&amp; other) &#123;</span><br><span class="line">        <span class="comment">// 移动构造函数，窃取资源</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>移动赋值运算符（Move Assignment Operator）：</strong> 移动赋值运算符允许将资源从一个对象转移到另一个对象，以替代传统的复制赋值。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">MyString&amp; <span class="keyword">operator</span>=(MyString&amp;&amp; other) &#123;</span><br><span class="line">    <span class="comment">// 移动赋值运算符，窃取资源</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>移动语义的主要作用在于：</p>
<ul>
<li><p>提高性能：避免不必要的数据复制，特别是在处理大型数据结构时可以显著提高性能。</p>
</li>
<li><p>支持移动语义的标准库容器和算法：标准库容器（如<code>std::vector</code>）和算法（如<code>std::sort</code>）都已经更新，以支持移动语义，允许更高效地管理和操作对象。</p>
</li>
<li><p>支持移动语义的用户定义类型：用户可以为自己的类型定义移动构造函数和移动赋值运算符，以充分利用移动语义。</p>
</li>
</ul>
<p>移动语义是C++中的重要特性，可用于提高性能和资源管理的效率。</p>
<h3 id="什么是RAII（资源获取即初始化）？它在C-中有什么作用？-1"><a href="#什么是RAII（资源获取即初始化）？它在C-中有什么作用？-1" class="headerlink" title="什么是RAII（资源获取即初始化）？它在C++中有什么作用？"></a>什么是RAII（资源获取即初始化）？它在C++中有什么作用？</h3><p><strong>回答：</strong> RAII（Resource Acquisition Is Initialization）是C++中一种编程惯例，强调在对象的构造期间获取资源，并在对象的析构期间释放资源。RAII的核心思想是利用栈上对象的生命周期来管理资源，以确保资源在任何情况下都会得到正确释放，</p>
<p>避免资源泄漏。</p>
<p>RAII的应用包括：</p>
<ul>
<li><strong>内存管理：</strong> 使用智能指针（如<code>std::shared_ptr</code>和<code>std::unique_ptr</code>）来管理动态分配的内存，确保在对象生命周期结束时自动释放内存。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; ptr = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>); <span class="comment">// 获取内存资源</span></span><br><span class="line">    <span class="comment">// 在此作用域结束时，资源会自动释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>文件和资源管理：</strong> 使用RAII对象管理文件句柄、数据库连接、锁等资源，以确保在离开作用域时资源会被正确释放。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="function">std::ofstream <span class="title">file</span><span class="params">(<span class="string">&quot;example.txt&quot;</span>)</span></span>; <span class="comment">// 打开文件</span></span><br><span class="line">    <span class="comment">// 在此作用域结束时，文件会自动关闭</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>异常安全性：</strong> RAII可以确保在发生异常时资源会被正确释放，从而保证程序的异常安全性。</li>
</ul>
<p>RAII是C++中许多标准库和用户定义类型的设计原则，它简化了资源管理和提高了程序的可维护性和可靠性。</p>
<h3 id="什么是STL（Standard-Template-Library）？它包括哪些常见组件？"><a href="#什么是STL（Standard-Template-Library）？它包括哪些常见组件？" class="headerlink" title="什么是STL（Standard Template Library）？它包括哪些常见组件？"></a>什么是STL（Standard Template Library）？它包括哪些常见组件？</h3><p><strong>回答：</strong> STL（Standard Template Library）是C++标准库的一部分，它提供了一组通用的模板类和函数，用于实现常见的数据结构和算法。STL的目标是提供高性能、可重用的组件，以便开发人员可以更容易地编写高效且可维护的C++代码。</p>
<p>STL包括以下常见组件：</p>
<ul>
<li><p><strong>容器（Containers）：</strong> 容器是用于存储和组织数据的数据结构，STL提供了多种容器，包括<code>vector</code>、<code>list</code>、<code>map</code>、<code>set</code>等。每种容器都有特定的用途和性能特性。</p>
</li>
<li><p><strong>算法（Algorithms）：</strong> STL提供了一组强大的算法，用于在容器上执行各种操作，如排序、查找、遍历等。这些算法可以与不同类型的容器一起使用，提供了通用的接口。</p>
</li>
<li><p><strong>迭代器（Iterators）：</strong> 迭代器用于遍历容器中的元素，STL定义了多种类型的迭代器，包括输入迭代器、输出迭代器、正向迭代器、双向迭代器和随机访问迭代器。</p>
</li>
<li><p><strong>函数对象（Function Objects）：</strong> 函数对象是可调用对象，它们可以像函数一样被调用，并且可以在STL算法中使用。STL提供了一些内置的函数对象，也允许用户定义自己的函数对象。</p>
</li>
<li><p><strong>适配器（Adapters）：</strong> 适配器用于修改或扩展容器和迭代器的行为，如<code>stack</code>、<code>queue</code>、<code>priority_queue</code>等。</p>
</li>
</ul>
<p>STL的设计原则包括通用性、高性能和可复用性，使其成为C++编程中不可或缺的一部分，可以大大简化数据结构和算法的实现。</p>
<h3 id="什么是多态性（Polymorphism）？在C-中如何实现多态性？"><a href="#什么是多态性（Polymorphism）？在C-中如何实现多态性？" class="headerlink" title="什么是多态性（Polymorphism）？在C++中如何实现多态性？"></a>什么是多态性（Polymorphism）？在C++中如何实现多态性？</h3><p><strong>回答：</strong> 多态性是面向对象编程的核心概念之一，它允许不同类的对象对相同的消息作出不同的响应。多态性有两种主要形式：编译时多态性和运行时多态性。</p>
<p>在C++中，运行时多态性通常通过虚函数和基类指针&#x2F;引用实现。以下是多态性的关键概念和实现方式：</p>
<ul>
<li><strong>虚函数（Virtual Function）：</strong> 虚函数是在基类中声明的函数，可以在派生类中被重写（覆盖）。通过在函数声明前面加上<code>virtual</code>关键字来定义虚函数。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">myFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 基类虚函数的实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>函数重写（Function Overriding）：</strong> 派生类可以重写基类中的虚函数，提供自己的实现。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 派生类覆盖的虚函数实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>基类指针和引用：</strong> 基类指针或引用可以指向派生类对象，并在运行时调用派生类的虚函数。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Base* ptr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">ptr-&gt;<span class="built_in">myFunction</span>(); <span class="comment">// 调用Derived类的实现</span></span><br></pre></td></tr></table></figure>

<p>多态性的优点包括代码的灵活性和可扩展性，因为可以根据需要轻松添加新的派生类，而无需修改现有代码。多态性还支持面向接口编程，允许根据对象的行为而不是具体类型进行编程。</p>
<h3 id="什么是单例模式（Singleton-Pattern）？在C-中如何实现单例模式？"><a href="#什么是单例模式（Singleton-Pattern）？在C-中如何实现单例模式？" class="headerlink" title="什么是单例模式（Singleton Pattern）？在C++中如何实现单例模式？"></a>什么是单例模式（Singleton Pattern）？在C++中如何实现单例模式？</h3><p><strong>回答：</strong> 单例模式是一种设计模式，它确保类只有一个实例，并提供一种全局访问该实例的方式。单例模式通常用于那些需要在整个应用程序中共享一个资源或状态的情况。在C++中，可以通过以下方式实现单例模式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 获取单例实例的静态方法</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton&amp; <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> Singleton instance; <span class="comment">// 在首次调用时创建单例</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻止拷贝构造和赋值操作</span></span><br><span class="line">    <span class="built_in">Singleton</span>(Singleton <span class="type">const</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span>=(Singleton <span class="type">const</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">someFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 单例的成员函数实现</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 私有构造函数，防止外部创建实例</span></span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;</span><br><span class="line">        <span class="comment">// 初始化单例</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上述代码中，<code>Singleton</code>类的构造函数是私有的，只能在类的内部访问，从而防止外部代码创建多个实例。<code>getInstance</code>方法返回单例的引用，首次调用时创建实例。</p>
<p>此外，通过删除拷贝构造函数和赋值操作符，可以防止通过复制创建多个实例。</p>
<p>单例模式确保只有一个实例，因此可以全局共享状态和资源，但也要小心全局状态可能导致的问题。</p>
<h3 id="什么是模板（Template）？在C-中如何使用模板？"><a href="#什么是模板（Template）？在C-中如何使用模板？" class="headerlink" title="什么是模板（Template）？在C++中如何使用模板？"></a>什么是模板（Template）？在C++中如何使用模板？</h3><p><strong>回答：</strong> 模板是C++中的一种机制，允许编写通用代码，不受特定数据类型的限制。模板使得可以编写具有类型参数的函数和类，这些类型参数可以在使用模板时进行替换。</p>
<p>在C++中，有两种主要类型的模板：</p>
<ul>
<li><strong>函数模板（Function Template）：</strong> 函数模板允许编写可以处理不同类型的函数，通过将类型参数作为函数参数进行通用化。例如，以下是一个通用的<code>max</code>函数模板：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">max</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>类模板（Class Template）：</strong> 类模板允许编写可以处理不同类型的类，通过将类型参数作为类成员或成员函数参数进行通用化。例如，以下是一个通用的堆栈（<code>Stack</code>）类模板：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 类模板成员和成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T item)</span></span>;</span><br><span class="line">    <span class="function">T <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用模板时，可以提供具体的类型参数，从而生成特定类型的代码实例。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">max</span>(a, b); <span class="comment">// 使用函数模板</span></span><br><span class="line">    Stack&lt;<span class="type">double</span>&gt; doubleStack; <span class="comment">// 使用类模板</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模板使得可以编写高度</p>
<p>通用和可重用的代码，适用于各种数据类型。它在STL（标准模板库）中广泛应用，用于实现通用数据结构和算法。</p>
<h3 id="什么是析构函数（Destructor）？为什么它重要？-1"><a href="#什么是析构函数（Destructor）？为什么它重要？-1" class="headerlink" title="什么是析构函数（Destructor）？为什么它重要？"></a>什么是析构函数（Destructor）？为什么它重要？</h3><p><strong>回答：</strong> 析构函数是C++中的一个特殊成员函数，用于对象的清理和资源释放。析构函数的名称与类名相同，前面加上<code>~</code>符号。析构函数在以下情况下重要：</p>
<ul>
<li><p><strong>资源释放：</strong> 析构函数用于释放对象在其生命周期中分配的资源，如内存、文件句柄、数据库连接等。这有助于避免资源泄漏。</p>
</li>
<li><p><strong>对象生命周期控制：</strong> 析构函数确定了对象在销毁时应采取的行动，例如关闭文件或释放锁定。</p>
</li>
<li><p><strong>异常处理：</strong> 析构函数可以用于处理对象生命周期中的异常情况，确保资源在异常时得到释放。</p>
</li>
<li><p><strong>子类析构函数：</strong> 在继承中，基类的析构函数通常是虚的，以确保在销毁子类对象时正确调用基类析构函数，从而实现多态的析构。</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() &#123;</span><br><span class="line">        <span class="comment">// 构造函数的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123;</span><br><span class="line">        <span class="comment">// 析构函数的代码，用于释放资源</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>确保在需要时正确实现析构函数，以避免资源泄漏和不稳定的程序行为。</p>
<h3 id="什么是预处理器（Preprocessor）？它在C-x2F-C-中有什么作用？-1"><a href="#什么是预处理器（Preprocessor）？它在C-x2F-C-中有什么作用？-1" class="headerlink" title="什么是预处理器（Preprocessor）？它在C&#x2F;C++中有什么作用？"></a>什么是预处理器（Preprocessor）？它在C&#x2F;C++中有什么作用？</h3><p><strong>回答：</strong> 预处理器是C和C++编译过程中的一个独立阶段，用于在实际编译之前处理源代码。预处理器的主要作用包括：</p>
<ul>
<li><p><strong>宏替换：</strong> 预处理器可以替换源代码中的宏定义，例如使用<code>#define</code>定义的宏常量或宏函数。</p>
</li>
<li><p><strong>文件包含：</strong> 预处理器使用<code>#include</code>指令将其他文件的内容插入源文件中，允许代码的模块化组织。</p>
</li>
<li><p><strong>条件编译：</strong> 预处理器使用条件编译指令，如<code>#ifdef</code>和<code>#ifndef</code>，可以根据条件选择性地包含或排除代码块。</p>
</li>
<li><p><strong>注释删除：</strong> 预处理器删除源代码中的注释，以减小编译后的可执行文件的大小。</p>
</li>
<li><p><strong>宏展开：</strong> 预处理器展开宏，将宏调用替换为宏定义的实际内容。</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_VALUE 100 <span class="comment">// 宏定义</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  <span class="comment">// 文件包含</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">    <span class="comment">// 调试代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> value = MAX_VALUE; <span class="comment">// 宏替换</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>预处理器通过生成经过处理的源代码，然后将其传递给编译器进行编译，起到了代码预处理和条件编译的作用。</p>
<h3 id="什么是静态多态性（Static-Polymorphism）和动态多态性（Dynamic-Polymorphism）？它们之间有什么区别？"><a href="#什么是静态多态性（Static-Polymorphism）和动态多态性（Dynamic-Polymorphism）？它们之间有什么区别？" class="headerlink" title="什么是静态多态性（Static Polymorphism）和动态多态性（Dynamic Polymorphism）？它们之间有什么区别？"></a>什么是静态多态性（Static Polymorphism）和动态多态性（Dynamic Polymorphism）？它们之间有什么区别？</h3><p><strong>回答：</strong> </p>
<ul>
<li><strong>静态多态性（Static Polymorphism）：</strong> 静态多态性也称为编译时多态性，是在编译时确定函数调用的方式。它通常与函数重载（Function Overloading）相关，其中编译器根据函数名称、参数类型和个数来选择正确的函数版本。静态多态性的优点在于效率高，因为函数调用在编译时就已经解析，不需要额外的运行时开销。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Printing integer: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">double</span> y)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Printing double: &quot;</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">42</span>;</span><br><span class="line">    <span class="type">double</span> b = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(a); <span class="comment">// 编译时确定调用 print(int)</span></span><br><span class="line">    <span class="built_in">print</span>(b); <span class="comment">// 编译时确定调用 print(double)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>动态多态性（Dynamic Polymorphism）：</strong> 动态多态性也称为运行时多态性，是在运行时根据对象的实际类型来确定函数调用的方式。它通常与虚函数（Virtual Function）和继承相关。通过虚函数，基类指针或引用可以调用派生类的函数，而具体的函数实现是在运行时根据对象的类型来选择的。动态多态性的优点在于它支持多态行为，允许基类接口处理派生类对象。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a shape&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a circle&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Shape* shapePtr = <span class="keyword">new</span> <span class="built_in">Circle</span>();</span><br><span class="line">    shapePtr-&gt;<span class="built_in">draw</span>(); <span class="comment">// 运行时确定调用 Circle 的 draw 函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> shapePtr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>区别：</p>
<ul>
<li>静态多态性在编译时确定函数调用，效率高，但不支持多态行为。</li>
<li>动态多态性在运行时确定函数调用，支持多态行为，但可能带来一些运行时开销。</li>
</ul>
<p>通常，C++开发中根据需要选择使用静态多态性或动态多态性，以满足特定的设计需求。</p>
<h3 id="什么是智能指针（Smart-Pointer）？在C-中有哪些智能指针？"><a href="#什么是智能指针（Smart-Pointer）？在C-中有哪些智能指针？" class="headerlink" title="什么是智能指针（Smart Pointer）？在C++中有哪些智能指针？"></a>什么是智能指针（Smart Pointer）？在C++中有哪些智能指针？</h3><p><strong>回答：</strong> 智能指针是C++中的一种数据类型，用于管理动态分配的内存，以帮助避免内存泄漏和悬挂指针等问题。C++标准库提供了以下几种智能指针：</p>
<ul>
<li><strong><code>std::unique_ptr</code>：</strong><ul>
<li><code>std::unique_ptr</code>表示独占所有权的智能指针，确保只有一个指针可以拥有和管理特定内存块。</li>
<li>移动语义允许将所有权从一个<code>unique_ptr</code>转移给另一个。</li>
<li>通常用于实现独占拥有的情况。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::unique_ptr&lt;<span class="type">int</span>&gt; ptr = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>std::shared_ptr</code>：</strong><ul>
<li><code>std::shared_ptr</code>表示多个智能指针可以共享相同内存块的所有权。</li>
<li>使用引用计数来跟踪共享对象的引用数，当引用计数为零时，自动释放内存。</li>
<li>适用于多个指针需要访问相同对象的情况。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; ptr1 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; ptr2 = ptr1; <span class="comment">// 共享所有权</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>std::weak_ptr</code>：</strong><ul>
<li><code>std::weak_ptr</code>是一种弱引用智能指针，它允许共享对象的引用但不增加引用计数。</li>
<li>主要用于解决<code>std::shared_ptr</code>的循环引用问题，防止内存泄漏。</li>
<li>可以通过<code>std::shared_ptr</code>转换为<code>std::weak_ptr</code>。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; shared = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line">std::weak_ptr&lt;<span class="type">int</span>&gt; weak = shared;</span><br></pre></td></tr></table></figure>

<p>智能指针的主要作用在于自动管理动态分配的内存，避免手动调用<code>new</code>和<code>delete</code>，从而提高代码的可维护性和安全性。</p>
<h3 id="什么是异常处理（Exception-Handling）？在C-中如何进行异常处理？"><a href="#什么是异常处理（Exception-Handling）？在C-中如何进行异常处理？" class="headerlink" title="什么是异常处理（Exception Handling）？在C++中如何进行异常处理？"></a>什么是异常处理（Exception Handling）？在C++中如何进行异常处理？</h3><p><strong>回答：</strong> 异常处理是一种程序设计和错误处理的方法，用于处理程序在运行时遇到的异常情况。异常是指不寻常的、不正常的情况，可能导致程序中断或不正常行为。在C++中，异常处理可以通过以下关键字和机制来实现：</p>
<ul>
<li><strong><code>try</code>：</strong> 使用<code>try</code>关键字来定义一个包含可能引发异常的代码块。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 可能引发异常的代码</span></span><br><span class="line">&#125; <span class="built_in">catch</span> (ExceptionType1 e1) &#123;</span><br><span class="line">    <span class="comment">// 处理 ExceptionType1 异常的代码</span></span><br><span class="line">&#125; <span class="built_in">catch</span> (ExceptionType2 e2) &#123;</span><br><span class="line">    <span class="comment">// 处理 ExceptionType2 异常的代码</span></span><br><span class="line">&#125; <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">    <span class="comment">// 处理其他异常的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>throw</code>：</strong> 使用<code>throw</code>关键字来引发异常。可以引发各种类型的异常，包括内置类型、自定义类型、标准库异常等。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (error_condition) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">MyException</span>(<span class="string">&quot;An error occurred&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong><code>catch</code>：</strong> 使用<code>catch</code>关键字来捕获并处理特定类型的异常。一个<code>try</code>块可以有多个<code>catch</code>块，用于处理不同类型的异常。</p>
</li>
<li><p><strong>自定义异常类型：</strong> 可以自定义异常类型，通过继承自<code>std::exception</code>或其派生类，来表示特定的异常情况，并提供异常信息。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyException</span> : <span class="keyword">public</span> std::exception &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyException</span>(<span class="type">const</span> <span class="type">char</span>* message) : <span class="built_in">message_</span>(message) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">what</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> message_.<span class="built_in">c_str</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string message_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>std::exception</code>：</strong> <code>std::exception</code>是C++标准库中定义的</li>
</ul>
<p>基本异常类，可以用作自定义异常类型的基类。</p>
<p>异常处理允许程序在遇到异常情况时从当前执行路径跳转到异常处理代码，从而实现错误处理和程序稳定性。合理的异常处理可以确保程序在发生异常时不会崩溃，并提供有关异常原因的信息，以便进行故障排除和修复。</p>
<h3 id="什么是静态多态性（Static-Polymorphism）和动态多态性（Dynamic-Polymorphism）？它们之间有什么区别？-1"><a href="#什么是静态多态性（Static-Polymorphism）和动态多态性（Dynamic-Polymorphism）？它们之间有什么区别？-1" class="headerlink" title="什么是静态多态性（Static Polymorphism）和动态多态性（Dynamic Polymorphism）？它们之间有什么区别？"></a>什么是静态多态性（Static Polymorphism）和动态多态性（Dynamic Polymorphism）？它们之间有什么区别？</h3><p><strong>回答：</strong> </p>
<ul>
<li><strong>静态多态性（Static Polymorphism）：</strong> 静态多态性也称为编译时多态性，是在编译时确定函数调用的方式。它通常与函数重载（Function Overloading）相关，其中编译器根据函数名称、参数类型和个数来选择正确的函数版本。静态多态性的优点在于效率高，因为函数调用在编译时就已经解析，不需要额外的运行时开销。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Printing integer: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">double</span> y)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Printing double: &quot;</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">42</span>;</span><br><span class="line">    <span class="type">double</span> b = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(a); <span class="comment">// 编译时确定调用 print(int)</span></span><br><span class="line">    <span class="built_in">print</span>(b); <span class="comment">// 编译时确定调用 print(double)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>动态多态性（Dynamic Polymorphism）：</strong> 动态多态性也称为运行时多态性，是在运行时根据对象的实际类型来确定函数调用的方式。它通常与虚函数（Virtual Function）和继承相关。通过虚函数，基类指针或引用可以调用派生类的函数，而具体的函数实现是在运行时根据对象的类型来选择的。动态多态性的优点在于它支持多态行为，允许基类接口处理派生类对象。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a shape&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a circle&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Shape* shapePtr = <span class="keyword">new</span> <span class="built_in">Circle</span>();</span><br><span class="line">    shapePtr-&gt;<span class="built_in">draw</span>(); <span class="comment">// 运行时确定调用 Circle 的 draw 函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> shapePtr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>区别：</p>
<ul>
<li>静态多态性在编译时确定函数调用，效率高，但不支持多态行为。</li>
<li>动态多态性在运行时确定函数调用，支持多态行为，但可能带来一些运行时开销。</li>
</ul>
<p>通常，C++开发中根据需要选择使用静态多态性或动态多态性，以满足特定的设计需求。</p>
<p>我明白了，让我为您提供一些新的问题和答案，以避免重复：</p>
<h3 id="什么是C-中的引用（Reference）？"><a href="#什么是C-中的引用（Reference）？" class="headerlink" title="什么是C++中的引用（Reference）？"></a>什么是C++中的引用（Reference）？</h3><p><strong>回答：</strong> 引用是C++中的一种数据类型，它允许一个变量引用（别名）另一个变量。引用提供了对变量的间接访问方式，使得可以通过不同的名字访问相同的内存位置。引用的主要特点包括：</p>
<ul>
<li>引用必须在定义时初始化，并且一旦初始化，就不能再引用其他对象。</li>
<li>引用在使用时不需要解引用操作（使用<code>*</code>符号），因为它们本身就是别名。</li>
<li>引用通常用于函数参数，以便通过引用传递参数，从而避免复制大量数据。</li>
</ul>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span>&amp; ref = x; <span class="comment">// 引用 x，ref 成为 x 的别名</span></span><br><span class="line"></span><br><span class="line">ref = <span class="number">10</span>;     <span class="comment">// 修改 x 的值，ref 也会跟着变成 10</span></span><br></pre></td></tr></table></figure>

<p>引用在C++中广泛用于函数参数传递、操作符重载和STL中，以提供更高效的代码和更自然的语法。</p>
<h3 id="什么是C-中的析构函数（Destructor）？"><a href="#什么是C-中的析构函数（Destructor）？" class="headerlink" title="什么是C++中的析构函数（Destructor）？"></a>什么是C++中的析构函数（Destructor）？</h3><p><strong>回答：</strong> 析构函数是C++中的一种特殊成员函数，它用于在对象生命周期结束时执行必要的清理和资源释放操作。析构函数的名称与类名相同，但前面加上波浪号（<code>~</code>）。</p>
<p>析构函数的主要作用包括：</p>
<ul>
<li>释放对象在其生命周期中分配的资源，如内存、文件句柄、数据库连接等。</li>
<li>控制对象的生命周期，确保在对象销毁时执行必要的操作。</li>
<li>处理对象生命周期中的异常情况，以确保资源不会泄漏。</li>
</ul>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FileHandler</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FileHandler</span>(<span class="type">const</span> std::string&amp; filename) &#123;</span><br><span class="line">        file = std::<span class="built_in">fopen</span>(filename.<span class="built_in">c_str</span>(), <span class="string">&quot;r&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!file) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to open file&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">FileHandler</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (file) &#123;</span><br><span class="line">            std::<span class="built_in">fclose</span>(file);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他成员函数，用于文件操作</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::FILE* file;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>FileHandler</code>类的析构函数用于关闭文件句柄，确保文件在对象生命周期结束时被正确关闭。</p>
<h3 id="C-中的多重继承是什么？它有什么特点和潜在的问题？"><a href="#C-中的多重继承是什么？它有什么特点和潜在的问题？" class="headerlink" title="C++中的多重继承是什么？它有什么特点和潜在的问题？"></a>C++中的多重继承是什么？它有什么特点和潜在的问题？</h3><p><strong>回答：</strong> 多重继承是C++中的一种面向对象编程概念，它允许一个类从多个基类继承属性和行为。多重继承的特点和潜在问题包括：</p>
<p>特点：</p>
<ul>
<li>一个派生类可以继承多个基类的成员，包括数据成员和成员函数。</li>
<li>可以实现不同类之间的复杂关系，例如混合多个不同类型的功能。</li>
</ul>
<p>潜在问题：</p>
<ul>
<li><strong>菱形继承问题（Diamond Inheritance Problem）：</strong> 当一个类通过多条路径继承同一个基类时，可能导致同一基类的多个实例被创建，引发二义性。</li>
<li><strong>函数名冲突：</strong> 如果多个基类具有相同名称的成员函数，可能导致函数名冲突，需要使用作用域解析运算符（<code>::</code>）来解决。</li>
<li><strong>复杂性增加：</strong> 多重继承会增加类之间的复杂性，使得代码更难理解和维护。</li>
</ul>
<p>解决多重继承问题的方法包括虚继承（使用<code>virtual</code>继承来解决菱形继承问题）、作用域解析运算符（<code>::</code>）、以及合理的设计，避免深层次和复杂的继承结构。</p>
<p>多重继承应慎重使用，通常在需要时才使用，以避免引发潜在问题。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>C/C++</tag>
        <tag>知识手册</tag>
      </tags>
  </entry>
  <entry>
    <title>C++面试题总结（分类版）</title>
    <url>/2023/08/23/C-%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93%EF%BC%88%E5%88%86%E7%B1%BB%E7%89%88%EF%BC%89/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>C++面试题分知识点重新排了一下</p>
<span id="more"></span>

<h3 id="C-x2F-C-基础"><a href="#C-x2F-C-基础" class="headerlink" title="C&#x2F;C++ 基础"></a>C&#x2F;C++ 基础</h3><ol>
<li><p><strong>什么是C++？</strong></p>
<p><strong>回答：</strong> C++是一种通用的、面向对象的编程语言，是C语言的扩展，它结合了高级语言的特性和低级语言的控制。C++支持面向对象编程、泛型编程和过程式编程，具有丰富的标准库。</p>
</li>
<li><p><strong>什么是C++的优点和特点？</strong></p>
<p><strong>回答：</strong> C++的优点包括：</p>
<ul>
<li>面向对象编程：支持类、继承、多态等面向对象特性。</li>
<li>性能：C++允许底层内存控制，可实现高性能的代码。</li>
<li>标准库：拥有强大的标准库，提供各种数据结构和算法。</li>
<li>多范式：支持多种编程范式，如面向对象和泛型编程。</li>
</ul>
</li>
<li><p><strong>什么是C++的缺点？</strong></p>
<p><strong>回答：</strong> C++的缺点包括：</p>
<ul>
<li>复杂性：语法复杂，学习曲线陡峭。</li>
<li>内存管理：需要手动管理内存，容易导致内存泄漏和悬挂指针。</li>
<li>安全性：不如一些其他语言（如Java）那样严格的安全性。</li>
<li>移植性：不同编译器和平台之间的移植性有时较差。</li>
</ul>
</li>
<li><p><strong>C++和C的主要区别是什么？</strong></p>
<p><strong>回答：</strong> C++在C的基础上引入了面向对象编程的特性，主要区别包括：</p>
<ul>
<li>面向对象：C++支持类、继承、多态等面向对象特性，C不支持。</li>
<li>标准库：C++拥有更丰富的标准库，包括STL等。</li>
<li>引入了新的关键字和语法，如<code>class</code>、<code>new</code>、<code>delete</code>等。</li>
<li>兼容性：C++可以使用C的代码，但C不一定能使用C++的代码。</li>
</ul>
</li>
<li><p><strong>什么是C++标准库？</strong></p>
<p><strong>回答：</strong> C++标准库是一组标准化的函数、对象和模板，提供了各种数据结构和算法，以便C++程序员更轻松地开发应用程序。它包括输入输出、容器、算法、文件操作等多个部分，如STL（Standard Template Library）。</p>
</li>
<li><p><strong>C++中的const关键字有什么作用？</strong></p>
<p><strong>回答：</strong> <code>const</code>关键字用于声明常量，它有以下作用：</p>
<ul>
<li>声明常量变量，一旦赋值后不能修改。</li>
<li>声明常量指针，指针指向的内容不能通过指针修改。</li>
<li>声明常量成员函数，不允许修改对象的成员变量。</li>
</ul>
</li>
<li><p><strong>C++中的static关键字有什么作用？</strong></p>
<p><strong>回答：</strong> <code>static</code>关键字在C++中的作用包括：</p>
<ul>
<li>声明静态变量，这些变量在函数调用之间保持其值。</li>
<li>声明静态成员变量，这些成员变量属于类而不是对象。</li>
<li>声明静态成员函数，这些函数不属于特定对象，可通过类名直接访问。</li>
</ul>
</li>
<li><p><strong>C++中的指针和引用有什么区别？</strong></p>
<p><strong>回答：</strong> 指针和引用的区别包括：</p>
<ul>
<li><strong>初始化和赋值：</strong> 指针需要初始化，并可以在后续重新赋值，而引用必须在声明时初始化，并不能重新绑定到其他对象。</li>
<li><strong>符号和操作：</strong> 指针使用<code>*</code>和<code>-&gt;</code>来访问对象，而引用直接使用对象名。</li>
<li><strong>空值：</strong> 指针可以为空（null），引用不能。</li>
</ul>
</li>
<li><p><strong>C++中的重载（Overloading）是什么？</strong></p>
<p><strong>回答：</strong> 重载是C++中的特性，允许在同一作用域内定义多个同名函数，但它们具有不同的参数列表（参数类型或个数）。编译器根据函数调用时提供的参数来选择正确的函数版本。</p>
</li>
<li><p><strong>什么是C++中的运算符重载？</strong></p>
<p><strong>回答：</strong> 运算符重载是C++中的特性，允许对标准运算符（如<code>+</code>、<code>-</code>、<code>*</code>等）进行自定义定义，以便用于自定义数据类型的操作。运算符重载通过函数重载来实现，重载函数的名称是运算符本身。</p>
</li>
</ol>
<h3 id="内存管理和指针"><a href="#内存管理和指针" class="headerlink" title="内存管理和指针"></a>内存管理和指针</h3><ol start="11">
<li><p><strong>什么是内存泄漏？如何避免内存泄漏？</strong></p>
<p><strong>回答：</strong> 内存泄漏是指程序分配的内存在不再使用时未被释放，导致系统的可用内存逐渐减少。要避免内存泄漏，可以采取以下措施：</p>
<ul>
<li>始终匹配<code>new</code>和<code>delete</code>、<code>malloc</code>和<code>free</code>。</li>
<li>使用智能指针来自动管理内存。</li>
<li>适时释放不再使用的资源，如文件句柄、数据库连接等。</li>
<li>使用内置数组或STL容器而不是手动分配内存。</li>
</ul>
</li>
<li><p><strong>什么是智能指针（Smart Pointer）？在C++中有哪些智能指针？</strong></p>
<p><strong>回答：</strong> 智能指针是C++中的一种数据类型，用于管理动态分配的内存，以避免内存泄漏和悬挂指针等问题。C++标准库提供了以下几种智能指针：</p>
<ul>
<li><code>std::unique_ptr</code>：表示独占所有权的智能指针。</li>
<li><code>std::shared_ptr</code>：表示多个智能指针可以共享相同内存块的所有权。</li>
<li><code>std::weak_ptr</code>：是一种弱引用智能指针，用于解决<code>std::shared_ptr</code>的循环引用问题。</li>
</ul>
</li>
<li><p><strong>什么是堆（Heap）和栈（Stack）？</strong></p>
<p><strong>回答：</strong> 堆和栈是计算机内存中的两个主要区域：</p>
<ul>
<li><strong>栈（Stack）：</strong> 用于存储函数调用、局部变量等短期存储的数据。它的管理由编译器自动处理，通常具有较小的固定大小。</li>
<li><strong>堆（Heap）：</strong> 用于存储动态分配的数据，如通过<code>new</code>、<code>malloc</code>等分配的内存。堆的管理需要显式释放，否则可能导致内存泄漏。</li>
</ul>
</li>
<li><p><strong>什么是指针和引用？它们之间有什么区别？</strong></p>
<p><strong>回答：</strong> 指针和引用的区别包括：</p>
<ul>
<li><strong>初始化和赋值：</strong> 指针需要初始化，并可以在后续重新赋值，而引用必须在声明时初始化，并不能重新绑定到其他对象。</li>
<li><strong>符号和操作：</strong> 指针使用<code>*</code>和<code>-&gt;</code>来访问对象，而引用直接使用对象名。</li>
<li><strong>空值：</strong> 指针可以为空（null），引用不能。</li>
</ul>
</li>
<li><p><strong>什么是野指针（Dangling Pointer）？如何避免野指针问题？</strong></p>
<p><strong>回答：</strong> 野指针是指指向已释放或未分配内存的指针，访问野指针会导致未定义的行为。为避免野指针问题，可以采取以下措施：</p>
<ul>
<li>在释放内存后，将指针设置为null或空指针。</li>
<li>避免使用未初始化的指针。</li>
<li>使用智能指针来自动管理内存。</li>
</ul>
</li>
</ol>
<h3 id="类和面向对象编程"><a href="#类和面向对象编程" class="headerlink" title="类和面向对象编程"></a>类和面向对象编程</h3><ol start="16">
<li><p><strong>什么是类和对象？</strong></p>
<p><strong>回答：</strong> 类是一种抽象数据类型，定义了数据成员和成员函数，对象是类的实例。类描述了对象的属性和行为。</p>
</li>
<li><p><strong>什么是封装（Encapsulation）？</strong></p>
<p><strong>回答：</strong> 封装是面向对象编程的原则，它将数据和操作数据的方法封装在一个单元中，防止外部直接访问数据，提供了数据隐藏和抽象。</p>
</li>
<li><p><strong>什么是继承（Inheritance）？C++支持多重继承吗？</strong></p>
<p><strong>回答：</strong> 继承是面向对象编程的概念，允许一个类（派生类）从另一个类（基类）继承属性和行为。C++支持多重继承，即一个派生类可以从多个基类继承。</p>
</li>
<li><p><strong>什么是多态性（Polymorphism）？C++中如何实现多态性？</strong></p>
<p><strong>回答：</strong> 多态性是面向对象编程的概念，它允许不同对象对相同的消息做出不同的响应。在C++中，多态性通过虚函数和函数重载来实现。</p>
</li>
<li><p><strong>什么是虚函数（Virtual Function）和纯虚函数（Pure Virtual Function）？</strong></p>
<p><strong>回答：</strong> 虚函数是用关键字<code>virtual</code>声明的类成员函数，它允许在派生类中进行重写（覆盖）。纯虚函数是一个没有实现的虚函数，它的声明以<code>= 0</code>结尾，用于定义接口。</p>
</li>
<li><p><strong>什么是构造函数和析构函数？它们的作用是什么？</strong></p>
<p><strong>回答：</strong> 构造函数是用于对象初始化的特殊成员函数，它在对象创建时自动调用。析构函数用于对象销毁时执行必要的清理和资源释放操作。构造函数和析构函数的名称与类名相同，但析构函数前面加上波浪号（<code>~</code>）。</p>
</li>
</ol>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><ol start="22">
<li><p><strong>什么是异常处理（Exception Handling）？在C++中如何进行异常处理？</strong></p>
<p><strong>回答：</strong> 异常处理是一种程序设计和错误处理的方法，用于处理程序在运行时遇到的异常情况。异常是指不寻常的、不正常的情况，可能导致程序中断或不正常行为。在C++中，异常处理可以通过<code>try</code>、<code>throw</code>和<code>catch</code>关键字来实现。</p>
</li>
<li><p><strong>什么是RAII（资源获取即初始化）？它在C++中有什么作用？</strong></p>
<p><strong>回答：</strong> RAII（Resource Acquisition Is Initialization）是C++中的一种编程范式，它强调资源的获取和释放应与对象的生命周期绑定。RAII的核心思想是在对象的构造函数中获取资源，在析构函数中释放资源，这样可以确保资源在对象生命周期结束时被正确释放，避免资源泄漏。RAII用于管理各种资源，包括内存、文件句柄、数据库连接等。</p>
</li>
</ol>
<h3 id="文件和输入输出"><a href="#文件和输入输出" class="headerlink" title="文件和输入输出"></a>文件和输入输出</h3><ol start="24">
<li><p><strong>如何在C++中读写文件？</strong></p>
<p><strong>回答：</strong> 在C++中，可以使用<code>&lt;fstream&gt;</code>头文件中的<code>ifstream</code>和<code>ofstream</code>类来进行文件的读写操作。通常的步骤包括打开文件、读写数据、关闭文件。同时，C++还提供了<code>&lt;iostream&gt;</code>中的输入输出流对象，如<code>cin</code>和<code>cout</code>，用于标准输入输出。</p>
</li>
<li><p><strong>什么是C++的流（Stream）？有哪些常用的流对象？</strong></p>
<p><strong>回答：</strong> 流是C++中用于输入和输出的抽象概念，它将数据流转化为字符流，使得数据的输入和输出都可以通过流进行。常用的流对象包括：</p>
<ul>
<li><code>cin</code>：标准输入流，用于从键盘读取输入。</li>
<li><code>cout</code>：标准输出流，用于向屏幕输出。</li>
<li><code>ifstream</code>：用于从文件读取输入。</li>
<li><code>ofstream</code>：用于向文件写入输出。</li>
<li><code>stringstream</code>：用于处理字符串的输入输出。</li>
</ul>
</li>
<li><p><strong>C++中的输入输出运算符是什么？如何重载它们？</strong></p>
<p><strong>回答：</strong> C++中的输入输出运算符是<code>&lt;&lt;</code>和<code>&gt;&gt;</code>，它们通常用于<code>cout</code>和<code>cin</code>对象以及文件流对象的输入输出。您可以通过运算符重载来自定义类的输入输出行为，重载函数的名称是运算符本身，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> MyClass&amp; obj) &#123;</span><br><span class="line">        os &lt;&lt; obj.data; <span class="comment">// 自定义输出行为</span></span><br><span class="line">        <span class="keyword">return</span> os;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> std::istream&amp; <span class="keyword">operator</span>&gt;&gt;(std::istream&amp; is, MyClass&amp; obj) &#123;</span><br><span class="line">        is &gt;&gt; obj.data; <span class="comment">// 自定义输入行为</span></span><br><span class="line">        <span class="keyword">return</span> is;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="模板和泛型编程"><a href="#模板和泛型编程" class="headerlink" title="模板和泛型编程"></a>模板和泛型编程</h3><ol start="27">
<li><p><strong>什么是模板（Template）？在C++中如何使用模板？</strong></p>
<p><strong>回答：</strong> 模板是C++中的一种机制，允许编写通用的代码以适应不同的数据类型。模板以<code>template</code>关键字开始，可以定义函数模板和类模板。</p>
</li>
<li><p><strong>什么是STL（Standard Template Library）？它包括哪些常见组件？</strong></p>
<p><strong>回答：</strong> STL是C++标准库的一部分，提供了许多常用的数据结构和算法，包括容器（如向量、链表、映射）、迭代器、算法（如排序、查找、遍历）等。STL使C++程序员能够更轻松地处理数据和执行常见的操作。</p>
</li>
</ol>
<h3 id="编译和预处理器"><a href="#编译和预处理器" class="headerlink" title="编译和预处理器"></a>编译和预处理器</h3><ol start="29">
<li><p><strong>什么是预处理器（Preprocessor）？它在C&#x2F;C++中有什么作用？</strong></p>
<p><strong>回答：</strong> 预处理器是C&#x2F;C++编译过程的一部分，用于在实际编译之前对源代码进行处理。它的主要作用包括：</p>
<ul>
<li>处理预处理指令，如<code>#include</code>、<code>#define</code>等。</li>
<li>进行宏替换。</li>
<li>条件编译，根据条件编译部分代码。</li>
<li>生成头文件的包含关系。<br>预处理器的工作是在实际编译之前进行的，它可以影响源代码的文本，但不会涉及编译后的机器代码生成。</li>
</ul>
</li>
</ol>
<h3 id="面试中常见问题"><a href="#面试中常见问题" class="headerlink" title="面试中常见问题"></a>面试中常见问题</h3><ol start="30">
<li><p><strong>为什么C++中需要析构函数？</strong></p>
<p><strong>回答：</strong> 析构函数是C++中的特殊成员函数，用于在对象生命周期结束时执行必要的清理和资源释放操作。它是必要的，因为C++允许手动管理资源，如内存、文件句柄等，析构函数确保这些资源在对象销毁时被正确释放，避免资源泄漏。</p>
</li>
<li><p><strong>什么是函数重载（Function Overloading）？举例说明。</strong></p>
<p><strong>回答：</strong> 函数重载是指在同一作用域内定义多个同名函数，但它们具有不同的参数列表（参数类型或个数）。编译器根据函数调用时提供的参数来选择正确的函数版本。示例如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Printing integer: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">double</span> y)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Printing double: &quot;</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">42</span>;</span><br><span class="line">    <span class="type">double</span> b = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(a); <span class="comment">// 编译时确定调用 print(int)</span></span><br><span class="line">    <span class="built_in">print</span>(b); <span class="comment">// 编译时确定调用 print(double)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>C++中的多重继承是什么？它有什么特点和潜在的问题？</strong></p>
<p><strong>回答：</strong> 多重继承是C++中的面向对象编程概念，允许一个类从多个基类继承属性和行为。多重继承的特点和潜在问题包括：<br>特点：</p>
<ul>
<li>一个派生类可以继承多个基类的成员，包括数据成员和成员函数。</li>
<li>可以实现不同类之间的复杂关系，例如混合多个不同类型的功能。<br>潜在问题：</li>
<li><strong>菱形继承问题（Diamond Inheritance Problem）：</strong> 当一个类通过多条路径继承同一个基类时，可能导致同一基类的多个实例被创建，引发二义性。</li>
<li><strong>函数名冲突：</strong> 如果多个基类具有相同名称的成员函数，可能导致函数名冲突，需要使用作用域解析运算符来解决。</li>
</ul>
</li>
<li><p><strong>什么是静态多态性（Static Polymorphism）和动态多态性（Dynamic Polymorphism）？它们之间有什么区别？</strong></p>
<p><strong>回答：</strong> </p>
<ul>
<li><p><strong>静态多态性（Static Polymorphism）：</strong> 静态多态性是在编译时确定函数调用的多态性，通常通过函数重载和运算符重载实现。编译器在编译时选择正确的函数版本。</p>
</li>
<li><p><strong>动态多态性（Dynamic Polymorphism）：</strong> 动态多态性是在运行时确定函数调用的多态性，通常通过虚函数实现。运行时根据对象的实际类型来调用适当的函数版本。这通常涉及基类指针或引用指向派生类对象。</p>
</li>
</ul>
</li>
<li><p><strong>什么是C++中的引用（Reference）？</strong></p>
<p><strong>回答：</strong> 引用是C++中的一种数据类型，用于创建变量的别名。它允许在不使用指针的情况下对变量进行操作，并且必须在声明时进行初始化。引用通常用于函数参数传递和返回值，以避免复制大型对象。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>C/C++</tag>
        <tag>知识手册</tag>
      </tags>
  </entry>
  <entry>
    <title>线程与协程异同比较</title>
    <url>/2023/08/19/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%8D%8F%E7%A8%8B%E5%BC%82%E5%90%8C%E6%AF%94%E8%BE%83/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>线程和协程都是用于多任务并发编程的概念，但它们有很大的不同之处。在本文中，我们将深入讨论线程和协程的异同点，并提供一些示例代码来说明它们的用法。</p>
<span id="more"></span>

<h2 id="线程（Threads）"><a href="#线程（Threads）" class="headerlink" title="线程（Threads）"></a>线程（Threads）</h2><p>线程是操作系统级别的并发执行单位，它是多任务编程的一种方式。每个线程都有自己的堆栈和程序计数器，可以独立运行。线程之间可以并行执行，共享进程的内存空间，因此可以访问相同的全局变量和数据结构。</p>
<h3 id="线程的特点"><a href="#线程的特点" class="headerlink" title="线程的特点"></a>线程的特点</h3><ol>
<li><p><strong>并行执行</strong>：线程可以并行执行，利用多核处理器的优势，提高程序性能。</p>
</li>
<li><p><strong>共享内存</strong>：线程可以访问相同进程的内存空间，因此可以轻松共享数据。</p>
</li>
<li><p><strong>适用于长时间任务</strong>：线程适用于执行长时间运行的任务，例如网络通信、文件读写等。</p>
</li>
</ol>
<h3 id="线程的示例代码"><a href="#线程的示例代码" class="headerlink" title="线程的示例代码"></a>线程的示例代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello from thread!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(hello)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="协程（Coroutines）"><a href="#协程（Coroutines）" class="headerlink" title="协程（Coroutines）"></a>协程（Coroutines）</h2><p>协程是一种更轻量级的并发编程概念，它允许函数在执行过程中暂停并在稍后恢复执行，而不需要创建新的线程。协程通常在函数级别上实现，而不是线程级别。</p>
<h3 id="协程的特点"><a href="#协程的特点" class="headerlink" title="协程的特点"></a>协程的特点</h3><ol>
<li><p><strong>轻量级</strong>：协程比线程更轻量级，创建和销毁协程的开销较小。</p>
</li>
<li><p><strong>避免并发问题</strong>：协程通常不会涉及共享内存，因此避免了许多并发问题，如竞态条件和死锁。</p>
</li>
<li><p><strong>适用于 I&#x2F;O 密集型任务</strong>：协程适用于执行 I&#x2F;O 密集型任务，如网络请求、文件操作等。</p>
</li>
</ol>
<h3 id="协程的示例代码"><a href="#协程的示例代码" class="headerlink" title="协程的示例代码"></a>协程的示例代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;coroutine&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Task</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">auto</span> <span class="title">get_return_object</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Task&#123;&#125;; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">auto</span> <span class="title">initial_suspend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> std::suspend_always&#123;&#125;; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">auto</span> <span class="title">final_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> std::suspend_always&#123;&#125;; &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">return_void</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">await_suspend</span><span class="params">(std::coroutine_handle&lt;&gt; h)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Task is suspended&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        h.<span class="built_in">resume</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Task <span class="title">myCoroutine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">co_await</span> std::suspend_always&#123;&#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Coroutine resumed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">myCoroutine</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="异同点比较"><a href="#异同点比较" class="headerlink" title="异同点比较"></a>异同点比较</h2><h3 id="1-并发级别"><a href="#1-并发级别" class="headerlink" title="1. 并发级别"></a>1. 并发级别</h3><ul>
<li><strong>线程</strong>：线程是操作系统级别的并发执行单位，可以并行执行在多核处理器上。</li>
<li><strong>协程</strong>：协程是函数级别的并发单位，通常在单个线程内执行，不能并行执行。</li>
</ul>
<h3 id="2-内存和开销"><a href="#2-内存和开销" class="headerlink" title="2. 内存和开销"></a>2. 内存和开销</h3><ul>
<li><strong>线程</strong>：线程的创建和销毁开销较大，因为每个线程都有自己的堆栈和上下文。线程通常需要更多的内存。</li>
<li><strong>协程</strong>：协程轻量级，创建和销毁开销小。协程通常需要较少的内存。</li>
</ul>
<h3 id="3-共享状态"><a href="#3-共享状态" class="headerlink" title="3. 共享状态"></a>3. 共享状态</h3><ul>
<li><strong>线程</strong>：线程之间可以轻松共享内存，但需要考虑同步和竞态条件。</li>
<li><strong>协程</strong>：协程通常不涉及共享内存，因此避免了大部分并发问题。</li>
</ul>
<h3 id="4-适用场景"><a href="#4-适用场景" class="headerlink" title="4. 适用场景"></a>4. 适用场景</h3><ul>
<li><strong>线程</strong>：适用于长时间运行的任务，利用多核处理器的并行性。</li>
<li><strong>协程</strong>：适用于 I&#x2F;O 密集型任务，避免了线程的开销和并发问题。</li>
</ul>
<p>综上所述，线程和协程在多任务编程中有不同的优势和用途。线程适用于需要并行执行的长时间任务，而协程适用于避免共享内存和处理 I&#x2F;O 密集型任务。在实际应用中，可以根据具体的需求选择合适的并发模型。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>内联函数和函数调用之间的主要区别</title>
    <url>/2023/08/15/%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E4%B9%8B%E9%97%B4%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>内联函数和普通函数调用之间有一些关键区别，它们影响了编译器如何处理函数以及程序的性能。下面是内联函数和函数调用之间的主要区别：</p>
<span id="more"></span>

<p><strong>1.编译时机制：</strong></p>
<ul>
<li>内联函数：内联函数是在编译时展开的，编译器会将函数体的代码复制到每个调用点，并消除函数调用的开销。</li>
<li>函数调用：普通函数调用是在运行时进行的，程序在运行时跳转到函数的地址执行代码。</li>
</ul>
<p><strong>2. 调用开销：</strong></p>
<ul>
<li>内联函数：由于内联函数是在调用点展开的，所以没有函数调用的开销，没有函数栈帧的创建和销毁，通常比函数调用更高效。</li>
<li>函数调用：函数调用涉及跳转到函数的地址、保存上下文、分配函数栈帧、传递参数等开销，相对较慢。</li>
</ul>
<p><strong>3. 代码膨胀：</strong></p>
<ul>
<li>内联函数：内联函数的代码会在每个调用点都复制一份，可能导致代码膨胀，增加可执行文件的大小。</li>
<li>函数调用：函数调用不会导致代码膨胀，函数的代码只有一份。</li>
</ul>
<p><strong>4. 适用场景：</strong></p>
<ul>
<li>内联函数：适用于短小、频繁调用的函数，如简单的getter和setter函数、数学运算等。</li>
<li>函数调用：适用于复杂的函数或递归函数。</li>
</ul>
<p><strong>5. 代码可读性：</strong></p>
<ul>
<li>内联函数：内联函数通常将函数体的代码嵌入到调用点，可能会导致可读性较差的代码。</li>
<li>函数调用：函数调用可以提高代码的可读性，因为它将具体的实现分离出来。</li>
</ul>
<p><strong>6. 语法：</strong></p>
<ul>
<li>内联函数：使用 <code>inline</code> 关键字进行声明和定义。</li>
<li>函数调用：直接调用函数名。</li>
</ul>
<p>下面是一个示例，演示了内联函数和函数调用之间的区别：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 内联函数</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数调用</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">subtract</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">5</span>, y = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> result1 = <span class="built_in">add</span>(x, y);        <span class="comment">// 内联函数展开为 x + y</span></span><br><span class="line">    <span class="type">int</span> result2 = <span class="built_in">subtract</span>(x, y);   <span class="comment">// 函数调用 subtract(x, y)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总之，内联函数和函数调用之间的选择取决于代码的需求和性能优化。内联函数可以提高性能，但可能导致代码膨胀，而函数调用具有更好的代码结构和可读性。在实际编程中，需要根据具体情况权衡二者的利弊。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中string相加为什么有时中间会出现E</title>
    <url>/2023/12/28/C-%E4%B8%ADstring%E7%9B%B8%E5%8A%A0%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E6%97%B6%E4%B8%AD%E9%97%B4%E4%BC%9A%E5%87%BA%E7%8E%B0E/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><span id="more"></span>

<p>在C++中，使用 <code>+</code> 运算符进行字符串相加时，不会出现额外的字符如 “E”。如果字符串相加的结果中看到 “E”，可能是因为其中的一个字符串是以 null 字符 (<code>&#39;\0&#39;</code>) 结尾的 C 风格字符串，而另一个是使用 C++ 的 <code>std::string</code> 表示的。</p>
<p>在 C 风格字符串中，字符串的结束是由 null 字符 (<code>&#39;\0&#39;</code>) 来标志的。如果一个字符串的末尾没有 null 字符，C++ 在处理时可能会导致错误。</p>
<p>例如，考虑以下情况：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* cString = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    std::string cppString = <span class="string">&quot;World&quot;</span>;</span><br><span class="line"></span><br><span class="line">    std::string result = cString + cppString;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>cString</code> 是一个 C 风格字符串，而 <code>cppString</code> 是一个 <code>std::string</code>。由于 <code>cString</code> 是以 null 字符结尾的，当它与 <code>cppString</code> 相加时，<code>+</code> 运算符会继续附加 <code>cppString</code> 的内容，但是在结果字符串中可能会有问题。</p>
<p>为了避免这种问题，可以确保 C++ 中的字符串都是使用 <code>std::string</code> 类型表示。如果需要将 C 风格字符串与 <code>std::string</code> 进行操作，可以使用 <code>std::string</code> 的构造函数来显式地创建 <code>std::string</code> 对象：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::string result = std::<span class="built_in">string</span>(cString) + cppString;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>2024新年快乐</title>
    <url>/2024/01/01/2024%E6%96%B0%E5%B9%B4%E5%BF%AB%E4%B9%90/</url>
    <content><![CDATA[<p><img src="/../images/IMG_2717290966EE-1-4099087.jpg" alt="IMG_2717290966EE-1"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>2023真是转瞬即逝啊！</p>
<span id="more"></span>



<p>每次到总结的时候又不知道该说些什么，不顾我觉得过去的2023年还是挺充实的。对于保持记录这种事情上，我不知道为啥有种莫名的抗拒，是不是觉得说出来的话就不是心里话了，哈哈，正经人谁写日记呢。23年确实是不断思索和启发的一年，上半年处于半摆烂状态，每天都能躺着刷视频从早看到晚，对于今后的人生选择也懒得去思索。</p>
<p><img src="/../images/image-20240104130750361.png" alt="image-20240104130750361"></p>
<p><img src="/../images/image-20240104130810673.png" alt="image-20240104130810673"></p>
<p>后面也慢慢开始尝试各种新的生活方式，目前仍处于并将长期处于探索新生活的阶段。尤其是重拾了一些多年前的兴趣，比如重拾了毛笔字。。。</p>
<p><img src="/../images/IMG_AC502EFCC7B2-1.jpeg" alt="IMG_AC502EFCC7B2-1"></p>
<p>（混进去了兰亭序。。。）</p>
<p>用多邻国学了粤语，感觉实在没学到啥东西</p>
<p><img src="/../images/image-20240104130854950.png" alt="image-20240104130854950"></p>
<p>重拾了吉他，还粗略地学习了一下音阶，没图就不放了。</p>
<p>2024打算再系统学习一下乐理知识和电钢琴，目前要说的流水账就这些。</p>
]]></content>
      <categories>
        <category>随笔</category>
        <category>日记</category>
      </categories>
      <tags>
        <tag>吃</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt C++语言新特性详解</title>
    <url>/2024/12/26/Qt-C-%E8%AF%AD%E8%A8%80%E6%96%B0%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><span id="more"></span>

<h1 id="Qt-C-语言新特性详解"><a href="#Qt-C-语言新特性详解" class="headerlink" title="Qt C++语言新特性详解"></a>Qt C++语言新特性详解</h1><p>随着C++标准的不断演进，C++11、C++14等新特性为开发者带来了更高效、更简洁和更强大的编程工具。结合Qt框架，这些新特性不仅提升了代码的可读性和维护性，还增强了应用程序的性能和功能。本篇文章将详细介绍Qt C++语言中的新特性，包括类型推导、序列for循环、lambda表达式、构造函数的新特性、现代容器、垃圾回收机制、正则表达式基础、智能指针以及关键字<code>nullptr</code>和<code>constexpr</code>。这些内容将帮助您充分利用C++的新特性，编写出更高效和更优雅的Qt应用程序。</p>
<hr>
<h2 id="1-类型推导：auto-与-decltype"><a href="#1-类型推导：auto-与-decltype" class="headerlink" title="1. 类型推导：auto 与 decltype"></a>1. 类型推导：<code>auto</code> 与 <code>decltype</code></h2><h3 id="1-1-auto-关键字"><a href="#1-1-auto-关键字" class="headerlink" title="1.1 auto 关键字"></a>1.1 <code>auto</code> 关键字</h3><p><code>auto</code>关键字允许编译器根据初始化表达式自动推导变量的类型，从而减少冗长的类型声明，提升代码的可读性和维护性。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用auto推导基本类型</span></span><br><span class="line">    <span class="keyword">auto</span> a = <span class="number">10</span>;          <span class="comment">// int</span></span><br><span class="line">    <span class="keyword">auto</span> b = <span class="number">3.14</span>;        <span class="comment">// double</span></span><br><span class="line">    <span class="keyword">auto</span> c = <span class="string">&quot;Hello&quot;</span>;     <span class="comment">// const char*</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;a: &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, b: &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;, c: &quot;</span> &lt;&lt; c &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用auto推导复杂类型</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>(); <span class="comment">// std::vector&lt;int&gt;::iterator</span></span><br><span class="line"></span><br><span class="line">    std::map&lt;std::string, <span class="type">double</span>&gt; priceMap = &#123;&#123;<span class="string">&quot;Apple&quot;</span>, <span class="number">1.99</span>&#125;, &#123;<span class="string">&quot;Banana&quot;</span>, <span class="number">0.99</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">auto</span> mapIt = priceMap.<span class="built_in">find</span>(<span class="string">&quot;Apple&quot;</span>); <span class="comment">// std::map&lt;std::string, double&gt;::iterator</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mapIt != priceMap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; mapIt-&gt;first &lt;&lt; <span class="string">&quot; costs &quot;</span> &lt;&lt; mapIt-&gt;second &lt;&lt; <span class="string">&quot; dollars.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a: 10, b: 3.14, c: Hello</span><br><span class="line">Apple costs 1.99 dollars.</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>auto</code>根据初始化表达式自动推导变量类型，减少了显式类型声明的需要。</li>
<li>在处理复杂类型如迭代器时，<code>auto</code>显著简化了代码，提高了可读性。</li>
</ul>
<h3 id="1-2-decltype-关键字"><a href="#1-2-decltype-关键字" class="headerlink" title="1.2 decltype 关键字"></a>1.2 <code>decltype</code> 关键字</h3><p><code>decltype</code>用于在编译时确定表达式的类型，常用于模板编程和复杂类型推导场景。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="type">double</span> y = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用decltype推导变量类型</span></span><br><span class="line">    <span class="keyword">decltype</span>(x) a = x;         <span class="comment">// int</span></span><br><span class="line">    <span class="keyword">decltype</span>(y) b = y;         <span class="comment">// double</span></span><br><span class="line">    <span class="keyword">decltype</span>(x + y) c = x + y; <span class="comment">// double</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;a: &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, b: &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;, c: &quot;</span> &lt;&lt; c &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 与模板结合使用</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">decltype</span>(vec)::iterator it = vec.<span class="built_in">begin</span>(); <span class="comment">// std::vector&lt;int&gt;::iterator</span></span><br><span class="line"></span><br><span class="line">    *it = <span class="number">10</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;First element after modification: &quot;</span> &lt;&lt; vec[<span class="number">0</span>] &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a: 5, b: 3.14, c: 8.14</span><br><span class="line">First element after modification: 10</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>decltype</code>根据给定的表达式推导出其类型。</li>
<li>在模板编程中，<code>decltype</code>可用于确定函数返回类型或变量类型，增强模板的灵活性和通用性。</li>
</ul>
<h3 id="1-3-auto-与-decltype-在Qt中的应用"><a href="#1-3-auto-与-decltype-在Qt中的应用" class="headerlink" title="1.3 auto 与 decltype 在Qt中的应用"></a>1.3 <code>auto</code> 与 <code>decltype</code> 在Qt中的应用</h3><p>在Qt开发中，尤其是在处理信号与槽、迭代容器、或模板类时，<code>auto</code>和<code>decltype</code>可以显著简化代码。例如，使用<code>auto</code>推导迭代器类型，或者使用<code>decltype</code>确定复杂对象的类型。</p>
<p><strong>示例：使用<code>auto</code>推导QList迭代器</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QList&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QString&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    QList&lt;QString&gt; fruits = &#123;<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Cherry&quot;</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用auto推导迭代器类型</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = fruits.<span class="built_in">begin</span>(); it != fruits.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; *it;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;Apple&quot;</span><br><span class="line">&quot;Banana&quot;</span><br><span class="line">&quot;Cherry&quot;</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>使用<code>auto</code>简化了迭代器类型的声明，使代码更加简洁和易读。</li>
<li>在Qt容器类中，<code>auto</code>广泛应用于迭代器和其他复杂类型的推导，提升了开发效率。</li>
</ul>
<hr>
<h2 id="2-基于范围的for循环（Range-based-for-Loop）"><a href="#2-基于范围的for循环（Range-based-for-Loop）" class="headerlink" title="2. 基于范围的for循环（Range-based for Loop）"></a>2. 基于范围的<code>for</code>循环（Range-based for Loop）</h2><p>C++11引入的基于范围的<code>for</code>循环简化了容器的遍历过程，提高了代码的可读性和效率。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QString&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QList&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Vector elements:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> num : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    QList&lt;QString&gt; fruits = &#123;<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Cherry&quot;</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;QList elements:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; fruit : fruits) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; fruit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Vector elements:</span><br><span class="line">1 2 3 4 5 </span><br><span class="line">QList elements:</span><br><span class="line">&quot;Apple&quot;</span><br><span class="line">&quot;Banana&quot;</span><br><span class="line">&quot;Cherry&quot;</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>基于范围的<code>for</code>循环通过直接遍历容器中的元素，避免了显式使用迭代器或下标，代码更简洁。</li>
<li>使用引用（如<code>const auto&amp;</code>）可以避免不必要的拷贝，提高性能，尤其是在处理大型对象或复杂类型时。</li>
</ul>
<h3 id="2-1-使用引用和常量引用"><a href="#2-1-使用引用和常量引用" class="headerlink" title="2.1 使用引用和常量引用"></a>2.1 使用引用和常量引用</h3><p>为了提高效率并避免不必要的拷贝，推荐在基于范围的<code>for</code>循环中使用引用或常量引用。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QString&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QList&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;std::string&gt; words = &#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;C++11&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用常量引用避免拷贝</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; word : words) &#123;</span><br><span class="line">        std::cout &lt;&lt; word &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    QList&lt;QString&gt; qwords = &#123;<span class="string">&quot;Qt&quot;</span>, <span class="string">&quot;is&quot;</span>, <span class="string">&quot;awesome&quot;</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用引用修改元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; qword : qwords) &#123;</span><br><span class="line">        qword = qword.<span class="built_in">toUpper</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Modified QList elements:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; qword : qwords) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; qword;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello world C++11 </span><br><span class="line">Modified QList elements:</span><br><span class="line">&quot;QT&quot;</span><br><span class="line">&quot;IS&quot;</span><br><span class="line">&quot;AWESOME&quot;</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>使用<code>const auto&amp;</code>避免对元素的拷贝，提高循环效率。</li>
<li>使用<code>auto&amp;</code>允许在循环中修改容器中的元素，如将字符串转换为大写。</li>
</ul>
<h3 id="2-2-与传统for循环的对比"><a href="#2-2-与传统for循环的对比" class="headerlink" title="2.2 与传统for循环的对比"></a>2.2 与传统<code>for</code>循环的对比</h3><p>基于范围的<code>for</code>循环相比传统的<code>for</code>循环具有以下优点：</p>
<ul>
<li><strong>简洁性</strong>：减少了循环变量的声明和初始化，代码更简洁。</li>
<li><strong>可读性</strong>：直接表达了遍历容器的意图，提升代码可读性。</li>
<li><strong>安全性</strong>：避免了越界访问和迭代器失效等问题，提升代码的安全性。</li>
</ul>
<p><strong>传统<code>for</code>循环示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Using traditional for loop:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; numbers.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; numbers[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Using traditional for loop:</span><br><span class="line">1 2 3 4 5 </span><br></pre></td></tr></table></figure>

<p><strong>基于范围的<code>for</code>循环示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Using range-based for loop:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> num : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Using range-based for loop:</span><br><span class="line">1 2 3 4 5 </span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>基于范围的<code>for</code>循环减少了循环变量的管理，代码更加简洁和易读。</li>
</ul>
<h3 id="2-3-在Qt中的应用"><a href="#2-3-在Qt中的应用" class="headerlink" title="2.3 在Qt中的应用"></a>2.3 在Qt中的应用</h3><p>在Qt开发中，基于范围的<code>for</code>循环广泛应用于遍历Qt容器类（如<code>QList</code>、<code>QVector</code>、<code>QMap</code>等），简化代码逻辑，提升开发效率。</p>
<p><strong>示例：遍历<code>QList</code>中的对象</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QList&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QString&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    QList&lt;QString&gt; fruits = &#123;<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Cherry&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Iterating over QList using range-based for loop:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; fruit : fruits) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; fruit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Iterating over QList using range-based for loop:</span><br><span class="line">&quot;Apple&quot;</span><br><span class="line">&quot;Banana&quot;</span><br><span class="line">&quot;Cherry&quot;</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>使用基于范围的<code>for</code>循环遍历<code>QList</code>中的<code>QString</code>对象，代码简洁且易于维护。</li>
</ul>
<hr>
<h2 id="3-Lambda表达式"><a href="#3-Lambda表达式" class="headerlink" title="3. Lambda表达式"></a>3. Lambda表达式</h2><h3 id="3-1-Lambda表达式的概念"><a href="#3-1-Lambda表达式的概念" class="headerlink" title="3.1 Lambda表达式的概念"></a>3.1 Lambda表达式的概念</h3><p>Lambda表达式是C++11引入的一种匿名函数对象，允许在代码中定义内联的、临时的函数。它们特别适用于需要短期使用的小函数，如回调函数、排序比较器等。</p>
<p><strong>语法结构：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[capture](parameters) -&gt; return_type &#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>捕获列表</strong>（<code>capture</code>）：指定lambda表达式可以访问的外部变量。</li>
<li><strong>参数列表</strong>（<code>parameters</code>）：定义lambda表达式的参数。</li>
<li><strong>返回类型</strong>（<code>return_type</code>）：可选，指定返回类型，编译器通常可以自动推导。</li>
<li><strong>函数体</strong>（<code>&#123;&#125;</code>）：定义lambda表达式的具体行为。</li>
</ul>
<h3 id="3-2-Lambda表达式的使用"><a href="#3-2-Lambda表达式的使用" class="headerlink" title="3.2 Lambda表达式的使用"></a>3.2 Lambda表达式的使用</h3><p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用lambda表达式打印每个元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Numbers: &quot;</span>;</span><br><span class="line">    std::for_each(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), [](<span class="type">int</span> num) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用lambda表达式计算所有元素的和</span></span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    std::for_each(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), [&amp;sum](<span class="type">int</span> num) &#123;</span><br><span class="line">        sum += num;</span><br><span class="line">    &#125;);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sum: &quot;</span> &lt;&lt; sum &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用lambda表达式进行排序（降序）</span></span><br><span class="line">    std::<span class="built_in">sort</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), [](<span class="type">int</span> a, <span class="type">int</span> b) -&gt; <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sorted (descending): &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> num : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Numbers: 1 2 3 4 5 </span><br><span class="line">Sum: 15</span><br><span class="line">Sorted (descending): 5 4 3 2 1 </span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>第一个<code>lambda</code>用于打印<code>vector</code>中的每个元素。</li>
<li>第二个<code>lambda</code>通过引用捕获外部变量<code>sum</code>，计算所有元素的总和。</li>
<li>第三个<code>lambda</code>作为排序比较器，实现了降序排序。</li>
</ul>
<h3 id="3-3-捕获列表的使用"><a href="#3-3-捕获列表的使用" class="headerlink" title="3.3 捕获列表的使用"></a>3.3 捕获列表的使用</h3><p>Lambda表达式的捕获列表决定了其可以访问哪些外部变量，以及如何访问它们。常见的捕获方式包括：</p>
<ul>
<li><strong>按值捕获</strong>（<code>[=]</code>）：复制外部变量的副本。</li>
<li><strong>按引用捕获</strong>（<code>[&amp;]</code>）：通过引用访问外部变量。</li>
<li><strong>混合捕获</strong>（<code>[=, &amp;var]</code> 或 <code>[&amp;, var]</code>）：指定部分变量按值或按引用捕获。</li>
<li><strong>不捕获任何变量</strong>（<code>[]</code>）：仅使用参数和全局变量。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> factor = <span class="number">2</span>;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按值捕获</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Numbers multiplied by factor (value capture): &quot;</span>;</span><br><span class="line">    std::for_each(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), [=](<span class="type">int</span>&amp; num) &#123;</span><br><span class="line">        num *= factor;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> num : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按引用捕获</span></span><br><span class="line">    factor = <span class="number">3</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Numbers multiplied by factor (reference capture): &quot;</span>;</span><br><span class="line">    std::for_each(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), [&amp;](<span class="type">int</span>&amp; num) &#123;</span><br><span class="line">        num *= factor;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> num : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Numbers multiplied by factor (value capture): 2 4 6 8 10 </span><br><span class="line">Numbers multiplied by factor (reference capture): 6 12 18 24 30 </span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>第一个<code>lambda</code>按值捕获<code>factor</code>，即使之后<code>factor</code>的值发生变化，<code>lambda</code>内的<code>factor</code>仍保持初始值<code>2</code>。</li>
<li>第二个<code>lambda</code>按引用捕获<code>factor</code>，<code>lambda</code>内的<code>factor</code>会反映外部变量的最新值<code>3</code>。</li>
</ul>
<h3 id="3-4-Lambda表达式在Qt中的应用"><a href="#3-4-Lambda表达式在Qt中的应用" class="headerlink" title="3.4 Lambda表达式在Qt中的应用"></a>3.4 Lambda表达式在Qt中的应用</h3><p>在Qt开发中，lambda表达式广泛应用于信号与槽机制、回调函数、事件处理等场景，使得代码更加简洁和灵活。</p>
<p><strong>示例：使用lambda表达式连接信号与槽</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTimer&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    QTimer timer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用lambda表达式作为槽函数</span></span><br><span class="line">    QObject::<span class="built_in">connect</span>(&amp;timer, &amp;QTimer::timeout, [&amp;]() &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Timer timeout occurred!&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    timer.<span class="built_in">start</span>(<span class="number">1000</span>); <span class="comment">// 每1000毫秒触发一次timeout信号</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出（每秒输出一次）：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Timer timeout occurred!</span><br><span class="line">Timer timeout occurred!</span><br><span class="line">Timer timeout occurred!</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>使用lambda表达式作为<code>QTimer</code>的槽函数，简化了传统的槽函数声明和实现过程。</li>
<li>使得信号与槽的连接更加灵活，尤其适用于简单的回调场景。</li>
</ul>
<p><strong>示例：使用lambda表达式处理按钮点击事件</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">QPushButton <span class="title">button</span><span class="params">(<span class="string">&quot;Click Me&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用lambda表达式处理按钮点击事件</span></span><br><span class="line">    QObject::<span class="built_in">connect</span>(&amp;button, &amp;QPushButton::clicked, [&amp;]() &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Button was clicked!&quot;</span>;</span><br><span class="line">        a.<span class="built_in">quit</span>(); <span class="comment">// 退出应用程序</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    button.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>当按钮被点击时，lambda表达式中的代码将被执行，输出点击信息并退出应用程序。</li>
<li>避免了为简单事件处理编写额外的槽函数，提高了代码的简洁性。</li>
</ul>
<hr>
<h2 id="4-构造函数的新特性：委托构造与继承构造"><a href="#4-构造函数的新特性：委托构造与继承构造" class="headerlink" title="4. 构造函数的新特性：委托构造与继承构造"></a>4. 构造函数的新特性：委托构造与继承构造</h2><h3 id="4-1-委托构造函数（Delegating-Constructors）"><a href="#4-1-委托构造函数（Delegating-Constructors）" class="headerlink" title="4.1 委托构造函数（Delegating Constructors）"></a>4.1 委托构造函数（Delegating Constructors）</h3><p>C++11引入了委托构造函数，允许一个构造函数调用同一类中的另一个构造函数，以减少重复代码，简化构造函数的实现。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 委托构造函数</span></span><br><span class="line">    <span class="built_in">Person</span>() : <span class="built_in">Person</span>(<span class="string">&quot;Unknown&quot;</span>, <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Default constructor called.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主构造函数</span></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; name, <span class="type">int</span> age) : <span class="built_in">name_</span>(name), <span class="built_in">age_</span>(age) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Parameterized constructor called.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; name_ &lt;&lt; <span class="string">&quot;, Age: &quot;</span> &lt;&lt; age_ &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name_;</span><br><span class="line">    <span class="type">int</span> age_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person p1; <span class="comment">// 调用默认构造函数，委托调用主构造函数</span></span><br><span class="line">    p1.<span class="built_in">display</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>)</span></span>; <span class="comment">// 直接调用主构造函数</span></span><br><span class="line">    p2.<span class="built_in">display</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Parameterized constructor called.</span><br><span class="line">Default constructor called.</span><br><span class="line">Name: Unknown, Age: 0</span><br><span class="line">Parameterized constructor called.</span><br><span class="line">Name: Alice, Age: 30</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>Person</code>类的默认构造函数通过委托调用带参数的主构造函数，初始化默认值。</li>
<li>这种方式避免了在多个构造函数中重复初始化成员变量的代码，提高了代码的可维护性。</li>
</ul>
<h3 id="4-2-继承构造函数（Inherited-Constructors）"><a href="#4-2-继承构造函数（Inherited-Constructors）" class="headerlink" title="4.2 继承构造函数（Inherited Constructors）"></a>4.2 继承构造函数（Inherited Constructors）</h3><p>C++11引入了继承构造函数，允许派生类继承基类的构造函数，简化派生类构造函数的定义。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Vehicle</span>(<span class="type">const</span> std::string&amp; brand, <span class="type">int</span> year) : <span class="built_in">brand_</span>(brand), <span class="built_in">year_</span>(year) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Vehicle constructor called.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Brand: &quot;</span> &lt;&lt; brand_ &lt;&lt; <span class="string">&quot;, Year: &quot;</span> &lt;&lt; year_ &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::string brand_;</span><br><span class="line">    <span class="type">int</span> year_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类继承Vehicle的构造函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> : <span class="keyword">public</span> Vehicle &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Vehicle::Vehicle; <span class="comment">// 继承基类的构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">honk</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; brand_ &lt;&lt; <span class="string">&quot; is honking.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Car <span class="title">car1</span><span class="params">(<span class="string">&quot;Toyota&quot;</span>, <span class="number">2020</span>)</span></span>; <span class="comment">// 直接使用基类的构造函数</span></span><br><span class="line">    car1.<span class="built_in">display</span>();</span><br><span class="line">    car1.<span class="built_in">honk</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Vehicle constructor called.</span><br><span class="line">Brand: Toyota, Year: 2020</span><br><span class="line">Toyota is honking.</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>Car</code>类通过<code>using Vehicle::Vehicle;</code>继承了<code>Vehicle</code>类的构造函数，无需在<code>Car</code>类中重新定义构造函数。</li>
<li>这简化了派生类的构造函数，实现了更高效的代码复用。</li>
</ul>
<h3 id="4-3-在Qt中的应用"><a href="#4-3-在Qt中的应用" class="headerlink" title="4.3 在Qt中的应用"></a>4.3 在Qt中的应用</h3><p>在Qt开发中，尤其是在自定义控件和窗口类时，委托构造和继承构造函数可以简化类的构造过程，减少重复代码。</p>
<p><strong>示例：自定义Qt控件使用继承构造函数</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QVBoxLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyWidget</span> : <span class="keyword">public</span> QWidget &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> QWidget::QWidget; <span class="comment">// 继承QWidget的构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setupUI</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        QVBoxLayout* layout = <span class="keyword">new</span> <span class="built_in">QVBoxLayout</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        QPushButton* button = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;Click Me&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">        layout-&gt;<span class="built_in">addWidget</span>(button);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用lambda表达式连接按钮点击信号</span></span><br><span class="line">        <span class="built_in">connect</span>(button, &amp;QPushButton::clicked, <span class="keyword">this</span>, [<span class="keyword">this</span>]() &#123;</span><br><span class="line">            <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Button in MyWidget clicked!&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    MyWidget widget;</span><br><span class="line">    widget.<span class="built_in">setupUI</span>();</span><br><span class="line">    widget.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>MyWidget</code>类通过<code>using QWidget::QWidget;</code>继承了<code>QWidget</code>的构造函数，简化了自定义控件的构造过程。</li>
<li>通过继承构造函数，可以直接使用基类提供的构造函数参数，无需在派生类中重新定义构造函数。</li>
</ul>
<hr>
<h2 id="5-容器：array、forward-list-与-tuple"><a href="#5-容器：array、forward-list-与-tuple" class="headerlink" title="5. 容器：array、forward_list 与 tuple"></a>5. 容器：<code>array</code>、<code>forward_list</code> 与 <code>tuple</code></h2><h3 id="5-1-std-array"><a href="#5-1-std-array" class="headerlink" title="5.1 std::array"></a>5.1 <code>std::array</code></h3><h4 id="5-1-1-std-array的概念"><a href="#5-1-1-std-array的概念" class="headerlink" title="5.1.1 std::array的概念"></a>5.1.1 <code>std::array</code>的概念</h4><p><code>std::array</code>是C++11引入的固定大小的数组容器，提供了与C风格数组相似的接口，但具有STL容器的特性，如支持范围for循环、迭代器等。</p>
<p><strong>特点：</strong></p>
<ul>
<li>固定大小，大小在编译时确定。</li>
<li>支持STL容器的所有操作，如迭代器、算法等。</li>
<li>不支持动态大小调整。</li>
</ul>
<h4 id="5-1-2-std-array的基本用法"><a href="#5-1-2-std-array的基本用法" class="headerlink" title="5.1.2 std::array的基本用法"></a>5.1.2 <code>std::array</code>的基本用法</h4><p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个包含5个整数的std::array</span></span><br><span class="line">    std::array&lt;<span class="type">int</span>, 5&gt; arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;First element: &quot;</span> &lt;&lt; arr[<span class="number">0</span>] &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Last element: &quot;</span> &lt;&lt; arr[arr.<span class="built_in">size</span>() - <span class="number">1</span>] &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历数组</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Elements: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> num : arr) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用STL算法</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Elements in reverse: &quot;</span>;</span><br><span class="line">    std::<span class="built_in">reverse</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> num : arr) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">First element: 1</span><br><span class="line">Last element: 5</span><br><span class="line">Elements: 1 2 3 4 5 </span><br><span class="line">Elements in reverse: 5 4 3 2 1 </span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>std::array</code>提供了与C风格数组相似的访问方式，同时支持STL算法，提高了代码的灵活性和可读性。</li>
<li>通过<code>std::reverse</code>等算法，可以方便地操作<code>std::array</code>中的元素。</li>
</ul>
<h3 id="5-2-std-forward-list"><a href="#5-2-std-forward-list" class="headerlink" title="5.2 std::forward_list"></a>5.2 <code>std::forward_list</code></h3><h4 id="5-2-1-std-forward-list的概念"><a href="#5-2-1-std-forward-list的概念" class="headerlink" title="5.2.1 std::forward_list的概念"></a>5.2.1 <code>std::forward_list</code>的概念</h4><p><code>std::forward_list</code>是C++11引入的单向链表容器，适用于需要频繁插入和删除操作但不需要随机访问的场景。相比<code>std::list</code>，<code>std::forward_list</code>具有更小的内存占用和更高的性能。</p>
<p><strong>特点：</strong></p>
<ul>
<li>单向链表，支持高效的前向遍历。</li>
<li>不支持双向迭代器或随机访问。</li>
<li>内存占用较低，适用于大量小型元素的存储。</li>
</ul>
<h4 id="5-2-2-std-forward-list的基本用法"><a href="#5-2-2-std-forward-list的基本用法" class="headerlink" title="5.2.2 std::forward_list的基本用法"></a>5.2.2 <code>std::forward_list</code>的基本用法</h4><p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个std::forward_list</span></span><br><span class="line">    std::forward_list&lt;<span class="type">int</span>&gt; flist = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历并打印元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Forward list elements: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = flist.<span class="built_in">begin</span>(); it != flist.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    flist.<span class="built_in">insert_after</span>(flist.<span class="built_in">begin</span>(), <span class="number">15</span>);</span><br><span class="line">    flist.<span class="built_in">emplace_after</span>(flist.<span class="built_in">begin</span>(), <span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After insertion: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> num : flist) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除元素</span></span><br><span class="line">    flist.<span class="built_in">remove</span>(<span class="number">30</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After removal: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> num : flist) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用STL算法</span></span><br><span class="line">    flist.<span class="built_in">sort</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After sorting: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> num : flist) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Forward list elements: 10 20 30 40 50 </span><br><span class="line">After insertion: 10 12 15 20 30 40 50 </span><br><span class="line">After removal: 10 12 15 20 40 50 </span><br><span class="line">After sorting: 10 12 15 20 40 50 </span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>insert_after</code>和<code>emplace_after</code>用于在指定位置后插入新元素，适用于单向链表的操作。</li>
<li><code>remove</code>用于删除所有匹配特定值的元素。</li>
<li><code>sort</code>算法对<code>std::forward_list</code>中的元素进行排序。</li>
</ul>
<h3 id="5-3-std-tuple"><a href="#5-3-std-tuple" class="headerlink" title="5.3 std::tuple"></a>5.3 <code>std::tuple</code></h3><h4 id="5-3-1-std-tuple的概念"><a href="#5-3-1-std-tuple的概念" class="headerlink" title="5.3.1 std::tuple的概念"></a>5.3.1 <code>std::tuple</code>的概念</h4><p><code>std::tuple</code>是C++11引入的一个固定大小的容器，用于存储不同类型的元素。与<code>std::pair</code>相比，<code>std::tuple</code>可以存储任意数量和类型的元素，适用于需要将多个不同类型的值组合在一起的场景。</p>
<p><strong>特点：</strong></p>
<ul>
<li>可以存储不同类型的元素。</li>
<li>支持访问单个元素，通过<code>std::get</code>或<code>std::tie</code>。</li>
<li>支持解构和结构化绑定（C++17引入）。</li>
</ul>
<h4 id="5-3-2-std-tuple的基本用法"><a href="#5-3-2-std-tuple的基本用法" class="headerlink" title="5.3.2 std::tuple的基本用法"></a>5.3.2 <code>std::tuple</code>的基本用法</h4><p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个std::tuple</span></span><br><span class="line">    <span class="function">std::tuple&lt;std::string, <span class="type">int</span>, <span class="type">double</span>&gt; <span class="title">person</span><span class="params">(<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>, <span class="number">5.5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(person) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Age: &quot;</span> &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(person) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Height: &quot;</span> &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(person) &lt;&lt; <span class="string">&quot; feet&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改元素</span></span><br><span class="line">    std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(person) = <span class="number">31</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Updated Age: &quot;</span> &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(person) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用std::tie进行解构</span></span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">double</span> height;</span><br><span class="line">    std::<span class="built_in">tie</span>(name, age, height) = person;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Destructured Tuple - Name: &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;, Age: &quot;</span> &lt;&lt; age &lt;&lt; <span class="string">&quot;, Height: &quot;</span> &lt;&lt; height &lt;&lt; <span class="string">&quot; feet&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Name: Alice</span><br><span class="line">Age: 30</span><br><span class="line">Height: 5.5 feet</span><br><span class="line">Updated Age: 31</span><br><span class="line">Destructured Tuple - Name: Alice, Age: 31, Height: 5.5 feet</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>使用<code>std::get</code>按索引访问<code>tuple</code>中的元素。</li>
<li>通过<code>std::tie</code>进行解构，将<code>tuple</code>中的元素赋值给独立的变量。</li>
<li><code>std::tuple</code>适用于函数返回多个值或存储异构数据的场景。</li>
</ul>
<h3 id="5-4-在Qt中的应用"><a href="#5-4-在Qt中的应用" class="headerlink" title="5.4 在Qt中的应用"></a>5.4 在Qt中的应用</h3><p>在Qt开发中，<code>std::tuple</code>可用于存储和传递多个相关但类型不同的数据，如函数返回多个值，或在模型-视图架构中管理复杂的数据结构。</p>
<p><strong>示例：函数返回多个值</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QString&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数返回一个tuple，包含QString和int</span></span><br><span class="line"><span class="function">std::tuple&lt;QString, <span class="type">int</span>&gt; <span class="title">getUserInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    QString name = <span class="string">&quot;Bob&quot;</span>;</span><br><span class="line">    <span class="type">int</span> age = <span class="number">28</span>;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_tuple</span>(name, age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> userInfo = <span class="built_in">getUserInfo</span>();</span><br><span class="line">    QString name = std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(userInfo);</span><br><span class="line">    <span class="type">int</span> age = std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(userInfo);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;User Name:&quot;</span> &lt;&lt; name;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;User Age:&quot;</span> &lt;&lt; age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">User Name: &quot;Bob&quot;</span><br><span class="line">User Age: 28</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>getUserInfo</code>函数返回一个包含姓名和年龄的<code>std::tuple</code>。</li>
<li>在<code>main</code>函数中，通过<code>std::get</code>访问并使用<code>tuple</code>中的各个元素。</li>
</ul>
<hr>
<h2 id="6-垃圾回收机制：RAII-与智能指针"><a href="#6-垃圾回收机制：RAII-与智能指针" class="headerlink" title="6. 垃圾回收机制：RAII 与智能指针"></a>6. 垃圾回收机制：RAII 与智能指针</h2><h3 id="6-1-RAII（资源获取即初始化）"><a href="#6-1-RAII（资源获取即初始化）" class="headerlink" title="6.1 RAII（资源获取即初始化）"></a>6.1 RAII（资源获取即初始化）</h3><p>RAII是一种C++编程惯用法，通过对象的生命周期管理资源，确保资源在对象创建时被获取，在对象销毁时被释放。这种方式有效防止了资源泄漏和悬空指针问题。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileHandler</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FileHandler</span>(<span class="type">const</span> std::string&amp; filename) &#123;</span><br><span class="line">        file_.<span class="built_in">open</span>(filename);</span><br><span class="line">        <span class="keyword">if</span>(file_.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;File opened: &quot;</span> &lt;&lt; filename &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;无法打开文件: &quot;</span> + filename);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">FileHandler</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span>(file_.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">            file_.<span class="built_in">close</span>();</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;File closed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">const</span> std::string&amp; data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(file_.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">            file_ &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::ofstream file_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="function">FileHandler <span class="title">fh</span><span class="params">(<span class="string">&quot;example.txt&quot;</span>)</span></span>;</span><br><span class="line">        fh.<span class="built_in">write</span>(<span class="string">&quot;Hello, RAII!&quot;</span>);</span><br><span class="line">        <span class="comment">// 当fh对象离开作用域时，文件自动关闭</span></span><br><span class="line">    &#125; <span class="built_in">catch</span>(<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;异常捕获: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">File opened: example.txt</span><br><span class="line">File closed.</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>FileHandler</code>类在构造函数中打开文件，并在析构函数中关闭文件。</li>
<li>无论函数如何退出，析构函数都会被调用，确保文件资源被正确释放。</li>
</ul>
<h3 id="6-2-智能指针"><a href="#6-2-智能指针" class="headerlink" title="6.2 智能指针"></a>6.2 智能指针</h3><p>C++11引入了智能指针，进一步简化了资源管理，避免了手动管理内存的复杂性和风险。主要的智能指针类型包括<code>std::unique_ptr</code>、<code>std::shared_ptr</code>和<code>std::weak_ptr</code>。</p>
<h4 id="6-2-1-std-unique-ptr"><a href="#6-2-1-std-unique-ptr" class="headerlink" title="6.2.1 std::unique_ptr"></a>6.2.1 <code>std::unique_ptr</code></h4><p><code>std::unique_ptr</code>表示对动态分配对象的独占所有权，不能复制，只能移动。适用于需要唯一所有权的场景。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Widget构造。&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    ~<span class="built_in">Widget</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Widget析构。&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">greet</span><span class="params">()</span> <span class="type">const</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Hello from Widget!&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个unique_ptr</span></span><br><span class="line">    std::unique_ptr&lt;Widget&gt; ptr1 = std::<span class="built_in">make_unique</span>&lt;Widget&gt;();</span><br><span class="line">    ptr1-&gt;<span class="built_in">greet</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不能复制unique_ptr，以下代码将导致编译错误</span></span><br><span class="line">    <span class="comment">// std::unique_ptr&lt;Widget&gt; ptr2 = ptr1;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以移动unique_ptr</span></span><br><span class="line">    std::unique_ptr&lt;Widget&gt; ptr2 = std::<span class="built_in">move</span>(ptr1);</span><br><span class="line">    <span class="keyword">if</span>(!ptr1) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ptr1不再拥有Widget。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ptr2-&gt;<span class="built_in">greet</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Widget构造。</span><br><span class="line">Hello from Widget!</span><br><span class="line">ptr1不再拥有Widget。</span><br><span class="line">Hello from Widget!</span><br><span class="line">Widget析构。</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>std::unique_ptr</code>确保同一时间只有一个指针拥有资源，防止资源被多次释放。</li>
<li>通过<code>std::move</code>转移所有权，实现资源的所有权管理。</li>
</ul>
<h4 id="6-2-2-std-shared-ptr"><a href="#6-2-2-std-shared-ptr" class="headerlink" title="6.2.2 std::shared_ptr"></a>6.2.2 <code>std::shared_ptr</code></h4><p><code>std::shared_ptr</code>允许多个指针共享同一个动态分配对象，通过引用计数管理对象生命周期。当最后一个<code>shared_ptr</code>被销毁时，资源被释放。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Gadget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Gadget</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Gadget构造。&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    ~<span class="built_in">Gadget</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Gadget析构。&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Gadget在工作。&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;Gadget&gt; sp1 = std::<span class="built_in">make_shared</span>&lt;Gadget&gt;();</span><br><span class="line">    &#123;</span><br><span class="line">        std::shared_ptr&lt;Gadget&gt; sp2 = sp1; <span class="comment">// 引用计数增加</span></span><br><span class="line">        sp2-&gt;<span class="built_in">show</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;引用计数: &quot;</span> &lt;&lt; sp1.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="comment">// sp2析构，引用计数减少</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;引用计数: &quot;</span> &lt;&lt; sp1.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Gadget构造。</span><br><span class="line">Gadget在工作。</span><br><span class="line">引用计数: 2</span><br><span class="line">引用计数: 1</span><br><span class="line">Gadget析构。</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>std::shared_ptr</code>通过内部引用计数管理资源，当引用计数为零时，自动释放资源。</li>
<li>多个<code>shared_ptr</code>可以安全地共享同一资源，适用于需要共享所有权的场景。</li>
</ul>
<h4 id="6-2-3-std-weak-ptr"><a href="#6-2-3-std-weak-ptr" class="headerlink" title="6.2.3 std::weak_ptr"></a>6.2.3 <code>std::weak_ptr</code></h4><p><code>std::weak_ptr</code>是<code>std::shared_ptr</code>的辅助工具，用于观察但不拥有资源，不增加引用计数。主要用于解决循环引用问题。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::shared_ptr&lt;Node&gt; next;</span><br><span class="line">    std::weak_ptr&lt;Node&gt; prev; <span class="comment">// 使用weak_ptr避免循环引用</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> value) : <span class="built_in">value_</span>(value) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Node &quot;</span> &lt;&lt; value_ &lt;&lt; <span class="string">&quot; 构造。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Node</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Node &quot;</span> &lt;&lt; value_ &lt;&lt; <span class="string">&quot; 析构。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;Node&gt; node1 = std::<span class="built_in">make_shared</span>&lt;Node&gt;(<span class="number">1</span>);</span><br><span class="line">    std::shared_ptr&lt;Node&gt; node2 = std::<span class="built_in">make_shared</span>&lt;Node&gt;(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    node1-&gt;next = node2;</span><br><span class="line">    node2-&gt;prev = node1; <span class="comment">// 使用weak_ptr，不增加引用计数</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;node1引用计数: &quot;</span> &lt;&lt; node1.<span class="built_in">use_count</span>() &lt;&lt; std::endl; <span class="comment">// 输出1</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;node2引用计数: &quot;</span> &lt;&lt; node2.<span class="built_in">use_count</span>() &lt;&lt; std::endl; <span class="comment">// 输出2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Node 1 构造。</span><br><span class="line">Node 2 构造。</span><br><span class="line">node1引用计数: 1</span><br><span class="line">node2引用计数: 2</span><br><span class="line">Node 2 析构。</span><br><span class="line">Node 1 析构。</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>Node</code>类中的<code>prev</code>指针使用<code>std::weak_ptr</code>，避免了<code>node1</code>和<code>node2</code>之间的循环引用。</li>
<li>通过<code>std::weak_ptr</code>，<code>node2</code>可以观察<code>node1</code>，但不会增加其引用计数，确保资源能够被正确释放。</li>
</ul>
<h3 id="6-3-RAII与智能指针的结合"><a href="#6-3-RAII与智能指针的结合" class="headerlink" title="6.3 RAII与智能指针的结合"></a>6.3 RAII与智能指针的结合</h3><p>通过将RAII与智能指针结合使用，可以实现更安全和高效的资源管理，避免内存泄漏和资源泄漏问题。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileWriter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FileWriter</span>(<span class="type">const</span> std::string&amp; filename) : <span class="built_in">file_</span>(std::<span class="built_in">make_unique</span>&lt;std::ofstream&gt;(filename)) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!file_-&gt;<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;无法打开文件: &quot;</span> + filename);</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;文件已打开: &quot;</span> &lt;&lt; filename &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">const</span> std::string&amp; data)</span> </span>&#123;</span><br><span class="line">        *file_ &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unique_ptr&lt;std::ofstream&gt; file_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="function">FileWriter <span class="title">fw</span><span class="params">(<span class="string">&quot;output.txt&quot;</span>)</span></span>;</span><br><span class="line">        fw.<span class="built_in">write</span>(<span class="string">&quot;Hello, RAII and Smart Pointers!&quot;</span>);</span><br><span class="line">        <span class="comment">// FileWriter对象离开作用域时，文件自动关闭</span></span><br><span class="line">    &#125; <span class="built_in">catch</span>(<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;异常捕获: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">文件已打开: output.txt</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>FileWriter</code>类使用<code>std::unique_ptr</code>管理<code>std::ofstream</code>对象，确保文件在<code>FileWriter</code>对象销毁时自动关闭。</li>
<li>结合RAII和智能指针，简化了资源管理，提升了代码的安全性和可维护性。</li>
</ul>
<h3 id="6-4-在Qt中的应用"><a href="#6-4-在Qt中的应用" class="headerlink" title="6.4 在Qt中的应用"></a>6.4 在Qt中的应用</h3><p>在Qt开发中，RAII和智能指针被广泛应用于管理资源，如内存、文件句柄、网络连接等。使用智能指针可以有效避免内存泄漏和资源泄漏问题，提升应用程序的稳定性和可靠性。</p>
<p><strong>示例：使用<code>std::shared_ptr</code>管理QObject</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QObject&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Worker</span> : <span class="keyword">public</span> QObject &#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Worker</span>() &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Worker构造。&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Worker</span>() &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Worker析构。&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Worker正在工作...&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用std::shared_ptr管理Worker对象</span></span><br><span class="line">    std::shared_ptr&lt;Worker&gt; workerPtr = std::<span class="built_in">make_shared</span>&lt;Worker&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将QObject的生命周期与shared_ptr绑定</span></span><br><span class="line">    QObject::<span class="built_in">connect</span>(&amp;a, &amp;QCoreApplication::aboutToQuit, [&amp;]() &#123;</span><br><span class="line">        workerPtr.<span class="built_in">reset</span>(); <span class="comment">// 释放Worker对象</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    workerPtr-&gt;<span class="built_in">doWork</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.moc&quot;</span></span></span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Worker构造。</span><br><span class="line">Worker正在工作...</span><br><span class="line">Worker析构。</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>使用<code>std::shared_ptr</code>管理<code>Worker</code>对象的生命周期，确保在应用程序退出前正确释放资源。</li>
<li>通过连接<code>QCoreApplication::aboutToQuit</code>信号，可以在应用程序退出前执行资源释放操作，提升资源管理的灵活性。</li>
</ul>
<hr>
<h2 id="7-正则表达式基础（Regular-Expressions）"><a href="#7-正则表达式基础（Regular-Expressions）" class="headerlink" title="7. 正则表达式基础（Regular Expressions）"></a>7. 正则表达式基础（Regular Expressions）</h2><h3 id="7-1-正则表达式的概念"><a href="#7-1-正则表达式的概念" class="headerlink" title="7.1 正则表达式的概念"></a>7.1 正则表达式的概念</h3><p>正则表达式（Regular Expressions）是一种用于匹配字符串中字符组合的模式。它广泛应用于文本搜索、替换、验证等任务。在C++11中，标准库引入了<code>&lt;regex&gt;</code>头文件，提供了对正则表达式的全面支持。</p>
<h3 id="7-2-使用C-11中的正则表达式库"><a href="#7-2-使用C-11中的正则表达式库" class="headerlink" title="7.2 使用C++11中的正则表达式库"></a>7.2 使用C++11中的正则表达式库</h3><h4 id="7-2-1-基本用法"><a href="#7-2-1-基本用法" class="headerlink" title="7.2.1 基本用法"></a>7.2.1 基本用法</h4><p><strong>示例：匹配邮箱地址</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string email = <span class="string">&quot;user@example.com&quot;</span>;</span><br><span class="line">    <span class="comment">// 定义邮箱的正则表达式模式</span></span><br><span class="line">    <span class="function">std::regex <span class="title">email_pattern</span><span class="params">(<span class="string">R&quot;((\w+)(\.\w+)*@(\w+\.)+(\w+))&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">regex_match</span>(email, email_pattern)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;有效的邮箱地址。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;无效的邮箱地址。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">有效的邮箱地址。</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>std::regex</code>用于定义正则表达式模式。</li>
<li><code>std::regex_match</code>用于检查整个字符串是否匹配给定的模式。</li>
<li><code>R&quot;(...)&quot;</code>是原始字符串字面量，避免了转义字符的复杂性。</li>
</ul>
<h4 id="7-2-2-搜索和替换"><a href="#7-2-2-搜索和替换" class="headerlink" title="7.2.2 搜索和替换"></a>7.2.2 搜索和替换</h4><p><strong>示例：在文本中查找并替换特定模式</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string text = <span class="string">&quot;C++11 introduced many features like auto, lambda, and smart pointers.&quot;</span>;</span><br><span class="line">    <span class="comment">// 定义要查找的关键词</span></span><br><span class="line">    <span class="function">std::regex <span class="title">feature_pattern</span><span class="params">(<span class="string">R&quot;(\b(auto|lambda|smart pointers)\b)&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 替换为强调格式</span></span><br><span class="line">    std::string replaced_text = std::<span class="built_in">regex_replace</span>(text, feature_pattern, <span class="string">&quot;&lt;strong&gt;$1&lt;/strong&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; replaced_text &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C++11 introduced many features like &lt;strong&gt;auto&lt;/strong&gt;, &lt;strong&gt;lambda&lt;/strong&gt;, and &lt;strong&gt;smart pointers&lt;/strong&gt;.</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>std::regex_replace</code>用于在字符串中查找匹配的部分并进行替换。</li>
<li><code>$1</code>表示第一个捕获组，即<code>auto</code>、<code>lambda</code>或<code>smart pointers</code>。</li>
</ul>
<h4 id="7-2-3-分割字符串"><a href="#7-2-3-分割字符串" class="headerlink" title="7.2.3 分割字符串"></a>7.2.3 分割字符串</h4><p><strong>示例：使用正则表达式分割字符串</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string data = <span class="string">&quot;apple, banana; cherry|date&quot;</span>;</span><br><span class="line">    <span class="comment">// 定义分隔符的正则表达式模式</span></span><br><span class="line">    <span class="function">std::regex <span class="title">delimiter</span><span class="params">(<span class="string">R&quot;([,;|])&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">std::sregex_token_iterator <span class="title">it</span><span class="params">(data.begin(), data.end(), delimiter, <span class="number">-1</span>)</span></span>;</span><br><span class="line">    std::sregex_token_iterator end;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::string&gt; fruits;</span><br><span class="line">    <span class="keyword">for</span>(; it != end; ++it) &#123;</span><br><span class="line">        fruits.<span class="built_in">push_back</span>(it-&gt;<span class="built_in">str</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Fruits:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; fruit : fruits) &#123;</span><br><span class="line">        std::cout &lt;&lt; fruit &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Fruits:</span><br><span class="line">apple</span><br><span class="line"> banana</span><br><span class="line"> cherry</span><br><span class="line">date</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>std::sregex_token_iterator</code>用于根据正则表达式分割字符串。</li>
<li>参数<code>-1</code>表示获取分割后的子字符串。</li>
</ul>
<h3 id="7-3-在Qt中的应用"><a href="#7-3-在Qt中的应用" class="headerlink" title="7.3 在Qt中的应用"></a>7.3 在Qt中的应用</h3><p>在Qt开发中，正则表达式常用于输入验证、数据解析和文本处理。Qt提供了<code>QRegExp</code>（Qt 5）和<code>QRegularExpression</code>（Qt 5.2及更高版本）类来支持正则表达式操作。</p>
<p><strong>示例：使用<code>QRegularExpression</code>验证邮箱地址</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QRegularExpression&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QString&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    QString email = <span class="string">&quot;user@example.com&quot;</span>;</span><br><span class="line">    <span class="comment">// 定义邮箱的正则表达式模式</span></span><br><span class="line">    <span class="function">QRegularExpression <span class="title">email_pattern</span><span class="params">(<span class="string">R&quot;((\w+)(\.\w+)*@(\w+\.)+(\w+))&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    QRegularExpressionMatch match = email_pattern.<span class="built_in">match</span>(email);</span><br><span class="line">    <span class="keyword">if</span>(match.<span class="built_in">hasMatch</span>()) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;有效的邮箱地址。&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;无效的邮箱地址。&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">有效的邮箱地址。</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>QRegularExpression</code>用于定义正则表达式模式。</li>
<li><code>match</code>方法用于检查字符串是否匹配模式。</li>
<li><code>hasMatch()</code>方法判断是否成功匹配。</li>
</ul>
<hr>
<h2 id="8-智能指针：shared-ptr、unique-ptr-与-weak-ptr"><a href="#8-智能指针：shared-ptr、unique-ptr-与-weak-ptr" class="headerlink" title="8. 智能指针：shared_ptr、unique_ptr 与 weak_ptr"></a>8. 智能指针：<code>shared_ptr</code>、<code>unique_ptr</code> 与 <code>weak_ptr</code></h2><h3 id="8-1-智能指针的概念"><a href="#8-1-智能指针的概念" class="headerlink" title="8.1 智能指针的概念"></a>8.1 智能指针的概念</h3><p>智能指针是C++11引入的一种RAII（资源获取即初始化）工具，用于自动管理动态分配的内存，防止内存泄漏和悬挂指针问题。C++标准库提供了三种智能指针类型：<code>std::unique_ptr</code>、<code>std::shared_ptr</code>和<code>std::weak_ptr</code>。</p>
<h3 id="8-2-std-unique-ptr"><a href="#8-2-std-unique-ptr" class="headerlink" title="8.2 std::unique_ptr"></a>8.2 <code>std::unique_ptr</code></h3><h4 id="8-2-1-std-unique-ptr的特点"><a href="#8-2-1-std-unique-ptr的特点" class="headerlink" title="8.2.1 std::unique_ptr的特点"></a>8.2.1 <code>std::unique_ptr</code>的特点</h4><ul>
<li><strong>独占所有权</strong>：每个<code>unique_ptr</code>只能拥有一个指针。</li>
<li><strong>不可复制</strong>：<code>unique_ptr</code>不可被复制，但可以被移动。</li>
<li><strong>轻量级</strong>：没有额外的引用计数开销。</li>
</ul>
<h4 id="8-2-2-使用示例"><a href="#8-2-2-使用示例" class="headerlink" title="8.2.2 使用示例"></a>8.2.2 使用示例</h4><p><strong>示例：管理动态分配的对象</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Widget构造。&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    ~<span class="built_in">Widget</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Widget析构。&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">greet</span><span class="params">()</span> <span class="type">const</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Hello from Widget!&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个unique_ptr</span></span><br><span class="line">    std::unique_ptr&lt;Widget&gt; ptr1 = std::<span class="built_in">make_unique</span>&lt;Widget&gt;();</span><br><span class="line">    ptr1-&gt;<span class="built_in">greet</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不能复制unique_ptr，以下代码将导致编译错误</span></span><br><span class="line">    <span class="comment">// std::unique_ptr&lt;Widget&gt; ptr2 = ptr1;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以移动unique_ptr</span></span><br><span class="line">    std::unique_ptr&lt;Widget&gt; ptr2 = std::<span class="built_in">move</span>(ptr1);</span><br><span class="line">    <span class="keyword">if</span>(!ptr1) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ptr1不再拥有Widget。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ptr2-&gt;<span class="built_in">greet</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Widget构造。</span><br><span class="line">Hello from Widget!</span><br><span class="line">ptr1不再拥有Widget。</span><br><span class="line">Hello from Widget!</span><br><span class="line">Widget析构。</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>std::unique_ptr</code>确保同一时间只有一个指针拥有资源，防止资源被多次释放。</li>
<li>通过<code>std::move</code>转移所有权，实现资源的所有权管理。</li>
</ul>
<h3 id="8-3-std-shared-ptr"><a href="#8-3-std-shared-ptr" class="headerlink" title="8.3 std::shared_ptr"></a>8.3 <code>std::shared_ptr</code></h3><h4 id="8-3-1-std-shared-ptr的特点"><a href="#8-3-1-std-shared-ptr的特点" class="headerlink" title="8.3.1 std::shared_ptr的特点"></a>8.3.1 <code>std::shared_ptr</code>的特点</h4><ul>
<li><strong>共享所有权</strong>：多个<code>shared_ptr</code>可以共享同一个资源。</li>
<li><strong>引用计数</strong>：内部维护一个引用计数，记录有多少个<code>shared_ptr</code>指向同一资源。</li>
<li><strong>自动释放</strong>：当最后一个<code>shared_ptr</code>被销毁时，资源自动释放。</li>
</ul>
<h4 id="8-3-2-使用示例"><a href="#8-3-2-使用示例" class="headerlink" title="8.3.2 使用示例"></a>8.3.2 使用示例</h4><p><strong>示例：共享资源的多个所有者</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Gadget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Gadget</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Gadget构造。&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    ~<span class="built_in">Gadget</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Gadget析构。&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Gadget在工作。&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;Gadget&gt; sp1 = std::<span class="built_in">make_shared</span>&lt;Gadget&gt;();</span><br><span class="line">    &#123;</span><br><span class="line">        std::shared_ptr&lt;Gadget&gt; sp2 = sp1; <span class="comment">// 引用计数增加</span></span><br><span class="line">        sp2-&gt;<span class="built_in">show</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;引用计数: &quot;</span> &lt;&lt; sp1.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="comment">// sp2析构，引用计数减少</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;引用计数: &quot;</span> &lt;&lt; sp1.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Gadget构造。</span><br><span class="line">Gadget在工作。</span><br><span class="line">引用计数: 2</span><br><span class="line">引用计数: 1</span><br><span class="line">Gadget析构。</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>std::shared_ptr</code>通过内部引用计数管理资源，当引用计数为零时，自动释放资源。</li>
<li>多个<code>shared_ptr</code>可以安全地共享同一资源，适用于需要共享所有权的场景。</li>
</ul>
<h3 id="8-4-std-weak-ptr"><a href="#8-4-std-weak-ptr" class="headerlink" title="8.4 std::weak_ptr"></a>8.4 <code>std::weak_ptr</code></h3><h4 id="8-4-1-std-weak-ptr的特点"><a href="#8-4-1-std-weak-ptr的特点" class="headerlink" title="8.4.1 std::weak_ptr的特点"></a>8.4.1 <code>std::weak_ptr</code>的特点</h4><ul>
<li><strong>观察者指针</strong>：<code>weak_ptr</code>不拥有资源，不会增加引用计数。</li>
<li><strong>避免循环引用</strong>：常用于打破<code>shared_ptr</code>之间的循环引用，防止内存泄漏。</li>
<li><strong>可以从<code>shared_ptr</code>获取资源</strong>：通过<code>lock()</code>方法尝试获取<code>shared_ptr</code>。</li>
</ul>
<h4 id="8-4-2-使用示例"><a href="#8-4-2-使用示例" class="headerlink" title="8.4.2 使用示例"></a>8.4.2 使用示例</h4><p><strong>示例：打破循环引用</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::shared_ptr&lt;Node&gt; next;</span><br><span class="line">    std::weak_ptr&lt;Node&gt; prev; <span class="comment">// 使用weak_ptr避免循环引用</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> value) : <span class="built_in">value_</span>(value) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Node &quot;</span> &lt;&lt; value_ &lt;&lt; <span class="string">&quot; 构造。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Node</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Node &quot;</span> &lt;&lt; value_ &lt;&lt; <span class="string">&quot; 析构。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;Node&gt; node1 = std::<span class="built_in">make_shared</span>&lt;Node&gt;(<span class="number">1</span>);</span><br><span class="line">    std::shared_ptr&lt;Node&gt; node2 = std::<span class="built_in">make_shared</span>&lt;Node&gt;(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    node1-&gt;next = node2;</span><br><span class="line">    node2-&gt;prev = node1; <span class="comment">// 使用weak_ptr，不增加引用计数</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;node1引用计数: &quot;</span> &lt;&lt; node1.<span class="built_in">use_count</span>() &lt;&lt; std::endl; <span class="comment">// 输出1</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;node2引用计数: &quot;</span> &lt;&lt; node2.<span class="built_in">use_count</span>() &lt;&lt; std::endl; <span class="comment">// 输出2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Node 1 构造。</span><br><span class="line">Node 2 构造。</span><br><span class="line">node1引用计数: 1</span><br><span class="line">node2引用计数: 2</span><br><span class="line">Node 2 析构。</span><br><span class="line">Node 1 析构。</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>Node</code>类中的<code>prev</code>指针使用<code>std::weak_ptr</code>，避免了<code>node1</code>和<code>node2</code>之间的循环引用。</li>
<li>通过<code>std::weak_ptr</code>，<code>node2</code>可以观察<code>node1</code>，但不会增加其引用计数，确保资源能够被正确释放。</li>
</ul>
<h3 id="8-5-在Qt中的应用"><a href="#8-5-在Qt中的应用" class="headerlink" title="8.5 在Qt中的应用"></a>8.5 在Qt中的应用</h3><p>在Qt开发中，智能指针被广泛应用于管理QObject派生类的生命周期、处理资源管理和避免内存泄漏。结合Qt的父子对象机制，智能指针能够进一步提升资源管理的安全性和效率。</p>
<p><strong>示例：使用<code>std::shared_ptr</code>管理QObject</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QObject&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Worker</span> : <span class="keyword">public</span> QObject &#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Worker</span>() &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Worker构造。&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Worker</span>() &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Worker析构。&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Worker正在工作...&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用std::shared_ptr管理Worker对象</span></span><br><span class="line">    std::shared_ptr&lt;Worker&gt; workerPtr = std::<span class="built_in">make_shared</span>&lt;Worker&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将QObject的生命周期与shared_ptr绑定</span></span><br><span class="line">    QObject::<span class="built_in">connect</span>(&amp;a, &amp;QCoreApplication::aboutToQuit, [&amp;]() &#123;</span><br><span class="line">        workerPtr.<span class="built_in">reset</span>(); <span class="comment">// 释放Worker对象</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    workerPtr-&gt;<span class="built_in">doWork</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.moc&quot;</span></span></span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Worker构造。</span><br><span class="line">Worker正在工作...</span><br><span class="line">Worker析构。</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>使用<code>std::shared_ptr</code>管理<code>Worker</code>对象的生命周期，确保在应用程序退出前正确释放资源。</li>
<li>通过连接<code>QCoreApplication::aboutToQuit</code>信号，可以在应用程序退出前执行资源释放操作，提升资源管理的灵活性。</li>
</ul>
<hr>
<h2 id="9-关键字：nullptr-与-constexpr"><a href="#9-关键字：nullptr-与-constexpr" class="headerlink" title="9. 关键字：nullptr 与 constexpr"></a>9. 关键字：<code>nullptr</code> 与 <code>constexpr</code></h2><h3 id="9-1-nullptr"><a href="#9-1-nullptr" class="headerlink" title="9.1 nullptr"></a>9.1 <code>nullptr</code></h3><h4 id="9-1-1-nullptr的概念"><a href="#9-1-1-nullptr的概念" class="headerlink" title="9.1.1 nullptr的概念"></a>9.1.1 <code>nullptr</code>的概念</h4><p><code>nullptr</code>是C++11引入的一个关键字，用于表示空指针。它替代了传统的<code>NULL</code>宏，提供了更强的类型安全性。</p>
<h4 id="9-1-2-使用示例"><a href="#9-1-2-使用示例" class="headerlink" title="9.1.2 使用示例"></a>9.1.2 使用示例</h4><p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>* ptr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ptr == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;指针为空。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;指针指向的值：&quot;</span> &lt;&lt; *ptr &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span>* p1 = &amp;x;</span><br><span class="line">    <span class="type">int</span>* p2 = <span class="literal">nullptr</span>; <span class="comment">// 使用nullptr</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">func</span>(p1);</span><br><span class="line">    <span class="built_in">func</span>(p2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">指针指向的值：10</span><br><span class="line">指针为空。</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>nullptr</code>具有类型<code>std::nullptr_t</code>，能够被隐式转换为任何指针类型，避免了与整数的歧义。</li>
<li>提升了代码的类型安全性，减少了错误。</li>
</ul>
<h3 id="9-2-constexpr"><a href="#9-2-constexpr" class="headerlink" title="9.2 constexpr"></a>9.2 <code>constexpr</code></h3><h4 id="9-2-1-constexpr的概念"><a href="#9-2-1-constexpr的概念" class="headerlink" title="9.2.1 constexpr的概念"></a>9.2.1 <code>constexpr</code>的概念</h4><p><code>constexpr</code>是C++11引入的关键字，用于指定表达式或函数在编译时进行求值。它允许定义编译期常量，提升代码的性能和安全性。</p>
<h4 id="9-2-2-使用示例"><a href="#9-2-2-使用示例" class="headerlink" title="9.2.2 使用示例"></a>9.2.2 使用示例</h4><p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译期常量</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">square</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> val = <span class="built_in">square</span>(<span class="number">5</span>); <span class="comment">// 在编译时计算</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Square of 5 is &quot;</span> &lt;&lt; val &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// constexpr int val2 = square(a); // 错误，a不是编译期常量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Square of 5 is 25</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>constexpr</code>函数<code>square</code>在编译时计算<code>5 * 5</code>，结果赋值给<code>val</code>。</li>
<li><code>constexpr</code>变量必须在编译时能够确定其值，不能依赖运行时变量。</li>
</ul>
<h3 id="9-3-在Qt中的应用"><a href="#9-3-在Qt中的应用" class="headerlink" title="9.3 在Qt中的应用"></a>9.3 在Qt中的应用</h3><p>在Qt开发中，<code>nullptr</code>和<code>constexpr</code>被广泛应用于提高代码的类型安全性和性能。例如，使用<code>constexpr</code>定义编译期常量，优化界面布局和资源管理。</p>
<p><strong>示例：使用<code>constexpr</code>定义窗口尺寸</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> windowWidth = <span class="number">400</span>;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> windowHeight = <span class="number">300</span>;</span><br><span class="line"></span><br><span class="line">    QWidget window;</span><br><span class="line">    window.<span class="built_in">setFixedSize</span>(windowWidth, windowHeight);</span><br><span class="line">    window.<span class="built_in">setWindowTitle</span>(<span class="string">&quot;Qt 应用&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function">QPushButton <span class="title">button</span><span class="params">(<span class="string">&quot;点击我&quot;</span>, &amp;window)</span></span>;</span><br><span class="line">    button.<span class="built_in">setGeometry</span>(<span class="number">150</span>, <span class="number">130</span>, <span class="number">100</span>, <span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">    window.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>使用<code>constexpr</code>定义窗口的宽度和高度，在编译时确定这些值，提升了代码的性能和可读性。</li>
<li>通过<code>setFixedSize</code>设置窗口的固定尺寸，确保界面布局的一致性。</li>
</ul>
<hr>
<h2 id="10-共享内存与互斥量（Mutex）"><a href="#10-共享内存与互斥量（Mutex）" class="headerlink" title="10. 共享内存与互斥量（Mutex）"></a>10. 共享内存与互斥量（Mutex）</h2><h3 id="10-1-共享内存的概念"><a href="#10-1-共享内存的概念" class="headerlink" title="10.1 共享内存的概念"></a>10.1 共享内存的概念</h3><p>在多线程编程中，多个线程可能需要访问和修改共享数据。共享内存允许线程之间高效地交换信息，但也带来了数据竞争和同步的问题。</p>
<h3 id="10-2-互斥量（Mutex）"><a href="#10-2-互斥量（Mutex）" class="headerlink" title="10.2 互斥量（Mutex）"></a>10.2 互斥量（Mutex）</h3><h4 id="10-2-1-std-mutex的概念"><a href="#10-2-1-std-mutex的概念" class="headerlink" title="10.2.1 std::mutex的概念"></a>10.2.1 <code>std::mutex</code>的概念</h4><p><code>std::mutex</code>是C++11引入的一个同步原语，用于保护共享资源，防止多个线程同时访问导致的数据竞争。</p>
<h4 id="10-2-2-使用示例"><a href="#10-2-2-使用示例" class="headerlink" title="10.2.2 使用示例"></a>10.2.2 使用示例</h4><p><strong>示例：保护共享计数器</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">(<span class="type">int</span> num_iterations)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_iterations; ++i) &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>; <span class="comment">// 自动加锁和解锁</span></span><br><span class="line">        ++counter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> num_threads = <span class="number">5</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> num_iterations = <span class="number">1000</span>;</span><br><span class="line">    std::thread threads[num_threads];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动多个线程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_threads; ++i) &#123;</span><br><span class="line">        threads[i] = std::<span class="built_in">thread</span>(increment, num_iterations);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待所有线程完成</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_threads; ++i) &#123;</span><br><span class="line">        threads[i].<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;最终计数器值: &quot;</span> &lt;&lt; counter &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">最终计数器值: 5000</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>使用<code>std::lock_guard&lt;std::mutex&gt;</code>在作用域内自动管理互斥锁的加锁与解锁，确保线程安全。</li>
<li>保护共享变量<code>counter</code>，防止多个线程同时修改导致的数据竞争。</li>
</ul>
<h3 id="10-3-在Qt中的应用"><a href="#10-3-在Qt中的应用" class="headerlink" title="10.3 在Qt中的应用"></a>10.3 在Qt中的应用</h3><p>在Qt开发中，多线程编程常见于需要后台处理任务、提高应用响应性的场景。使用互斥量和其他同步原语，可以确保线程安全地访问和修改共享资源。</p>
<p><strong>示例：使用<code>std::mutex</code>保护共享数据</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; data;</span><br><span class="line">std::mutex data_mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addData</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(data_mutex)</span></span>;</span><br><span class="line">    data.<span class="built_in">push_back</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> num_threads = <span class="number">4</span>;</span><br><span class="line">    std::thread threads[num_threads];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动多个线程，向共享数据中添加元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_threads; ++i) &#123;</span><br><span class="line">        threads[i] = std::<span class="built_in">thread</span>([i]() &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; ++j) &#123;</span><br><span class="line">                <span class="built_in">addData</span>(i * <span class="number">10</span> + j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待所有线程完成</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_threads; ++i) &#123;</span><br><span class="line">        threads[i].<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印共享数据</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(data_mutex)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;共享数据内容:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> val : data) &#123;</span><br><span class="line">        std::cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">共享数据内容:</span><br><span class="line">0 1 2 3 4 10 11 12 13 14 20 21 22 23 24 30 31 32 33 34 </span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>使用<code>std::mutex</code>保护共享的<code>data</code>向量，确保多个线程安全地添加元素。</li>
<li>通过<code>std::lock_guard</code>自动管理互斥锁，避免手动加锁和解锁的复杂性。</li>
</ul>
<hr>
<h2 id="11-C-11-STL哈希映射容器：std-unordered-map"><a href="#11-C-11-STL哈希映射容器：std-unordered-map" class="headerlink" title="11. C++11 STL哈希映射容器：std::unordered_map"></a>11. C++11 STL哈希映射容器：<code>std::unordered_map</code></h2><h3 id="11-1-std-unordered-map的概念"><a href="#11-1-std-unordered-map的概念" class="headerlink" title="11.1 std::unordered_map的概念"></a>11.1 <code>std::unordered_map</code>的概念</h3><p><code>std::unordered_map</code>是C++11引入的关联容器，基于哈希表实现，提供平均常数时间复杂度的查找、插入和删除操作。与<code>std::map</code>不同，<code>unordered_map</code>中的元素无序存储，但查找效率更高。</p>
<h3 id="11-2-使用示例"><a href="#11-2-使用示例" class="headerlink" title="11.2 使用示例"></a>11.2 使用示例</h3><p><strong>示例：存储和查找学生成绩</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个unordered_map，键为学生姓名，值为成绩</span></span><br><span class="line">    std::unordered_map&lt;std::string, <span class="type">int</span>&gt; student_scores = &#123;</span><br><span class="line">        &#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">90</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">85</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Charlie&quot;</span>, <span class="number">92</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Diana&quot;</span>, <span class="number">88</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找学生成绩</span></span><br><span class="line">    std::string name = <span class="string">&quot;Charlie&quot;</span>;</span><br><span class="line">    <span class="keyword">auto</span> it = student_scores.<span class="built_in">find</span>(name);</span><br><span class="line">    <span class="keyword">if</span>(it != student_scores.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; name &lt;&lt; <span class="string">&quot;的成绩是 &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;未找到学生 &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot; 的成绩。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入新的学生成绩</span></span><br><span class="line">    student_scores[<span class="string">&quot;Eve&quot;</span>] = <span class="number">95</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历unordered_map</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;所有学生的成绩:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : student_scores) &#123;</span><br><span class="line">        std::cout &lt;&lt; pair.first &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; pair.second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Charlie的成绩是 92</span><br><span class="line">所有学生的成绩:</span><br><span class="line">Diana : 88</span><br><span class="line">Eve : 95</span><br><span class="line">Alice : 90</span><br><span class="line">Bob : 85</span><br><span class="line">Charlie : 92</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>std::unordered_map</code>提供了高效的键值对存储和查找机制。</li>
<li>元素的存储顺序与插入顺序无关，但查找、插入和删除操作具有较高的效率。</li>
</ul>
<h3 id="11-3-自定义哈希函数"><a href="#11-3-自定义哈希函数" class="headerlink" title="11.3 自定义哈希函数"></a>11.3 自定义哈希函数</h3><p>对于自定义类型作为键的<code>unordered_map</code>，需要提供哈希函数和相等比较函数。</p>
<p><strong>示例：使用自定义类型作为键</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Point&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x == other.x &amp;&amp; y == other.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义哈希函数</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PointHash</span> &#123;</span><br><span class="line">    <span class="function">std::<span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Point&amp; p)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">hash</span>&lt;<span class="type">int</span>&gt;()(p.x) ^ (std::<span class="built_in">hash</span>&lt;<span class="type">int</span>&gt;()(p.y) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义unordered_map，键为Point，值为字符串</span></span><br><span class="line">    std::unordered_map&lt;Point, std::string, PointHash&gt; point_map = &#123;</span><br><span class="line">        &#123; &#123;<span class="number">0</span>, <span class="number">0</span>&#125;, <span class="string">&quot;Origin&quot;</span> &#125;,</span><br><span class="line">        &#123; &#123;<span class="number">1</span>, <span class="number">2</span>&#125;, <span class="string">&quot;Point A&quot;</span> &#125;,</span><br><span class="line">        &#123; &#123;<span class="number">3</span>, <span class="number">4</span>&#125;, <span class="string">&quot;Point B&quot;</span> &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找Point</span></span><br><span class="line">    Point p = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> it = point_map.<span class="built_in">find</span>(p);</span><br><span class="line">    <span class="keyword">if</span>(it != point_map.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Point (&quot;</span> &lt;&lt; p.x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; p.y &lt;&lt; <span class="string">&quot;) 是 &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;未找到Point (&quot;</span> &lt;&lt; p.x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; p.y &lt;&lt; <span class="string">&quot;)。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Point (1, 2) 是 Point A</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>定义了一个自定义类型<code>Point</code>，并重载了<code>operator==</code>以支持相等比较。</li>
<li>创建了一个自定义哈希函数<code>PointHash</code>，用于计算<code>Point</code>对象的哈希值。</li>
<li>在<code>std::unordered_map</code>中使用<code>Point</code>作为键，需要指定哈希函数类型。</li>
</ul>
<h3 id="11-4-在Qt中的应用"><a href="#11-4-在Qt中的应用" class="headerlink" title="11.4 在Qt中的应用"></a>11.4 在Qt中的应用</h3><p>在Qt开发中，<code>std::unordered_map</code>常用于高效地管理和查找数据，如缓存机制、快速索引等。结合Qt的容器类和信号槽机制，可以实现复杂的数据管理逻辑。</p>
<p><strong>示例：使用<code>std::unordered_map</code>管理QWidget对象</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QString&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">WidgetKey</span> &#123;</span><br><span class="line">    QString name;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> WidgetKey&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name == other.name &amp;&amp; id == other.id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义哈希函数</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">WidgetKeyHash</span> &#123;</span><br><span class="line">    <span class="function">std::<span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> WidgetKey&amp; key)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">hash</span>&lt;QString&gt;()(key.name) ^ (std::<span class="built_in">hash</span>&lt;<span class="type">int</span>&gt;()(key.id) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义unordered_map，键为WidgetKey，值为shared_ptr&lt;QWidget&gt;</span></span><br><span class="line">    std::unordered_map&lt;WidgetKey, std::shared_ptr&lt;QWidget&gt;, WidgetKeyHash&gt; widget_map;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建并插入QWidget对象</span></span><br><span class="line">    WidgetKey key1 = &#123; <span class="string">&quot;MainWindow&quot;</span>, <span class="number">1</span> &#125;;</span><br><span class="line">    widget_map[key1] = std::<span class="built_in">make_shared</span>&lt;QWidget&gt;();</span><br><span class="line">    widget_map[key1]-&gt;<span class="built_in">setWindowTitle</span>(<span class="string">&quot;Main Window&quot;</span>);</span><br><span class="line"></span><br><span class="line">    WidgetKey key2 = &#123; <span class="string">&quot;SettingsDialog&quot;</span>, <span class="number">2</span> &#125;;</span><br><span class="line">    widget_map[key2] = std::<span class="built_in">make_shared</span>&lt;QWidget&gt;();</span><br><span class="line">    widget_map[key2]-&gt;<span class="built_in">setWindowTitle</span>(<span class="string">&quot;Settings Dialog&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找并显示窗口标题</span></span><br><span class="line">    WidgetKey search_key = &#123; <span class="string">&quot;MainWindow&quot;</span>, <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">auto</span> it = widget_map.<span class="built_in">find</span>(search_key);</span><br><span class="line">    <span class="keyword">if</span>(it != widget_map.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;找到窗口:&quot;</span> &lt;&lt; it-&gt;second-&gt;<span class="built_in">windowTitle</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;未找到指定的窗口。&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">找到窗口: &quot;Main Window&quot;</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>使用<code>std::unordered_map</code>管理Qt的<code>QWidget</code>对象，通过自定义键类型<code>WidgetKey</code>实现高效查找。</li>
<li>结合<code>std::shared_ptr</code>自动管理<code>QWidget</code>对象的生命周期，确保资源被正确释放。</li>
</ul>
<hr>
<h2 id="12-原子操作与线程同步"><a href="#12-原子操作与线程同步" class="headerlink" title="12. 原子操作与线程同步"></a>12. 原子操作与线程同步</h2><h3 id="12-1-原子操作（Atomic-Operations）"><a href="#12-1-原子操作（Atomic-Operations）" class="headerlink" title="12.1 原子操作（Atomic Operations）"></a>12.1 原子操作（Atomic Operations）</h3><h4 id="12-1-1-std-atomic-flag与std-atomic"><a href="#12-1-1-std-atomic-flag与std-atomic" class="headerlink" title="12.1.1 std::atomic_flag与std::atomic"></a>12.1.1 <code>std::atomic_flag</code>与<code>std::atomic</code></h4><p>C++11引入了原子操作类<code>std::atomic_flag</code>和<code>std::atomic</code>，用于在多线程环境中实现无锁编程，保证数据操作的原子性，防止数据竞争。</p>
<h4 id="12-1-2-使用std-atomic"><a href="#12-1-2-使用std-atomic" class="headerlink" title="12.1.2 使用std::atomic"></a>12.1.2 使用<code>std::atomic</code></h4><p><strong>示例：线程安全的计数器</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">counter</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">(<span class="type">int</span> num_iterations)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_iterations; ++i) &#123;</span><br><span class="line">        ++counter; <span class="comment">// 原子递增</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> num_threads = <span class="number">4</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> num_iterations = <span class="number">1000</span>;</span><br><span class="line">    std::vector&lt;std::thread&gt; threads;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动多个线程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_threads; ++i) &#123;</span><br><span class="line">        threads.<span class="built_in">emplace_back</span>(increment, num_iterations);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待所有线程完成</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; th : threads) &#123;</span><br><span class="line">        th.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;最终计数器值: &quot;</span> &lt;&lt; counter.<span class="built_in">load</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">最终计数器值: 4000</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>std::atomic&lt;int&gt;</code>保证<code>counter</code>的操作是原子的，避免了数据竞争。</li>
<li>使用<code>counter.load()</code>安全地读取当前值。</li>
</ul>
<h3 id="12-2-条件变量（Condition-Variable）"><a href="#12-2-条件变量（Condition-Variable）" class="headerlink" title="12.2 条件变量（Condition Variable）"></a>12.2 条件变量（Condition Variable）</h3><h4 id="12-2-1-条件变量的概念"><a href="#12-2-1-条件变量的概念" class="headerlink" title="12.2.1 条件变量的概念"></a>12.2.1 条件变量的概念</h4><p><code>std::condition_variable</code>用于线程间的同步与通信，允许一个或多个线程等待特定条件的发生。</p>
<h4 id="12-2-2-使用示例"><a href="#12-2-2-使用示例" class="headerlink" title="12.2.2 使用示例"></a>12.2.2 使用示例</h4><p><strong>示例：生产者-消费者问题</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::queue&lt;<span class="type">int</span>&gt; data_queue;</span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line"><span class="type">bool</span> finished = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">(<span class="type">int</span> num_items)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= num_items; ++i) &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">            data_queue.<span class="built_in">push</span>(i);</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;生产者生产: &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        cv.<span class="built_in">notify_one</span>(); <span class="comment">// 通知消费者</span></span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        finished = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cv.<span class="built_in">notify_all</span>(); <span class="comment">// 通知所有消费者生产结束</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        cv.<span class="built_in">wait</span>(lock, []&#123; <span class="keyword">return</span> !data_queue.<span class="built_in">empty</span>() || finished; &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!data_queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> item = data_queue.<span class="built_in">front</span>();</span><br><span class="line">            data_queue.<span class="built_in">pop</span>();</span><br><span class="line">            lock.<span class="built_in">unlock</span>();</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;消费者 &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; 消费: &quot;</span> &lt;&lt; item &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(finished) &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 生产结束，退出循环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">prod</span><span class="params">(producer, <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">cons1</span><span class="params">(consumer, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">cons2</span><span class="params">(consumer, <span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    prod.<span class="built_in">join</span>();</span><br><span class="line">    cons1.<span class="built_in">join</span>();</span><br><span class="line">    cons2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;所有任务完成。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">生产者生产: 1</span><br><span class="line">消费者 1 消费: 1</span><br><span class="line">生产者生产: 2</span><br><span class="line">消费者 2 消费: 2</span><br><span class="line">生产者生产: 3</span><br><span class="line">消费者 1 消费: 3</span><br><span class="line">...</span><br><span class="line">生产者生产: 10</span><br><span class="line">消费者 2 消费: 10</span><br><span class="line">所有任务完成。</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>生产者线程生产数据并将其放入队列，随后通知消费者。</li>
<li>消费者线程等待条件变量的通知，消费队列中的数据。</li>
<li>使用<code>finished</code>标志位通知消费者生产结束，避免无限等待。</li>
</ul>
<h3 id="12-3-在Qt中的应用"><a href="#12-3-在Qt中的应用" class="headerlink" title="12.3 在Qt中的应用"></a>12.3 在Qt中的应用</h3><p>在Qt开发中，多线程编程常涉及线程间的数据同步与通信。结合C++11的原子操作和条件变量，可以实现高效的线程同步机制，提升应用程序的性能和响应性。</p>
<p><strong>示例：使用条件变量实现线程同步</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line"><span class="type">bool</span> ready = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    cv.<span class="built_in">wait</span>(lock, []&#123; <span class="keyword">return</span> ready; &#125;); <span class="comment">// 等待信号</span></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;线程收到信号，开始工作。&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">th</span><span class="params">(worker)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;主线程正在准备数据...&quot;</span>;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>)); <span class="comment">// 模拟准备过程</span></span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        ready = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cv.<span class="built_in">notify_one</span>(); <span class="comment">// 发送信号</span></span><br><span class="line"></span><br><span class="line">    th.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">主线程正在准备数据...</span><br><span class="line">线程收到信号，开始工作。</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>工作线程等待条件变量的信号，直到<code>ready</code>标志位被设置为<code>true</code>。</li>
<li>主线程准备数据后，设置<code>ready</code>为<code>true</code>并通知工作线程开始工作。</li>
<li>通过<code>std::condition_variable</code>实现线程间的同步，确保工作线程在数据准备好后再开始工作。</li>
</ul>
<hr>
<h2 id="13-异常处理：exception的深入理解"><a href="#13-异常处理：exception的深入理解" class="headerlink" title="13. 异常处理：exception的深入理解"></a>13. 异常处理：<code>exception</code>的深入理解</h2><h3 id="13-1-异常类的层次结构"><a href="#13-1-异常类的层次结构" class="headerlink" title="13.1 异常类的层次结构"></a>13.1 异常类的层次结构</h3><p>C++标准库提供了一个异常类层次结构，所有标准异常类都继承自<code>std::exception</code>。常见的异常类包括：</p>
<ul>
<li><code>std::runtime_error</code></li>
<li><code>std::logic_error</code></li>
<li><code>std::invalid_argument</code></li>
<li><code>std::out_of_range</code></li>
<li><code>std::bad_alloc</code></li>
</ul>
<h3 id="13-2-自定义异常类型"><a href="#13-2-自定义异常类型" class="headerlink" title="13.2 自定义异常类型"></a>13.2 自定义异常类型</h3><p>自定义异常类可以提供更具体的错误信息，适用于特定的错误场景。自定义异常类通常继承自<code>std::exception</code>或其子类，并重写<code>what()</code>方法。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义异常类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyException</span> : <span class="keyword">public</span> std::exception &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyException</span>(<span class="type">const</span> std::string&amp; message) : <span class="built_in">msg_</span>(message) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">what</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> msg_.<span class="built_in">c_str</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string msg_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数，可能抛出自定义异常</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">riskyFunction</span><span class="params">(<span class="type">bool</span> triggerError)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(triggerError) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">MyException</span>(<span class="string">&quot;自定义错误发生！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;函数正常执行。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">riskyFunction</span>(<span class="literal">true</span>);</span><br><span class="line">    &#125; <span class="built_in">catch</span>(<span class="type">const</span> MyException&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;捕获到自定义异常: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="built_in">catch</span>(<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;捕获到标准异常: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="built_in">catch</span>(...) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;捕获到未知异常。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">捕获到自定义异常: 自定义错误发生！</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>MyException</code>继承自<code>std::exception</code>，并重写了<code>what()</code>方法以返回自定义错误信息。</li>
<li>在<code>riskyFunction</code>中，根据参数决定是否抛出<code>MyException</code>。</li>
<li><code>main</code>函数中的<code>try-catch</code>块捕获并处理自定义异常，确保程序能够优雅地应对错误。</li>
</ul>
<h3 id="13-3-异常安全性"><a href="#13-3-异常安全性" class="headerlink" title="13.3 异常安全性"></a>13.3 异常安全性</h3><p>编写异常安全的代码是提高程序可靠性的重要步骤。以下是实现异常安全性的几个关键原则：</p>
<ol>
<li><strong>强异常保证</strong>：操作要么完全成功，要么完全没有副作用。</li>
<li><strong>基本异常保证</strong>：即使发生异常，程序状态仍然保持有效。</li>
<li><strong>无异常保证</strong>：操作不会抛出任何异常。</li>
</ol>
<h4 id="13-3-1-使用RAII确保资源释放"><a href="#13-3-1-使用RAII确保资源释放" class="headerlink" title="13.3.1 使用RAII确保资源释放"></a>13.3.1 使用RAII确保资源释放</h4><p>结合RAII原则和智能指针，可以确保在异常发生时资源能够被正确释放，防止资源泄漏。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Resource</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Resource</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;资源分配。&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    ~<span class="built_in">Resource</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;资源释放。&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">use</span><span class="params">()</span> <span class="type">const</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;使用资源。&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::unique_ptr&lt;Resource&gt; res = std::<span class="built_in">make_unique</span>&lt;Resource&gt;();</span><br><span class="line">    res-&gt;<span class="built_in">use</span>();</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;处理过程中发生错误。&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">process</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span>(<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;异常捕获: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">资源分配。</span><br><span class="line">使用资源。</span><br><span class="line">资源释放。</span><br><span class="line">异常捕获: 处理过程中发生错误。</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>使用<code>std::unique_ptr</code>管理<code>Resource</code>对象，确保即使在<code>process</code>函数抛出异常时，资源也会被自动释放。</li>
<li>通过RAII和智能指针，简化了异常安全性的实现，提升了代码的可靠性。</li>
</ul>
<h3 id="13-4-在Qt中的应用"><a href="#13-4-在Qt中的应用" class="headerlink" title="13.4 在Qt中的应用"></a>13.4 在Qt中的应用</h3><p>在Qt开发中，异常处理同样重要，尤其是在处理文件操作、网络通信和动态内存管理等可能出现错误的场景中。结合Qt的信号槽机制和C++的异常处理机制，可以实现更加健壮的应用程序。</p>
<p><strong>示例：在Qt中处理文件读取异常</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QFile&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTextStream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义异常类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileException</span> : <span class="keyword">public</span> std::exception &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FileException</span>(<span class="type">const</span> QString&amp; message) : <span class="built_in">msg_</span>(message) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">what</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> msg_.<span class="built_in">toStdString</span>().<span class="built_in">c_str</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QString msg_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">readFile</span><span class="params">(<span class="type">const</span> QString&amp; filename)</span> </span>&#123;</span><br><span class="line">    <span class="function">QFile <span class="title">file</span><span class="params">(filename)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(!file.<span class="built_in">open</span>(QIODevice::ReadOnly | QIODevice::Text)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">FileException</span>(<span class="built_in">QString</span>(<span class="string">&quot;无法打开文件: %1&quot;</span>).<span class="built_in">arg</span>(filename));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">QTextStream <span class="title">in</span><span class="params">(&amp;file)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(!in.<span class="built_in">atEnd</span>()) &#123;</span><br><span class="line">        QString line = in.<span class="built_in">readLine</span>();</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; line;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">readFile</span>(<span class="string">&quot;nonexistent.txt&quot;</span>);</span><br><span class="line">    &#125; <span class="built_in">catch</span>(<span class="type">const</span> FileException&amp; e) &#123;</span><br><span class="line">        <span class="built_in">qCritical</span>() &lt;&lt; <span class="string">&quot;文件读取错误:&quot;</span> &lt;&lt; e.<span class="built_in">what</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span>(<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">        <span class="built_in">qCritical</span>() &lt;&lt; <span class="string">&quot;标准异常:&quot;</span> &lt;&lt; e.<span class="built_in">what</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">文件读取错误: 无法打开文件: nonexistent.txt</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>在<code>readFile</code>函数中，尝试打开文件，如果失败则抛出自定义的<code>FileException</code>。</li>
<li><code>main</code>函数中的<code>try-catch</code>块捕获并处理文件读取异常，确保应用程序不会因未处理的异常而崩溃。</li>
</ul>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章深入介绍了Qt C++语言中的新特性，包括正则表达式、智能指针、关键字<code>nullptr</code>与<code>constexpr</code>、多线程编程工具、STL的哈希映射容器<code>unordered_map</code>、原子操作与条件变量、异常处理的深入理解以及类型特性检测。这些新特性不仅提升了C++的编程能力，还为Qt开发提供了更高效、更安全和更灵活的工具和方法。</p>
<h3 id="主要内容回顾："><a href="#主要内容回顾：" class="headerlink" title="主要内容回顾："></a>主要内容回顾：</h3><ol>
<li><p><strong>正则表达式基础</strong></p>
<ul>
<li>使用C++11的<code>&lt;regex&gt;</code>库进行模式匹配、搜索和替换。</li>
<li>在Qt中使用<code>QRegularExpression</code>进行高级文本处理。</li>
</ul>
</li>
<li><p><strong>智能指针：<code>shared_ptr</code>、<code>unique_ptr</code> 与 <code>weak_ptr</code></strong></p>
<ul>
<li><code>std::unique_ptr</code>提供独占所有权，适用于唯一资源管理。</li>
<li><code>std::shared_ptr</code>允许多个指针共享资源，适用于需要共享所有权的场景。</li>
<li><code>std::weak_ptr</code>用于观察但不拥有资源，防止循环引用。</li>
</ul>
</li>
<li><p><strong>关键字：<code>nullptr</code> 与 <code>constexpr</code></strong></p>
<ul>
<li><code>nullptr</code>提升指针操作的类型安全性，替代传统的<code>NULL</code>。</li>
<li><code>constexpr</code>支持编译期常量计算，优化代码性能和安全性。</li>
</ul>
</li>
<li><p><strong>共享内存与互斥量（Mutex）</strong></p>
<ul>
<li>使用<code>std::mutex</code>和<code>std::lock_guard</code>保护共享资源，防止数据竞争。</li>
<li>在Qt中结合智能指针和互斥量实现线程安全的数据管理。</li>
</ul>
</li>
<li><p><strong>C++11 STL哈希映射容器：<code>std::unordered_map</code></strong></p>
<ul>
<li>提供高效的键值对存储和查找机制。</li>
<li>支持自定义类型作为键，通过自定义哈希函数实现高效查找。</li>
</ul>
</li>
<li><p><strong>原子操作与条件变量</strong></p>
<ul>
<li>使用<code>std::atomic</code>和<code>std::atomic_flag</code>实现无锁编程，确保数据操作的原子性。</li>
<li>使用<code>std::condition_variable</code>实现线程间的同步与通信，解决生产者-消费者问题。</li>
</ul>
</li>
<li><p><strong>异常处理：<code>exception</code>的深入理解</strong></p>
<ul>
<li>理解异常类的层次结构，使用标准异常类和自定义异常类。</li>
<li>结合RAII和智能指针实现异常安全的资源管理，提升程序的可靠性。</li>
</ul>
</li>
</ol>
<h3 id="下一步学习建议："><a href="#下一步学习建议：" class="headerlink" title="下一步学习建议："></a>下一步学习建议：</h3><p>掌握了上述C++的新特性后，建议继续深入以下内容，以全面提升Qt C++编程能力：</p>
<ul>
<li><p><strong>类型特性检测：<code>type_traits</code>库的应用</strong></p>
<ul>
<li>使用<code>std::is_integral</code>、<code>std::is_rvalue_reference</code>、<code>std::is_arithmetic</code>、<code>std::is_volatile</code>、<code>std::is_class</code>等进行类型判断，辅助模板元编程。</li>
</ul>
</li>
<li><p><strong>变量模板与内联变量（C++14）</strong></p>
<ul>
<li>学习C++14中的变量模板和<code>inline</code>变量的概念，应用于实际编程。</li>
</ul>
</li>
<li><p><strong>多线程编程的高级工具</strong></p>
<ul>
<li>深入了解线程局部存储、锁的优化策略、线程池等高级多线程编程工具。</li>
</ul>
</li>
<li><p><strong>模板编程的高级技巧</strong></p>
<ul>
<li>掌握模板元编程、SFINAE（替换失败不是错误）等高级模板编程技术，提升代码的泛化和复用能力。</li>
</ul>
</li>
<li><p><strong>Qt框架的核心概念与高级功能</strong></p>
<ul>
<li>深入学习Qt的信号与槽机制、事件处理、模型-视图架构、Qt Quick等高级功能，构建更复杂和功能丰富的应用程序。</li>
</ul>
</li>
</ul>
<p>持续关注，我们将在后续的文章中详细介绍这些内容，帮助您全面掌握Qt C++编程的新特性和高级技巧，提升开发效率，构建高质量的Qt应用程序。</p>
<hr>
<p><em>如果您对本文内容有任何疑问或建议，欢迎在评论区留言与我们交流。感谢您的阅读与支持！</em></p>
]]></content>
  </entry>
  <entry>
    <title>Qt C++语言编程基础</title>
    <url>/2024/12/26/Qt-C-%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><span id="more"></span>

<h1 id="Qt-C-语言编程基础详解"><a href="#Qt-C-语言编程基础详解" class="headerlink" title="Qt C++语言编程基础详解"></a>Qt C++语言编程基础详解</h1><p>在学习Qt开发之前，掌握C++编程语言的基础知识至关重要。本篇文章将详细介绍Qt C++语言编程的基础知识，包括Visual Studio 2022的安装、C++语言基础概述、指针与引用、类与对象以及其他相关特性。本文适合初学者和希望巩固基础的开发者。</p>
<hr>
<h2 id="1-Visual-Studio-2022安装"><a href="#1-Visual-Studio-2022安装" class="headerlink" title="1. Visual Studio 2022安装"></a>1. Visual Studio 2022安装</h2><h3 id="1-1-下载Visual-Studio-2022"><a href="#1-1-下载Visual-Studio-2022" class="headerlink" title="1.1 下载Visual Studio 2022"></a>1.1 下载Visual Studio 2022</h3><p>Visual Studio 2022是微软推出的集成开发环境（IDE），支持多种编程语言，包括C++。以下是下载和安装的步骤：</p>
<ol>
<li><p><strong>访问官方网站</strong>：<br>前往<a href="https://visualstudio.microsoft.com/">Visual Studio官网</a>。</p>
</li>
<li><p><strong>选择版本</strong>：<br>Visual Studio提供多个版本，包括Community（免费）、Professional和Enterprise。对于个人学习和开源项目，Community版已足够。</p>
<img src="../images/image-20241031160551024.png" alt="image-20241031160551024" style="zoom:50%;" />
</li>
<li><p><strong>下载安装程序</strong>：<br>点击“下载”按钮，下载Visual Studio Installer。</p>
</li>
</ol>
<h3 id="1-2-安装Visual-Studio-2022"><a href="#1-2-安装Visual-Studio-2022" class="headerlink" title="1.2 安装Visual Studio 2022"></a>1.2 安装Visual Studio 2022</h3><ol>
<li><p><strong>运行安装程序</strong>：<br>双击下载的安装程序（通常是<code>vs_installer.exe</code>）启动安装向导。</p>
<p><img src="/../images/image-20241031160450215.png" alt="image-20241031160450215"></p>
</li>
<li><p><strong>选择工作负载</strong>：<br>在安装向导中，选择适合的工作负载。对于C++开发，建议选择：</p>
<ul>
<li><p><strong>“使用C++的桌面开发”</strong>：包含用于开发Windows桌面应用的工具和库。</p>
</li>
<li><p><strong>“使用C++的游戏开发”</strong>（可选）：如果你计划进行游戏开发。</p>
<p><img src="/../images/1730361829428.jpg" alt="1730361829428"></p>
</li>
</ul>
<p><strong>安装组件</strong>：<br>根据需求，可以添加更多组件，如“C++ CMake工具”、“Visual Studio扩展”等。</p>
</li>
<li><p><strong>开始安装</strong>：<br>点击“安装”按钮，等待安装过程完成。这可能需要一些时间，具体取决于选择的组件和网络速度。</p>
</li>
<li><p><strong>首次启动</strong>：<br>安装完成后，启动Visual Studio。根据提示登录或创建一个微软账户，以便同步设置和获取更多功能。</p>
</li>
</ol>
<h3 id="1-3-配置C-开发环境"><a href="#1-3-配置C-开发环境" class="headerlink" title="1.3 配置C++开发环境"></a>1.3 配置C++开发环境</h3><ol>
<li><p><strong>更新和扩展</strong>：<br>确保所有组件已更新到最新版本。可以通过Visual Studio Installer进行更新。</p>
</li>
<li><p><strong>设置主题和布局</strong>：<br>在“工具” &gt; “选项”中，可以调整IDE的主题（如暗色模式）和编辑器布局，以提升开发体验。</p>
</li>
<li><p><strong>验证安装</strong>：<br>创建一个简单的C++控制台应用程序，确保开发环境配置正确。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello, Visual Studio 2022!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译并运行，确认输出“Hello, Visual Studio 2022!”。</p>
</li>
</ol>
<hr>
<h2 id="2-C-语言基础概述"><a href="#2-C-语言基础概述" class="headerlink" title="2. C++语言基础概述"></a>2. C++语言基础概述</h2><p>C++是一种功能强大的编程语言，广泛应用于系统软件、游戏开发、实时物理模拟等领域。以下是C++语言的基本组成部分。</p>
<h3 id="2-1-基本语法"><a href="#2-1-基本语法" class="headerlink" title="2.1 基本语法"></a>2.1 基本语法</h3><p>C++的基本语法类似于C语言，但引入了面向对象编程的特性。一个简单的C++程序结构如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> <span class="comment">// 预处理指令，包含输入输出库</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; <span class="comment">// 主函数，程序入口</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello, World!&quot;</span> &lt;&lt; std::endl; <span class="comment">// 输出语句</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-数据类型"><a href="#2-2-数据类型" class="headerlink" title="2.2 数据类型"></a>2.2 数据类型</h3><p>C++支持多种数据类型，主要分为基本数据类型和用户自定义数据类型。</p>
<ul>
<li><p><strong>基本数据类型</strong>：</p>
<ul>
<li>整型：<code>int</code>, <code>short</code>, <code>long</code>, <code>long long</code></li>
<li>浮点型：<code>float</code>, <code>double</code>, <code>long double</code></li>
<li>字符型：<code>char</code></li>
<li>布尔型：<code>bool</code></li>
</ul>
</li>
<li><p><strong>用户自定义数据类型</strong>：</p>
<ul>
<li>结构体（<code>struct</code>）</li>
<li>联合体（<code>union</code>）</li>
<li>枚举（<code>enum</code>）</li>
<li>类（<code>class</code>）</li>
</ul>
</li>
</ul>
<h3 id="2-3-控制结构"><a href="#2-3-控制结构" class="headerlink" title="2.3 控制结构"></a>2.3 控制结构</h3><p>控制结构用于控制程序的执行流程，主要包括条件语句和循环语句。</p>
<ul>
<li><p><strong>条件语句</strong>：</p>
<ul>
<li><code>if</code>语句</li>
<li><code>else if</code>和<code>else</code></li>
<li><code>switch</code>语句</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> number = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span> (number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Positive number&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (number &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Negative number&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Zero&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>循环语句</strong>：</p>
<ul>
<li><code>for</code>循环</li>
<li><code>while</code>循环</li>
<li><code>do-while</code>循环</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-4-编程范式"><a href="#2-4-编程范式" class="headerlink" title="2.4 编程范式"></a>2.4 编程范式</h3><p>C++支持多种编程范式，包括：</p>
<ul>
<li><strong>过程式编程</strong>：基于函数和过程的编程方式。</li>
<li><strong>面向对象编程（OOP）</strong>：基于对象和类，支持封装、继承和多态。</li>
<li><strong>泛型编程</strong>：通过模板实现代码的泛化和复用。</li>
<li><strong>函数式编程</strong>（部分支持）：如Lambda表达式和STL算法。</li>
</ul>
<hr>
<h2 id="3-C-指针与引用"><a href="#3-C-指针与引用" class="headerlink" title="3. C++指针与引用"></a>3. C++指针与引用</h2><p>指针和引用是C++中非常重要的概念，掌握它们对于理解内存管理和高效编程至关重要。</p>
<h3 id="3-1-指针（Pointer）"><a href="#3-1-指针（Pointer）" class="headerlink" title="3.1 指针（Pointer）"></a>3.1 指针（Pointer）</h3><p>指针是一个变量，用于存储另一个变量的内存地址。通过指针，可以间接访问和修改变量的值。</p>
<h4 id="3-1-1-指针的声明与初始化"><a href="#3-1-1-指针的声明与初始化" class="headerlink" title="3.1.1 指针的声明与初始化"></a>3.1.1 指针的声明与初始化</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> var = <span class="number">10</span>;    <span class="comment">// 声明一个整型变量</span></span><br><span class="line">    <span class="type">int</span>* ptr = &amp;var; <span class="comment">// 声明一个指向整型的指针，并初始化为var的地址</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;var的值: &quot;</span> &lt;&lt; var &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ptr指向的地址: &quot;</span> &lt;&lt; ptr &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ptr指向的值: &quot;</span> &lt;&lt; *ptr &lt;&lt; std::endl; <span class="comment">// 使用*运算符解引用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-1-2-指针运算"><a href="#3-1-2-指针运算" class="headerlink" title="3.1.2 指针运算"></a>3.1.2 指针运算</h4><p>指针可以进行算术运算，如加减。特别是在数组操作中，指针运算非常常见。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span>* p = arr; <span class="comment">// 指向数组的第一个元素</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">    std::cout &lt;&lt; *(p + i) &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 输出数组元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-1-3-空指针与悬空指针"><a href="#3-1-3-空指针与悬空指针" class="headerlink" title="3.1.3 空指针与悬空指针"></a>3.1.3 空指针与悬空指针</h4><ul>
<li><p><strong>空指针</strong>：不指向任何有效内存地址的指针，通常初始化为<code>nullptr</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>悬空指针</strong>：指针原本指向的内存已被释放或重新分配，但指针未被更新，导致指向无效地址。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">delete</span> ptr;</span><br><span class="line"><span class="comment">// ptr现在成为悬空指针</span></span><br><span class="line">ptr = <span class="literal">nullptr</span>; <span class="comment">// 及时置空，避免悬空</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-2-引用（Reference）"><a href="#3-2-引用（Reference）" class="headerlink" title="3.2 引用（Reference）"></a>3.2 引用（Reference）</h3><p>引用是一个变量的别名，必须在声明时初始化，且不能改变引用的对象。</p>
<h4 id="3-2-1-引用的声明与使用"><a href="#3-2-1-引用的声明与使用" class="headerlink" title="3.2.1 引用的声明与使用"></a>3.2.1 引用的声明与使用</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> var = <span class="number">20</span>;</span><br><span class="line">    <span class="type">int</span>&amp; ref = var; <span class="comment">// 声明一个引用，ref是var的别名</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;var的值: &quot;</span> &lt;&lt; var &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ref的值: &quot;</span> &lt;&lt; ref &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    ref = <span class="number">30</span>; <span class="comment">// 修改ref也会修改var</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;修改后的var: &quot;</span> &lt;&lt; var &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-2-常量引用"><a href="#3-2-2-常量引用" class="headerlink" title="3.2.2 常量引用"></a>3.2.2 常量引用</h4><p>常量引用用于绑定临时对象或常量，保证引用的对象不会被修改。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; ref)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;值为: &quot;</span> &lt;&lt; ref &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> var = <span class="number">50</span>;</span><br><span class="line">    <span class="built_in">printValue</span>(var);</span><br><span class="line">    <span class="built_in">printValue</span>(<span class="number">100</span>); <span class="comment">// 临时对象也可以通过常量引用传递</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-指针与引用的区别"><a href="#3-3-指针与引用的区别" class="headerlink" title="3.3 指针与引用的区别"></a>3.3 指针与引用的区别</h3><table>
<thead>
<tr>
<th>特性</th>
<th>指针</th>
<th>引用</th>
</tr>
</thead>
<tbody><tr>
<td>声明</td>
<td><code>int* ptr;</code></td>
<td><code>int&amp; ref = var;</code></td>
</tr>
<tr>
<td>初始化</td>
<td>可以先声明后初始化</td>
<td>必须在声明时初始化</td>
</tr>
<tr>
<td>重赋值</td>
<td>可以指向不同的变量</td>
<td>不能改变引用的目标</td>
</tr>
<tr>
<td>空值</td>
<td>可以为<code>nullptr</code></td>
<td>必须引用有效的对象，不允许为空</td>
</tr>
<tr>
<td>语法</td>
<td>需要使用<code>*</code>和<code>&amp;</code>进行解引用和取地址</td>
<td>直接使用，无需额外运算符</td>
</tr>
</tbody></table>
<h3 id="3-4-内存管理的重要性"><a href="#3-4-内存管理的重要性" class="headerlink" title="3.4 内存管理的重要性"></a>3.4 内存管理的重要性</h3><p>正确使用指针和引用对于内存管理至关重要。错误的指针操作可能导致内存泄漏、悬空指针和未定义行为。使用智能指针（如<code>std::unique_ptr</code>和<code>std::shared_ptr</code>）可以有效管理动态内存，减少错误风险。</p>
<hr>
<h2 id="4-C-类与对象（一）"><a href="#4-C-类与对象（一）" class="headerlink" title="4. C++类与对象（一）"></a>4. C++类与对象（一）</h2><p>面向对象编程（OOP）是C++的重要特性之一，通过类和对象实现代码的封装、复用和扩展。以下是C++中类与对象的基本概念。</p>
<h3 id="4-1-类（Class）"><a href="#4-1-类（Class）" class="headerlink" title="4.1 类（Class）"></a>4.1 类（Class）</h3><p>类是对象的蓝图，定义了对象的属性（成员变量）和行为（成员函数）。</p>
<h4 id="4-1-1-类的定义"><a href="#4-1-1-类的定义" class="headerlink" title="4.1.1 类的定义"></a>4.1.1 类的定义</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Person</span>(std::string name, <span class="type">int</span> age) : <span class="built_in">name_</span>(name), <span class="built_in">age_</span>(age) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">introduce</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;我是&quot;</span> &lt;&lt; name_ &lt;&lt; <span class="string">&quot;，今年&quot;</span> &lt;&lt; age_ &lt;&lt; <span class="string">&quot;岁。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 成员变量</span></span><br><span class="line">    std::string name_;</span><br><span class="line">    <span class="type">int</span> age_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>访问修饰符</strong>：<ul>
<li><code>public</code>：公有成员，类外可以访问。</li>
<li><code>private</code>：私有成员，类外不可访问。</li>
<li><code>protected</code>：受保护成员，派生类可以访问。</li>
</ul>
</li>
</ul>
<h4 id="4-1-2-类的实例化"><a href="#4-1-2-类的实例化" class="headerlink" title="4.1.2 类的实例化"></a>4.1.2 类的实例化</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">person</span><span class="params">(<span class="string">&quot;张三&quot;</span>, <span class="number">25</span>)</span></span>; <span class="comment">// 创建对象</span></span><br><span class="line">    person.<span class="built_in">introduce</span>(); <span class="comment">// 调用成员函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-对象（Object）"><a href="#4-2-对象（Object）" class="headerlink" title="4.2 对象（Object）"></a>4.2 对象（Object）</h3><p>对象是类的实例，具有类定义的属性和行为。每个对象在内存中占有独立的空间。</p>
<h4 id="4-2-1-动态对象与静态对象"><a href="#4-2-1-动态对象与静态对象" class="headerlink" title="4.2.1 动态对象与静态对象"></a>4.2.1 动态对象与静态对象</h4><ul>
<li><p><strong>静态对象</strong>：在栈上分配，生命周期由作用域决定。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Person <span class="title">person</span><span class="params">(<span class="string">&quot;李四&quot;</span>, <span class="number">30</span>)</span></span>; <span class="comment">// 静态对象</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>动态对象</strong>：在堆上分配，需要手动管理内存。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Person* ptr = <span class="keyword">new</span> <span class="built_in">Person</span>(<span class="string">&quot;王五&quot;</span>, <span class="number">35</span>); <span class="comment">// 动态对象</span></span><br><span class="line">ptr-&gt;<span class="built_in">introduce</span>();</span><br><span class="line"><span class="keyword">delete</span> ptr; <span class="comment">// 释放内存</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-3-成员变量与成员函数"><a href="#4-3-成员变量与成员函数" class="headerlink" title="4.3 成员变量与成员函数"></a>4.3 成员变量与成员函数</h3><ul>
<li><p><strong>成员变量</strong>：描述对象的状态和属性。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rectangle</span>(<span class="type">double</span> width, <span class="type">double</span> height) : <span class="built_in">width_</span>(width), <span class="built_in">height_</span>(height) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">area</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> width_ * height_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> width_;</span><br><span class="line">    <span class="type">double</span> height_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>成员函数</strong>：描述对象的行为和操作。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Rectangle <span class="title">rect</span><span class="params">(<span class="number">5.0</span>, <span class="number">3.0</span>)</span></span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;面积: &quot;</span> &lt;&lt; rect.<span class="built_in">area</span>() &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-4-访问修饰符"><a href="#4-4-访问修饰符" class="headerlink" title="4.4 访问修饰符"></a>4.4 访问修饰符</h3><p>访问修饰符用于控制类成员的可见性和访问权限。</p>
<ul>
<li><strong>public</strong>：公开成员，类外可访问。</li>
<li><strong>private</strong>：私有成员，类外不可访问。</li>
<li><strong>protected</strong>：受保护成员，只有派生类和类内部可访问。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">publicMethod</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">protectedMethod</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">privateMethod</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">accessMethods</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">publicMethod</span>();      <span class="comment">// 可访问</span></span><br><span class="line">        <span class="built_in">protectedMethod</span>();   <span class="comment">// 可访问</span></span><br><span class="line">        <span class="comment">// privateMethod();  // 不可访问，编译错误</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="4-5-封装（Encapsulation）"><a href="#4-5-封装（Encapsulation）" class="headerlink" title="4.5 封装（Encapsulation）"></a>4.5 封装（Encapsulation）</h3><p>封装是OOP的核心概念，通过将数据和操作数据的函数绑定在一起，隐藏内部实现细节，仅暴露接口，提升代码的安全性和可维护性。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BankAccount</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BankAccount</span>(<span class="type">double</span> balance) : <span class="built_in">balance_</span>(balance) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deposit</span><span class="params">(<span class="type">double</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (amount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            balance_ += amount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">withdraw</span><span class="params">(<span class="type">double</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (amount &gt; <span class="number">0</span> &amp;&amp; amount &lt;= balance_) &#123;</span><br><span class="line">            balance_ -= amount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getBalance</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> balance_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> balance_; <span class="comment">// 私有成员，外部不可直接访问</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="5-C-类与对象（二）"><a href="#5-C-类与对象（二）" class="headerlink" title="5. C++类与对象（二）"></a>5. C++类与对象（二）</h2><p>在掌握了类与对象的基础后，进一步了解C++中类的高级特性，如继承、多态和封装等，将有助于编写更灵活和可复用的代码。</p>
<h3 id="5-1-继承（Inheritance）"><a href="#5-1-继承（Inheritance）" class="headerlink" title="5.1 继承（Inheritance）"></a>5.1 继承（Inheritance）</h3><p>继承允许一个类（派生类）继承另一个类（基类）的属性和行为，从而实现代码复用和层次化设计。</p>
<h4 id="5-1-1-单继承"><a href="#5-1-1-单继承" class="headerlink" title="5.1.1 单继承"></a>5.1.1 单继承</h4><p>单继承指一个派生类只能继承一个基类。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;动物在吃食物。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bark</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;狗在叫。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Dog dog;</span><br><span class="line">    dog.<span class="built_in">eat</span>();  <span class="comment">// 继承自Animal</span></span><br><span class="line">    dog.<span class="built_in">bark</span>(); <span class="comment">// Dog自身的函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-1-2-多继承"><a href="#5-1-2-多继承" class="headerlink" title="5.1.2 多继承"></a>5.1.2 多继承</h4><p>多继承指一个派生类可以继承多个基类。虽然多继承提供了更大的灵活性，但也可能引发复杂性，如菱形继承问题。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Flyer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;可以飞行。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Swimmer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;可以游泳。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Duck</span> : <span class="keyword">public</span> Flyer, <span class="keyword">public</span> Swimmer &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">quack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;鸭子在叫。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Duck duck;</span><br><span class="line">    duck.<span class="built_in">fly</span>();</span><br><span class="line">    duck.<span class="built_in">swim</span>();</span><br><span class="line">    duck.<span class="built_in">quack</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-多态（Polymorphism）"><a href="#5-2-多态（Polymorphism）" class="headerlink" title="5.2 多态（Polymorphism）"></a>5.2 多态（Polymorphism）</h3><p>多态允许对象以多种形式出现，主要通过虚函数实现。它使得同一接口可以调用不同的实现，增强了代码的灵活性和可扩展性。</p>
<h4 id="5-2-1-虚函数"><a href="#5-2-1-虚函数" class="headerlink" title="5.2.1 虚函数"></a>5.2.1 虚函数</h4><p>虚函数是在基类中声明为<code>virtual</code>的成员函数，允许派生类重写它们。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;绘制一个形状。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;绘制一个圆形。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;绘制一个矩形。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Shape* shape1 = <span class="keyword">new</span> <span class="built_in">Circle</span>();</span><br><span class="line">    Shape* shape2 = <span class="keyword">new</span> <span class="built_in">Rectangle</span>();</span><br><span class="line"></span><br><span class="line">    shape1-&gt;<span class="built_in">draw</span>(); <span class="comment">// 输出：绘制一个圆形。</span></span><br><span class="line">    shape2-&gt;<span class="built_in">draw</span>(); <span class="comment">// 输出：绘制一个矩形。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> shape1;</span><br><span class="line">    <span class="keyword">delete</span> shape2;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-2-2-抽象类"><a href="#5-2-2-抽象类" class="headerlink" title="5.2.2 抽象类"></a>5.2.2 抽象类</h4><p>抽象类是包含至少一个纯虚函数的类，不能实例化，通常作为接口使用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractShape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>; <span class="comment">// 纯虚函数</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">AbstractShape</span>() = <span class="keyword">default</span>; <span class="comment">// 虚析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Triangle</span> : <span class="keyword">public</span> AbstractShape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;绘制一个三角形。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// AbstractShape shape; // 错误，无法实例化抽象类</span></span><br><span class="line">    AbstractShape* shape = <span class="keyword">new</span> <span class="built_in">Triangle</span>();</span><br><span class="line">    shape-&gt;<span class="built_in">draw</span>(); <span class="comment">// 输出：绘制一个三角形。</span></span><br><span class="line">    <span class="keyword">delete</span> shape;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-3-封装与访问控制"><a href="#5-3-封装与访问控制" class="headerlink" title="5.3 封装与访问控制"></a>5.3 封装与访问控制</h3><p>封装不仅仅是将数据和函数绑定在一起，还涉及通过访问控制符限制对数据的访问，确保数据的一致性和安全性。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Employee</span>(std::string name, <span class="type">double</span> salary) : <span class="built_in">name_</span>(name), <span class="built_in">salary_</span>(salary) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setSalary</span><span class="params">(<span class="type">double</span> salary)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (salary &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            salary_ = salary;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getSalary</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> salary_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name_;</span><br><span class="line">    <span class="type">double</span> salary_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>salary_</code>是私有成员，不能直接从类外部访问。通过<code>setSalary</code>和<code>getSalary</code>函数来控制对<code>salary_</code>的访问和修改，确保其值始终有效。</p>
<h3 id="5-4-构造函数与析构函数"><a href="#5-4-构造函数与析构函数" class="headerlink" title="5.4 构造函数与析构函数"></a>5.4 构造函数与析构函数</h3><p>构造函数和析构函数是类中用于对象生命周期管理的重要成员函数。</p>
<h4 id="5-4-1-构造函数"><a href="#5-4-1-构造函数" class="headerlink" title="5.4.1 构造函数"></a>5.4.1 构造函数</h4><p>构造函数用于在创建对象时初始化成员变量。</p>
<ul>
<li><strong>默认构造函数</strong>：无参数构造函数。</li>
<li><strong>带参数构造函数</strong>：接受参数，用于初始化对象。</li>
<li><strong>拷贝构造函数</strong>：用于通过已有对象创建新对象。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="built_in">Point</span>() : <span class="built_in">x_</span>(<span class="number">0</span>), <span class="built_in">y_</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带参数构造函数</span></span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">double</span> x, <span class="type">double</span> y) : <span class="built_in">x_</span>(x), <span class="built_in">y_</span>(y) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">const</span> Point&amp; other) : <span class="built_in">x_</span>(other.x_), <span class="built_in">y_</span>(other.y_) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> x_;</span><br><span class="line">    <span class="type">double</span> y_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="5-4-2-析构函数"><a href="#5-4-2-析构函数" class="headerlink" title="5.4.2 析构函数"></a>5.4.2 析构函数</h4><p>析构函数在对象生命周期结束时自动调用，用于释放资源。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Resource</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Resource</span>() &#123;</span><br><span class="line">        data_ = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">100</span>];</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;资源已分配。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Resource</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] data_;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;资源已释放。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>* data_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        Resource res;</span><br><span class="line">    &#125; <span class="comment">// res的析构函数自动调用，释放资源</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-4-3-拷贝构造函数"><a href="#5-4-3-拷贝构造函数" class="headerlink" title="5.4.3 拷贝构造函数"></a>5.4.3 拷贝构造函数</h4><p>拷贝构造函数用于创建一个对象，该对象是通过另一个同类型对象的复制构造而来。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CopyExample</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CopyExample</span>(<span class="type">int</span> value) : <span class="built_in">value_</span>(value) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义拷贝构造函数</span></span><br><span class="line">    <span class="built_in">CopyExample</span>(<span class="type">const</span> CopyExample&amp; other) : <span class="built_in">value_</span>(other.value_) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;拷贝构造函数被调用。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">CopyExample <span class="title">obj1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    CopyExample obj2 = obj1; <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果没有自定义拷贝构造函数，编译器将生成默认的拷贝构造函数，逐个成员进行拷贝。</p>
<hr>
<h2 id="6-类的其他特性"><a href="#6-类的其他特性" class="headerlink" title="6. 类的其他特性"></a>6. 类的其他特性</h2><p>除了继承、多态和基本的封装，C++类还具备许多高级特性，如友元、静态成员、嵌套类和匿名对象等。这些特性使得C++类更加灵活和强大。</p>
<h3 id="6-1-友元（Friend）"><a href="#6-1-友元（Friend）" class="headerlink" title="6.1 友元（Friend）"></a>6.1 友元（Friend）</h3><p>友元允许外部函数或类访问类的私有和受保护成员。尽管这违背了封装原则，但在某些情况下非常有用，如重载运算符或实现辅助功能。</p>
<h4 id="6-1-1-友元函数"><a href="#6-1-1-友元函数" class="headerlink" title="6.1.1 友元函数"></a>6.1.1 友元函数</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> width_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Box</span>(<span class="type">double</span> width) : <span class="built_in">width_</span>(width) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明友元函数</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">printWidth</span><span class="params">(<span class="type">const</span> Box&amp; box)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义友元函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printWidth</span><span class="params">(<span class="type">const</span> Box&amp; box)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Box width: &quot;</span> &lt;&lt; box.width_ &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Box <span class="title">box</span><span class="params">(<span class="number">10.5</span>)</span></span>;</span><br><span class="line">    <span class="built_in">printWidth</span>(box); <span class="comment">// 友元函数可以访问私有成员</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-1-2-友元类"><a href="#6-1-2-友元类" class="headerlink" title="6.1.2 友元类"></a>6.1.2 友元类</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassB</span>; <span class="comment">// 前向声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassA</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ClassA</span>(<span class="type">int</span> value) : <span class="built_in">value_</span>(value) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明ClassB为友元类</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">ClassB</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassB</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showValue</span><span class="params">(<span class="type">const</span> ClassA&amp; a)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ClassA的值: &quot;</span> &lt;&lt; a.value_ &lt;&lt; std::endl; <span class="comment">// 访问ClassA的私有成员</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ClassA <span class="title">a</span><span class="params">(<span class="number">42</span>)</span></span>;</span><br><span class="line">    ClassB b;</span><br><span class="line">    b.<span class="built_in">showValue</span>(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-2-静态成员（Static-Members）"><a href="#6-2-静态成员（Static-Members）" class="headerlink" title="6.2 静态成员（Static Members）"></a>6.2 静态成员（Static Members）</h3><p>静态成员属于类本身，而不是类的任何实例。静态成员变量在所有对象之间共享，静态成员函数只能访问静态成员。</p>
<h4 id="6-2-1-静态成员变量"><a href="#6-2-1-静态成员变量" class="headerlink" title="6.2.1 静态成员变量"></a>6.2.1 静态成员变量</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count; <span class="comment">// 静态成员变量声明</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Counter</span>() &#123;</span><br><span class="line">        ++count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Counter</span>() &#123;</span><br><span class="line">        --count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态成员变量定义和初始化</span></span><br><span class="line"><span class="type">int</span> Counter::count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;初始计数: &quot;</span> &lt;&lt; Counter::count &lt;&lt; std::endl;</span><br><span class="line">    Counter c1;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;创建一个对象后计数: &quot;</span> &lt;&lt; Counter::count &lt;&lt; std::endl;</span><br><span class="line">    &#123;</span><br><span class="line">        Counter c2;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;创建第二个对象后计数: &quot;</span> &lt;&lt; Counter::count &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;销毁第二个对象后计数: &quot;</span> &lt;&lt; Counter::count &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-2-2-静态成员函数"><a href="#6-2-2-静态成员函数" class="headerlink" title="6.2.2 静态成员函数"></a>6.2.2 静态成员函数</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Utility</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">showMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;这是一个静态成员函数。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Utility::<span class="built_in">showMessage</span>(); <span class="comment">// 直接通过类名调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-3-嵌套类（Nested-Classes）"><a href="#6-3-嵌套类（Nested-Classes）" class="headerlink" title="6.3 嵌套类（Nested Classes）"></a>6.3 嵌套类（Nested Classes）</h3><p>嵌套类是在一个类的内部定义的类。嵌套类可以访问外部类的成员，包括私有成员。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;这是嵌套类Inner的成员函数。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showInner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Inner inner;</span><br><span class="line">        inner.<span class="built_in">display</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Outer outer;</span><br><span class="line">    outer.<span class="built_in">showInner</span>();</span><br><span class="line"></span><br><span class="line">    Outer::Inner inner;</span><br><span class="line">    inner.<span class="built_in">display</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-4-匿名对象（Temporary-Objects）"><a href="#6-4-匿名对象（Temporary-Objects）" class="headerlink" title="6.4 匿名对象（Temporary Objects）"></a>6.4 匿名对象（Temporary Objects）</h3><p>匿名对象是没有名字的临时对象，通常用于函数返回值或作为表达式的一部分。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Temp</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Temp</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;临时对象已创建。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Temp</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;临时对象已销毁。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;临时对象的方法。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Temp</span>().<span class="built_in">show</span>(); <span class="comment">// 创建一个匿名对象并调用show方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="7-构造函数、析构函数与拷贝构造函数"><a href="#7-构造函数、析构函数与拷贝构造函数" class="headerlink" title="7. 构造函数、析构函数与拷贝构造函数"></a>7. 构造函数、析构函数与拷贝构造函数</h2><p>对象的生命周期管理是C++编程中的重要方面。构造函数、析构函数和拷贝构造函数在管理资源和确保对象正确初始化和销毁中起着关键作用。</p>
<h3 id="7-1-构造函数（Constructor）"><a href="#7-1-构造函数（Constructor）" class="headerlink" title="7.1 构造函数（Constructor）"></a>7.1 构造函数（Constructor）</h3><p>构造函数是一个特殊的成员函数，用于在创建对象时初始化成员变量。构造函数的名称与类名相同，且没有返回类型。</p>
<h4 id="7-1-1-默认构造函数"><a href="#7-1-1-默认构造函数" class="headerlink" title="7.1.1 默认构造函数"></a>7.1.1 默认构造函数</h4><p>如果未显式定义任何构造函数，编译器将生成一个默认构造函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DefaultExample</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DefaultExample obj;</span><br><span class="line">    obj.value = <span class="number">100</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;值: &quot;</span> &lt;&lt; obj.value &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-1-2-带参数构造函数"><a href="#7-1-2-带参数构造函数" class="headerlink" title="7.1.2 带参数构造函数"></a>7.1.2 带参数构造函数</h4><p>带参数构造函数允许在创建对象时传递初始值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parameterized</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Parameterized</span>(<span class="type">int</span> x, <span class="type">int</span> y) : <span class="built_in">x_</span>(x), <span class="built_in">y_</span>(y) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;x = &quot;</span> &lt;&lt; x_ &lt;&lt; <span class="string">&quot;, y = &quot;</span> &lt;&lt; y_ &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x_;</span><br><span class="line">    <span class="type">int</span> y_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Parameterized <span class="title">obj</span><span class="params">(<span class="number">5</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    obj.<span class="built_in">display</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-1-3-委托构造函数（C-11引入）"><a href="#7-1-3-委托构造函数（C-11引入）" class="headerlink" title="7.1.3 委托构造函数（C++11引入）"></a>7.1.3 委托构造函数（C++11引入）</h4><p>委托构造函数允许一个构造函数调用同一类中的另一个构造函数，以减少重复代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point</span>() : <span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>) &#123;&#125; <span class="comment">// 委托调用带参数构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">int</span> x, <span class="type">int</span> y) : <span class="built_in">x_</span>(x), <span class="built_in">y_</span>(y) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Point(&quot;</span> &lt;&lt; x_ &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y_ &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x_;</span><br><span class="line">    <span class="type">int</span> y_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Point p1;</span><br><span class="line">    <span class="function">Point <span class="title">p2</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">    p1.<span class="built_in">display</span>();</span><br><span class="line">    p2.<span class="built_in">display</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-2-析构函数（Destructor）"><a href="#7-2-析构函数（Destructor）" class="headerlink" title="7.2 析构函数（Destructor）"></a>7.2 析构函数（Destructor）</h3><p>析构函数在对象生命周期结束时自动调用，用于释放资源和执行清理工作。析构函数的名称为类名之前加上波浪号（<code>~</code>），且没有参数和返回类型。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ResourceHolder</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ResourceHolder</span>() &#123;</span><br><span class="line">        data_ = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">100</span>];</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;资源已分配。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">ResourceHolder</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] data_;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;资源已释放。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>* data_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        ResourceHolder holder;</span><br><span class="line">    &#125; <span class="comment">// holder的析构函数自动调用，释放资源</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-3-拷贝构造函数（Copy-Constructor）"><a href="#7-3-拷贝构造函数（Copy-Constructor）" class="headerlink" title="7.3 拷贝构造函数（Copy Constructor）"></a>7.3 拷贝构造函数（Copy Constructor）</h3><p>拷贝构造函数用于通过现有对象创建新对象，确保对象的正确复制，尤其是在管理动态资源时。</p>
<h4 id="7-3-1-默认拷贝构造函数"><a href="#7-3-1-默认拷贝构造函数" class="headerlink" title="7.3.1 默认拷贝构造函数"></a>7.3.1 默认拷贝构造函数</h4><p>如果未显式定义拷贝构造函数，编译器将生成一个默认的成员逐个拷贝的拷贝构造函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Simple</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Simple obj1;</span><br><span class="line">    obj1.value = <span class="number">10</span>;</span><br><span class="line">    Simple obj2 = obj1; <span class="comment">// 使用默认拷贝构造函数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;obj2.value = &quot;</span> &lt;&lt; obj2.value &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-3-2-自定义拷贝构造函数"><a href="#7-3-2-自定义拷贝构造函数" class="headerlink" title="7.3.2 自定义拷贝构造函数"></a>7.3.2 自定义拷贝构造函数</h4><p>对于包含指针或需要深拷贝的类，需自定义拷贝构造函数，以避免浅拷贝带来的问题。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DeepCopy</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DeepCopy</span>(<span class="type">int</span> size) : <span class="built_in">size_</span>(size), <span class="built_in">data_</span>(<span class="keyword">new</span> <span class="type">int</span>[size]) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size_; ++i) &#123;</span><br><span class="line">            data_[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义拷贝构造函数</span></span><br><span class="line">    <span class="built_in">DeepCopy</span>(<span class="type">const</span> DeepCopy&amp; other) : <span class="built_in">size_</span>(other.size_), <span class="built_in">data_</span>(<span class="keyword">new</span> <span class="type">int</span>[other.size_]) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size_; ++i) &#123;</span><br><span class="line">            data_[i] = other.data_[i];</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;深拷贝构造函数被调用。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">DeepCopy</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] data_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size_; ++i) &#123;</span><br><span class="line">            std::cout &lt;&lt; data_[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> size_;</span><br><span class="line">    <span class="type">int</span>* data_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">DeepCopy <span class="title">obj1</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    DeepCopy obj2 = obj1; <span class="comment">// 调用自定义拷贝构造函数</span></span><br><span class="line">    obj2.<span class="built_in">display</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="8-C-友元与动态内存"><a href="#8-C-友元与动态内存" class="headerlink" title="8. C++友元与动态内存"></a>8. C++友元与动态内存</h2><p>友元和动态内存管理是C++中高级但重要的概念，掌握它们有助于编写高效和安全的代码。</p>
<h3 id="8-1-友元（Friend）"><a href="#8-1-友元（Friend）" class="headerlink" title="8.1 友元（Friend）"></a>8.1 友元（Friend）</h3><p>友元允许非成员函数或类访问类的私有和受保护成员。虽然增加了灵活性，但滥用友元可能破坏封装性。</p>
<h4 id="8-1-1-友元函数"><a href="#8-1-1-友元函数" class="headerlink" title="8.1.1 友元函数"></a>8.1.1 友元函数</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> width_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Box</span>(<span class="type">double</span> width) : <span class="built_in">width_</span>(width) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明友元函数</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">printWidth</span><span class="params">(<span class="type">const</span> Box&amp; box)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义友元函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printWidth</span><span class="params">(<span class="type">const</span> Box&amp; box)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Box width: &quot;</span> &lt;&lt; box.width_ &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Box <span class="title">box</span><span class="params">(<span class="number">15.5</span>)</span></span>;</span><br><span class="line">    <span class="built_in">printWidth</span>(box); <span class="comment">// 友元函数可以访问私有成员</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-1-2-友元类"><a href="#8-1-2-友元类" class="headerlink" title="8.1.2 友元类"></a>8.1.2 友元类</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassB</span>; <span class="comment">// 前向声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassA</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> secret_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ClassA</span>(<span class="type">int</span> secret) : <span class="built_in">secret_</span>(secret) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明ClassB为友元类</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">ClassB</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassB</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">revealSecret</span><span class="params">(<span class="type">const</span> ClassA&amp; a)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ClassA的秘密: &quot;</span> &lt;&lt; a.secret_ &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ClassA <span class="title">a</span><span class="params">(<span class="number">12345</span>)</span></span>;</span><br><span class="line">    ClassB b;</span><br><span class="line">    b.<span class="built_in">revealSecret</span>(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-2-动态内存管理"><a href="#8-2-动态内存管理" class="headerlink" title="8.2 动态内存管理"></a>8.2 动态内存管理</h3><p>C++允许程序在运行时动态分配和释放内存。正确管理动态内存是确保程序稳定性和防止内存泄漏的关键。</p>
<h4 id="8-2-1-使用new和delete"><a href="#8-2-1-使用new和delete" class="headerlink" title="8.2.1 使用new和delete"></a>8.2.1 使用<code>new</code>和<code>delete</code></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 动态分配单个整数</span></span><br><span class="line">    <span class="type">int</span>* ptr = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">42</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;动态分配的值: &quot;</span> &lt;&lt; *ptr &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">delete</span> ptr; <span class="comment">// 释放内存</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态分配数组</span></span><br><span class="line">    <span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        arr[i] = i * <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">delete</span>[] arr; <span class="comment">// 释放数组内存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-2-2-智能指针"><a href="#8-2-2-智能指针" class="headerlink" title="8.2.2 智能指针"></a>8.2.2 智能指针</h4><p>为了简化动态内存管理，C++11引入了智能指针，包括<code>std::unique_ptr</code>、<code>std::shared_ptr</code>和<code>std::weak_ptr</code>，它们通过RAII（资源获取即初始化）机制自动管理内存，减少内存泄漏的风险。</p>
<h5 id="8-2-2-1-std-unique-ptr"><a href="#8-2-2-1-std-unique-ptr" class="headerlink" title="8.2.2.1 std::unique_ptr"></a>8.2.2.1 <code>std::unique_ptr</code></h5><p><code>std::unique_ptr</code>表示对动态分配对象的独占所有权，不能复制，只能移动。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Widget构造。&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    ~<span class="built_in">Widget</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Widget析构。&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">greet</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Hello from Widget!&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::unique_ptr&lt;Widget&gt; ptr1 = std::<span class="built_in">make_unique</span>&lt;Widget&gt;();</span><br><span class="line">    ptr1-&gt;<span class="built_in">greet</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// std::unique_ptr&lt;Widget&gt; ptr2 = ptr1; // 错误，不能复制</span></span><br><span class="line">    std::unique_ptr&lt;Widget&gt; ptr2 = std::<span class="built_in">move</span>(ptr1); <span class="comment">// 通过移动所有权</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ptr1) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ptr1不再拥有Widget。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ptr2-&gt;<span class="built_in">greet</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="8-2-2-2-std-shared-ptr"><a href="#8-2-2-2-std-shared-ptr" class="headerlink" title="8.2.2.2 std::shared_ptr"></a>8.2.2.2 <code>std::shared_ptr</code></h5><p><code>std::shared_ptr</code>允许多个指针共享同一个动态分配对象，通过引用计数管理对象生命周期。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Gadget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Gadget</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Gadget构造。&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    ~<span class="built_in">Gadget</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Gadget析构。&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Gadget在工作。&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;Gadget&gt; sp1 = std::<span class="built_in">make_shared</span>&lt;Gadget&gt;();</span><br><span class="line">    &#123;</span><br><span class="line">        std::shared_ptr&lt;Gadget&gt; sp2 = sp1; <span class="comment">// 引用计数增加</span></span><br><span class="line">        sp2-&gt;<span class="built_in">show</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;引用计数: &quot;</span> &lt;&lt; sp1.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="comment">// sp2析构，引用计数减少</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;引用计数: &quot;</span> &lt;&lt; sp1.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">// sp1析构，Gadget被释放</span></span><br></pre></td></tr></table></figure>

<h5 id="8-2-2-3-std-weak-ptr"><a href="#8-2-2-3-std-weak-ptr" class="headerlink" title="8.2.2.3 std::weak_ptr"></a>8.2.2.3 <code>std::weak_ptr</code></h5><p><code>std::weak_ptr</code>是<code>std::shared_ptr</code>的辅助工具，用于解决循环引用问题，不增加引用计数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::shared_ptr&lt;Node&gt; next;</span><br><span class="line">    std::weak_ptr&lt;Node&gt; prev; <span class="comment">// 使用weak_ptr避免循环引用</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Node</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Node构造。&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    ~<span class="built_in">Node</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Node析构。&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;Node&gt; node1 = std::<span class="built_in">make_shared</span>&lt;Node&gt;();</span><br><span class="line">    std::shared_ptr&lt;Node&gt; node2 = std::<span class="built_in">make_shared</span>&lt;Node&gt;();</span><br><span class="line"></span><br><span class="line">    node1-&gt;next = node2;</span><br><span class="line">    node2-&gt;prev = node1; <span class="comment">// 使用weak_ptr，不增加引用计数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-3-内存管理的最佳实践"><a href="#8-3-内存管理的最佳实践" class="headerlink" title="8.3 内存管理的最佳实践"></a>8.3 内存管理的最佳实践</h3><ul>
<li><strong>避免内存泄漏</strong>：确保每一个<code>new</code>都有对应的<code>delete</code>，或者更好地使用智能指针自动管理内存。</li>
<li><strong>避免悬空指针</strong>：在释放内存后，及时将指针置为<code>nullptr</code>。</li>
<li><strong>使用RAII</strong>：通过资源获取即初始化的原则，确保资源在对象生命周期内被正确管理。</li>
<li><strong>尽量使用智能指针</strong>：减少手动管理内存的复杂性，提高代码安全性。</li>
</ul>
<hr>
<h2 id="9-函数重载与运算符重载"><a href="#9-函数重载与运算符重载" class="headerlink" title="9. 函数重载与运算符重载"></a>9. 函数重载与运算符重载</h2><p>通过函数重载和运算符重载，可以提升代码的可读性和灵活性，使类和函数更加直观和易用。</p>
<h3 id="9-1-函数重载（Function-Overloading）"><a href="#9-1-函数重载（Function-Overloading）" class="headerlink" title="9.1 函数重载（Function Overloading）"></a>9.1 函数重载（Function Overloading）</h3><p>函数重载允许在同一作用域内定义多个同名函数，只要它们的参数列表不同（参数数量或类型）。</p>
<h4 id="9-1-1-示例"><a href="#9-1-1-示例" class="headerlink" title="9.1.1 示例"></a>9.1.1 示例</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数重载示例</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;整数: &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">double</span> d)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;双精度浮点数: &quot;</span> &lt;&lt; d &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> std::string&amp; s)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;字符串: &quot;</span> &lt;&lt; s &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">3.14</span>);</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello, Overloading!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-2-运算符重载（Operator-Overloading）"><a href="#9-2-运算符重载（Operator-Overloading）" class="headerlink" title="9.2 运算符重载（Operator Overloading）"></a>9.2 运算符重载（Operator Overloading）</h3><p>运算符重载允许自定义类型的对象使用内置运算符，实现自定义的操作行为。运算符重载通过定义特殊的成员函数或友元函数来实现。</p>
<h4 id="9-2-1-重载基本运算符"><a href="#9-2-1-重载基本运算符" class="headerlink" title="9.2.1 重载基本运算符"></a>9.2.1 重载基本运算符</h4><p>以下是一个简单的<code>Complex</code>类，重载了加法运算符<code>+</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Complex</span>(<span class="type">double</span> real, <span class="type">double</span> imag) : <span class="built_in">real_</span>(real), <span class="built_in">imag_</span>(imag) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载加法运算符</span></span><br><span class="line">    Complex <span class="keyword">operator</span>+(<span class="type">const</span> Complex&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Complex</span>(real_ + other.real_, imag_ + other.imag_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; real_ &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; imag_ &lt;&lt; <span class="string">&quot;i&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> real_;</span><br><span class="line">    <span class="type">double</span> imag_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">1.2</span>, <span class="number">3.4</span>)</span></span>;</span><br><span class="line">    <span class="function">Complex <span class="title">c2</span><span class="params">(<span class="number">5.6</span>, <span class="number">7.8</span>)</span></span>;</span><br><span class="line">    Complex c3 = c1 + c2; <span class="comment">// 使用重载的+运算符</span></span><br><span class="line">    c3.<span class="built_in">display</span>(); <span class="comment">// 输出: 6.8 + 11.2i</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-2-2-重载流运算符"><a href="#9-2-2-重载流运算符" class="headerlink" title="9.2.2 重载流运算符"></a>9.2.2 重载流运算符</h4><p>常见的流运算符<code>&lt;&lt;</code>和<code>&gt;&gt;</code>可以被重载，以便自定义类型可以直接用于输入输出流。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">double</span> x, <span class="type">double</span> y) : <span class="built_in">x_</span>(x), <span class="built_in">y_</span>(y) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载输出运算符</span></span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> Point&amp; p);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载输入运算符</span></span><br><span class="line">    <span class="keyword">friend</span> std::istream&amp; <span class="keyword">operator</span>&gt;&gt;(std::istream&amp; is, Point&amp; p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> x_;</span><br><span class="line">    <span class="type">double</span> y_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出运算符重载</span></span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> Point&amp; p) &#123;</span><br><span class="line">    os &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; p.x_ &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; p.y_ &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入运算符重载</span></span><br><span class="line">std::istream&amp; <span class="keyword">operator</span>&gt;&gt;(std::istream&amp; is, Point&amp; p) &#123;</span><br><span class="line">    is &gt;&gt; p.x_ &gt;&gt; p.y_;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Point <span class="title">p1</span><span class="params">(<span class="number">2.5</span>, <span class="number">4.5</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;点p1: &quot;</span> &lt;&lt; p1 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="function">Point <span class="title">p2</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;输入点p2的坐标 (x y): &quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; p2;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;点p2: &quot;</span> &lt;&lt; p2 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="9-2-3-重载赋值运算符"><a href="#9-2-3-重载赋值运算符" class="headerlink" title="9.2.3 重载赋值运算符"></a>9.2.3 重载赋值运算符</h4><p>当类中包含动态分配的资源时，重载赋值运算符以实现深拷贝是必要的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>* str = <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str) &#123;</span><br><span class="line">            size_ = std::<span class="built_in">strlen</span>(str);</span><br><span class="line">            data_ = <span class="keyword">new</span> <span class="type">char</span>[size_ + <span class="number">1</span>];</span><br><span class="line">            std::<span class="built_in">strcpy</span>(data_, str);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            size_ = <span class="number">0</span>;</span><br><span class="line">            data_ = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">1</span>];</span><br><span class="line">            data_[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> String&amp; other) : <span class="built_in">size_</span>(other.size_), <span class="built_in">data_</span>(<span class="keyword">new</span> <span class="type">char</span>[other.size_ + <span class="number">1</span>]) &#123;</span><br><span class="line">        std::<span class="built_in">strcpy</span>(data_, other.data_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值运算符重载</span></span><br><span class="line">    String&amp; <span class="keyword">operator</span>=(<span class="type">const</span> String&amp; other) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other) &#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// 自我赋值检查</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span>[] data_; <span class="comment">// 释放现有资源</span></span><br><span class="line"></span><br><span class="line">        size_ = other.size_;</span><br><span class="line">        data_ = <span class="keyword">new</span> <span class="type">char</span>[size_ + <span class="number">1</span>];</span><br><span class="line">        std::<span class="built_in">strcpy</span>(data_, other.data_);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">String</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] data_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; data_ &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">size_t</span> size_;</span><br><span class="line">    <span class="type">char</span>* data_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">s1</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span></span>;</span><br><span class="line">    String s2 = s1; <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">    String s3;</span><br><span class="line">    s3 = s1;        <span class="comment">// 调用赋值运算符</span></span><br><span class="line">    s1.<span class="built_in">display</span>();</span><br><span class="line">    s2.<span class="built_in">display</span>();</span><br><span class="line">    s3.<span class="built_in">display</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-3-重载运算符的注意事项"><a href="#9-3-重载运算符的注意事项" class="headerlink" title="9.3 重载运算符的注意事项"></a>9.3 重载运算符的注意事项</h3><ul>
<li><strong>保持运算符的语义一致</strong>：重载运算符应符合其自然语义，避免混淆。</li>
<li><strong>避免过度重载</strong>：只在必要时重载运算符，过度重载可能导致代码难以理解。</li>
<li><strong>确保操作符的对称性</strong>：对于二元运算符，确保其操作是对称的（如<code>a + b</code>与<code>b + a</code>）。</li>
</ul>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章详细介绍了Qt C++语言编程基础的多个重要知识点，包括Visual Studio 2022的安装、C++语言基础、指针与引用、类与对象及其高级特性、构造函数与析构函数、友元与动态内存管理，以及函数重载与运算符重载。这些基础知识是掌握Qt开发的前提，建议读者在实践中多加练习，以加深理解和应用。</p>
<p>在下一篇文章中，我们将继续深入探讨Qt C++语言进阶知识，帮助您更好地掌握Qt开发的技能。</p>
<hr>
]]></content>
  </entry>
  <entry>
    <title>Qt C++语言进阶详解</title>
    <url>/2024/12/26/Qt-C-%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><span id="more"></span>

<h1 id="Qt-C-语言进阶详解"><a href="#Qt-C-语言进阶详解" class="headerlink" title="Qt C++语言进阶详解"></a>Qt C++语言进阶详解</h1><p>在掌握了Qt C++语言编程的基础知识后，进一步深入C++的高级特性是提升编程能力的关键。本篇文章将详细介绍Qt C++语言编程进阶的多个重要知识点，包括单继承、多继承、虚继承及其他特性、虚函数与抽象类、命名空间与模板等。这些内容不仅能够帮助您更好地理解C++的面向对象编程（OOP）理念，还能为后续学习Qt框架打下坚实的基础。</p>
<hr>
<h2 id="1-单继承（Single-Inheritance）"><a href="#1-单继承（Single-Inheritance）" class="headerlink" title="1. 单继承（Single Inheritance）"></a>1. 单继承（Single Inheritance）</h2><h3 id="1-1-单继承的概念"><a href="#1-1-单继承的概念" class="headerlink" title="1.1 单继承的概念"></a>1.1 单继承的概念</h3><p>单继承是指一个派生类仅继承自一个基类。这是C++中最基本的继承形式，通过单继承，可以实现代码的复用和类层次结构的构建。</p>
<h3 id="1-2-单继承的实现方式"><a href="#1-2-单继承的实现方式" class="headerlink" title="1.2 单继承的实现方式"></a>1.2 单继承的实现方式</h3><p>在C++中，单继承通过在类定义中使用冒号（<code>:</code>）和继承访问控制符（<code>public</code>、<code>protected</code>或<code>private</code>）来实现。常用的继承方式是公共继承（<code>public</code>），它确保基类的<code>public</code>和<code>protected</code>成员在派生类中保持其访问权限。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Animal</span>(<span class="type">const</span> std::string&amp; name) : <span class="built_in">name_</span>(name) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; name_ &lt;&lt; <span class="string">&quot; is eating.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::string name_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Dog</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> std::string&amp; breed)</span><br><span class="line">        : <span class="built_in">Animal</span>(name), <span class="built_in">breed_</span>(breed) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bark</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; name_ &lt;&lt; <span class="string">&quot; the &quot;</span> &lt;&lt; breed_ &lt;&lt; <span class="string">&quot; is barking.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string breed_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Dog <span class="title">myDog</span><span class="params">(<span class="string">&quot;Buddy&quot;</span>, <span class="string">&quot;Golden Retriever&quot;</span>)</span></span>;</span><br><span class="line">    myDog.<span class="built_in">eat</span>();  <span class="comment">// 调用基类的成员函数</span></span><br><span class="line">    myDog.<span class="built_in">bark</span>(); <span class="comment">// 调用派生类的成员函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Buddy is eating.</span><br><span class="line">Buddy the Golden Retriever is barking.</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>Animal</code>类是基类，包含一个公有成员函数<code>eat</code>和一个受保护的成员变量<code>name_</code>。</li>
<li><code>Dog</code>类是派生类，使用<code>public</code>继承自<code>Animal</code>，并添加了一个新的成员函数<code>bark</code>和一个私有成员变量<code>breed_</code>。</li>
<li>在<code>main</code>函数中，通过<code>Dog</code>类的实例<code>myDog</code>可以调用基类<code>Animal</code>的<code>eat</code>函数以及派生类<code>Dog</code>的<code>bark</code>函数，实现了代码的复用和功能的扩展。</li>
</ul>
<h3 id="1-3-单继承的应用场景"><a href="#1-3-单继承的应用场景" class="headerlink" title="1.3 单继承的应用场景"></a>1.3 单继承的应用场景</h3><p>单继承适用于简单的类层次结构，当一个类只需要继承自另一个类时，单继承能够有效地组织代码，提升可读性和维护性。例如：</p>
<ul>
<li><strong>动物分类</strong>：<code>Animal</code>（基类）→ <code>Dog</code>、<code>Cat</code>（派生类）</li>
<li><strong>图形形状</strong>：<code>Shape</code>（基类）→ <code>Circle</code>、<code>Rectangle</code>（派生类）</li>
</ul>
<p>单继承能够清晰地表达类之间的“是一个”关系，符合面向对象设计的基本原则。</p>
<hr>
<h2 id="2-多继承（Multiple-Inheritance）"><a href="#2-多继承（Multiple-Inheritance）" class="headerlink" title="2. 多继承（Multiple Inheritance）"></a>2. 多继承（Multiple Inheritance）</h2><h3 id="2-1-多继承的概念"><a href="#2-1-多继承的概念" class="headerlink" title="2.1 多继承的概念"></a>2.1 多继承的概念</h3><p>多继承是指一个派生类同时继承自多个基类。这使得派生类能够组合多个基类的功能，实现更为复杂和灵活的类层次结构。然而，多继承也带来了一些潜在的问题，如菱形继承导致的二义性。</p>
<h3 id="2-2-多继承的实现方式"><a href="#2-2-多继承的实现方式" class="headerlink" title="2.2 多继承的实现方式"></a>2.2 多继承的实现方式</h3><p>在C++中，多继承通过在类定义中列出多个基类，并用逗号分隔它们来实现。每个基类可以有不同的继承访问控制符。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Flyer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fly</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Flying in the sky.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Swimmer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swim</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Swimming in the water.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类，多继承自Flyer和Swimmer</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Duck</span> : <span class="keyword">public</span> Flyer, <span class="keyword">public</span> Swimmer &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">quack</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Quack quack!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Duck daffy;</span><br><span class="line">    daffy.<span class="built_in">fly</span>();    <span class="comment">// 调用Flyer的成员函数</span></span><br><span class="line">    daffy.<span class="built_in">swim</span>();   <span class="comment">// 调用Swimmer的成员函数</span></span><br><span class="line">    daffy.<span class="built_in">quack</span>();  <span class="comment">// 调用Duck的成员函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Flying in the sky.</span><br><span class="line">Swimming in the water.</span><br><span class="line">Quack quack!</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>Flyer</code>和<code>Swimmer</code>是两个独立的基类，分别提供<code>fly</code>和<code>swim</code>功能。</li>
<li><code>Duck</code>类通过<code>public</code>多继承自<code>Flyer</code>和<code>Swimmer</code>，因此<code>Duck</code>类的对象可以同时调用两个基类的成员函数。</li>
<li>这种方式实现了功能的组合，使得<code>Duck</code>类具备飞行和游泳的能力。</li>
</ul>
<h3 id="2-3-多继承的优点"><a href="#2-3-多继承的优点" class="headerlink" title="2.3 多继承的优点"></a>2.3 多继承的优点</h3><ul>
<li><strong>功能组合</strong>：通过多继承，派生类可以组合多个基类的功能，避免重复代码。</li>
<li><strong>灵活性</strong>：多继承提供了更高的灵活性，允许类以多种方式组合和扩展功能。</li>
<li><strong>模型表达力增强</strong>：能够更准确地表达现实世界中事物的多重特性。</li>
</ul>
<h3 id="2-4-多继承的潜在问题"><a href="#2-4-多继承的潜在问题" class="headerlink" title="2.4 多继承的潜在问题"></a>2.4 多继承的潜在问题</h3><p>尽管多继承带来了功能的强大组合，但也引入了一些复杂性和潜在问题，主要包括：</p>
<h4 id="2-4-1-菱形继承（Diamond-Inheritance）"><a href="#2-4-1-菱形继承（Diamond-Inheritance）" class="headerlink" title="2.4.1 菱形继承（Diamond Inheritance）"></a>2.4.1 菱形继承（Diamond Inheritance）</h4><p>菱形继承是多继承中最常见的问题之一，指的是一个派生类通过多个路径继承自同一个基类，导致基类的成员出现二义性。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Animal is eating.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mammal</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类，多继承自Mammal和Bird</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bat</span> : <span class="keyword">public</span> Mammal, <span class="keyword">public</span> Bird &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fly</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Bat is flying.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Bat bat;</span><br><span class="line">    <span class="comment">// bat.eat(); // 编译错误，二义性</span></span><br><span class="line">    bat.Mammal::<span class="built_in">eat</span>(); <span class="comment">// 指定调用Mammal路径的eat</span></span><br><span class="line">    bat.Bird::<span class="built_in">eat</span>();    <span class="comment">// 指定调用Bird路径的eat</span></span><br><span class="line">    bat.<span class="built_in">fly</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Animal is eating.</span><br><span class="line">Animal is eating.</span><br><span class="line">Bat is flying.</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>Bat</code>类通过<code>Mammal</code>和<code>Bird</code>两个路径继承自<code>Animal</code>类，导致<code>Bat</code>类中存在两个<code>Animal</code>类的子对象。</li>
<li>当尝试调用<code>bat.eat()</code>时，编译器无法确定调用哪个<code>Animal::eat()</code>版本，导致二义性错误。</li>
<li>需要明确指定调用哪个基类路径的成员函数，如<code>bat.Mammal::eat()</code>或<code>bat.Bird::eat()</code>。</li>
</ul>
<h4 id="2-4-2-二义性问题"><a href="#2-4-2-二义性问题" class="headerlink" title="2.4.2 二义性问题"></a>2.4.2 二义性问题</h4><p>除了菱形继承，其他多继承场景中也可能出现二义性问题，如不同基类中存在同名成员函数或变量时，派生类需要明确指定访问哪个基类的成员。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base1 show()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base2 show()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类，多继承自Base1和Base2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// show(); // 编译错误，二义性</span></span><br><span class="line">        Base1::<span class="built_in">show</span>(); <span class="comment">// 指定调用Base1的show</span></span><br><span class="line">        Base2::<span class="built_in">show</span>(); <span class="comment">// 指定调用Base2的show</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derived obj;</span><br><span class="line">    obj.<span class="built_in">display</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Base1 show()</span><br><span class="line">Base2 show()</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>Derived</code>类继承自<code>Base1</code>和<code>Base2</code>，两者都定义了<code>show</code>成员函数。</li>
<li>调用<code>show()</code>时，编译器无法确定应调用哪个基类的<code>show</code>函数，导致二义性错误。</li>
<li>需要明确指定调用哪个基类的<code>show</code>函数，如<code>Base1::show()</code>或<code>Base2::show()</code>。</li>
</ul>
<h3 id="2-5-多继承的最佳实践"><a href="#2-5-多继承的最佳实践" class="headerlink" title="2.5 多继承的最佳实践"></a>2.5 多继承的最佳实践</h3><p>为了避免多继承带来的复杂性和潜在问题，以下是一些最佳实践：</p>
<ol>
<li><strong>优先使用组合而非继承</strong>：在可能的情况下，优先选择组合（对象内部包含另一个对象）而非继承，以降低类之间的耦合度。</li>
<li><strong>明确类层次结构</strong>：设计清晰的类层次结构，避免不必要的多继承，特别是菱形继承。</li>
<li><strong>使用虚继承解决菱形继承</strong>：当必须使用多继承且存在菱形继承时，采用虚继承来共享基类的单一实例，避免二义性。</li>
<li><strong>避免同名成员</strong>：尽量避免不同基类中存在同名成员函数或变量，减少二义性问题。</li>
<li><strong>合理使用访问控制符</strong>：合理选择继承的访问控制符（<code>public</code>、<code>protected</code>、<code>private</code>），控制基类成员在派生类中的可见性。</li>
</ol>
<hr>
<h2 id="3-虚继承及其他特性（Virtual-Inheritance-and-Other-Features）"><a href="#3-虚继承及其他特性（Virtual-Inheritance-and-Other-Features）" class="headerlink" title="3. 虚继承及其他特性（Virtual Inheritance and Other Features）"></a>3. 虚继承及其他特性（Virtual Inheritance and Other Features）</h2><h3 id="3-1-虚继承的概念"><a href="#3-1-虚继承的概念" class="headerlink" title="3.1 虚继承的概念"></a>3.1 虚继承的概念</h3><p>虚继承是一种C++中的继承机制，用于解决多继承中菱形继承带来的二义性问题。通过虚继承，派生类共享同一个基类的实例，避免了多个基类子对象的出现。</p>
<h3 id="3-2-虚继承的实现方式"><a href="#3-2-虚继承的实现方式" class="headerlink" title="3.2 虚继承的实现方式"></a>3.2 虚继承的实现方式</h3><p>在C++中，使用<code>virtual</code>关键字在继承时指定虚继承。具体来说，在派生类继承基类时，使用<code>virtual</code>关键字修饰基类名。</p>
<p><strong>示例：解决菱形继承的二义性问题</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Animal</span>(<span class="type">const</span> std::string&amp; name) : <span class="built_in">name_</span>(name) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; name_ &lt;&lt; <span class="string">&quot; is eating.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::string name_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 虚继承基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mammal</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Mammal</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> std::string&amp; furColor)</span><br><span class="line">        : <span class="built_in">Animal</span>(name), <span class="built_in">furColor_</span>(furColor) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showFur</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; name_ &lt;&lt; <span class="string">&quot; has &quot;</span> &lt;&lt; furColor_ &lt;&lt; <span class="string">&quot; fur.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string furColor_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 虚继承基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Bird</span>(<span class="type">const</span> std::string&amp; name, <span class="type">double</span> wingSpan)</span><br><span class="line">        : <span class="built_in">Animal</span>(name), <span class="built_in">wingSpan_</span>(wingSpan) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showWings</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; name_ &lt;&lt; <span class="string">&quot; has a wingspan of &quot;</span> &lt;&lt; wingSpan_ &lt;&lt; <span class="string">&quot; meters.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> wingSpan_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类，多继承自Mammal和Bird</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bat</span> : <span class="keyword">public</span> Mammal, <span class="keyword">public</span> Bird &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Bat</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> std::string&amp; furColor, <span class="type">double</span> wingSpan, <span class="type">bool</span> echolocation)</span><br><span class="line">        : <span class="built_in">Animal</span>(name), <span class="built_in">Mammal</span>(name, furColor), <span class="built_in">Bird</span>(name, wingSpan), <span class="built_in">echolocation_</span>(echolocation) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">eat</span>();           <span class="comment">// 唯一的Animal::eat()</span></span><br><span class="line">        <span class="built_in">showFur</span>();</span><br><span class="line">        <span class="built_in">showWings</span>();</span><br><span class="line">        std::cout &lt;&lt; name_ &lt;&lt; <span class="string">&quot; uses &quot;</span> &lt;&lt; (echolocation_ ? <span class="string">&quot;echolocation.&quot;</span> : <span class="string">&quot;other navigation methods.&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">bool</span> echolocation_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Bat <span class="title">bat</span><span class="params">(<span class="string">&quot;Bruce&quot;</span>, <span class="string">&quot;brown&quot;</span>, <span class="number">1.5</span>, <span class="literal">true</span>)</span></span>;</span><br><span class="line">    bat.<span class="built_in">display</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Bruce is eating.</span><br><span class="line">Bruce has brown fur.</span><br><span class="line">Bruce has a wingspan of 1.5 meters.</span><br><span class="line">Bruce uses echolocation.</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>Mammal</code>和<code>Bird</code>类通过<code>virtual</code>关键字虚继承自<code>Animal</code>类，确保<code>Bat</code>类中只有一个<code>Animal</code>基类子对象。</li>
<li>在<code>Bat</code>类的构造函数中，必须显式调用<code>Animal</code>类的构造函数，以初始化共享的<code>Animal</code>子对象。</li>
<li>通过虚继承，<code>Bat</code>类能够避免菱形继承带来的二义性问题，<code>eat</code>函数调用变得明确且无歧义。</li>
</ul>
<h3 id="3-3-其他高级继承特性"><a href="#3-3-其他高级继承特性" class="headerlink" title="3.3 其他高级继承特性"></a>3.3 其他高级继承特性</h3><p>除了虚继承，C++还提供了其他一些高级继承特性，以增强类层次结构的表达能力和灵活性。</p>
<h4 id="3-3-1-多级继承（Multilevel-Inheritance）"><a href="#3-3-1-多级继承（Multilevel-Inheritance）" class="headerlink" title="3.3.1 多级继承（Multilevel Inheritance）"></a>3.3.1 多级继承（Multilevel Inheritance）</h4><p>多级继承是指一个派生类继承自另一个派生类，形成一个继承链。它有助于构建更为复杂和有层次的类结构。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Vehicle</span>(<span class="type">const</span> std::string&amp; brand) : <span class="built_in">brand_</span>(brand) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">honk</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; brand_ &lt;&lt; <span class="string">&quot; vehicle is honking.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::string brand_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> : <span class="keyword">public</span> Vehicle &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Car</span>(<span class="type">const</span> std::string&amp; brand, <span class="type">int</span> doors)</span><br><span class="line">        : <span class="built_in">Vehicle</span>(brand), <span class="built_in">doors_</span>(doors) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">displayDoors</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; brand_ &lt;&lt; <span class="string">&quot; car has &quot;</span> &lt;&lt; doors_ &lt;&lt; <span class="string">&quot; doors.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> doors_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类2，多级继承自Car</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ElectricCar</span> : <span class="keyword">public</span> Car &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ElectricCar</span>(<span class="type">const</span> std::string&amp; brand, <span class="type">int</span> doors, <span class="type">double</span> batteryCapacity)</span><br><span class="line">        : <span class="built_in">Car</span>(brand, doors), <span class="built_in">batteryCapacity_</span>(batteryCapacity) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">displayBattery</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; brand_ &lt;&lt; <span class="string">&quot; electric car has a battery capacity of &quot;</span> &lt;&lt; batteryCapacity_ &lt;&lt; <span class="string">&quot; kWh.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> batteryCapacity_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ElectricCar <span class="title">tesla</span><span class="params">(<span class="string">&quot;Tesla&quot;</span>, <span class="number">4</span>, <span class="number">75.0</span>)</span></span>;</span><br><span class="line">    tesla.<span class="built_in">honk</span>();</span><br><span class="line">    tesla.<span class="built_in">displayDoors</span>();</span><br><span class="line">    tesla.<span class="built_in">displayBattery</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tesla vehicle is honking.</span><br><span class="line">Tesla car has 4 doors.</span><br><span class="line">Tesla electric car has a battery capacity of 75 kWh.</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>ElectricCar</code>类通过多级继承从<code>Car</code>继承，<code>Car</code>又从<code>Vehicle</code>继承。</li>
<li>这种继承方式形成了一个清晰的层次结构，<code>ElectricCar</code>不仅拥有<code>Car</code>的属性和行为，还继承了<code>Vehicle</code>的功能。</li>
</ul>
<h4 id="3-3-2-虚继承与多级继承的结合"><a href="#3-3-2-虚继承与多级继承的结合" class="headerlink" title="3.3.2 虚继承与多级继承的结合"></a>3.3.2 虚继承与多级继承的结合</h4><p>在多级继承中，如果存在菱形继承关系，同样需要使用虚继承来避免二义性问题。通过合理设计继承关系，可以构建稳定且高效的类层次结构。</p>
<hr>
<h2 id="4-虚函数与抽象类（Virtual-Functions-and-Abstract-Classes）"><a href="#4-虚函数与抽象类（Virtual-Functions-and-Abstract-Classes）" class="headerlink" title="4. 虚函数与抽象类（Virtual Functions and Abstract Classes）"></a>4. 虚函数与抽象类（Virtual Functions and Abstract Classes）</h2><h3 id="4-1-虚函数的概念"><a href="#4-1-虚函数的概念" class="headerlink" title="4.1 虚函数的概念"></a>4.1 虚函数的概念</h3><p>虚函数是基类中声明为<code>virtual</code>的成员函数，允许派生类对其进行重写（Override）。通过虚函数，可以实现多态性，使得基类指针或引用能够调用派生类的重写函数。</p>
<h3 id="4-2-虚函数的实现与使用"><a href="#4-2-虚函数的实现与使用" class="headerlink" title="4.2 虚函数的实现与使用"></a>4.2 虚函数的实现与使用</h3><p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Shape</span>(<span class="type">const</span> std::string&amp; name) : <span class="built_in">name_</span>(name) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a generic shape.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Shape</span>() = <span class="keyword">default</span>; <span class="comment">// 虚析构函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::string name_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Circle</span>(<span class="type">double</span> radius) : <span class="built_in">Shape</span>(<span class="string">&quot;Circle&quot;</span>), <span class="built_in">radius_</span>(radius) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a circle with radius &quot;</span> &lt;&lt; radius_ &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> radius_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rectangle</span>(<span class="type">double</span> width, <span class="type">double</span> height)</span><br><span class="line">        : <span class="built_in">Shape</span>(<span class="string">&quot;Rectangle&quot;</span>), <span class="built_in">width_</span>(width), <span class="built_in">height_</span>(height) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a rectangle with width &quot;</span> &lt;&lt; width_</span><br><span class="line">                  &lt;&lt; <span class="string">&quot; and height &quot;</span> &lt;&lt; height_ &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> width_;</span><br><span class="line">    <span class="type">double</span> height_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Shape* shape1 = <span class="keyword">new</span> <span class="built_in">Circle</span>(<span class="number">5.0</span>);</span><br><span class="line">    Shape* shape2 = <span class="keyword">new</span> <span class="built_in">Rectangle</span>(<span class="number">4.0</span>, <span class="number">6.0</span>);</span><br><span class="line"></span><br><span class="line">    shape1-&gt;<span class="built_in">draw</span>(); <span class="comment">// 调用Circle的draw</span></span><br><span class="line">    shape2-&gt;<span class="built_in">draw</span>(); <span class="comment">// 调用Rectangle的draw</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> shape1;</span><br><span class="line">    <span class="keyword">delete</span> shape2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Drawing a circle with radius 5.</span><br><span class="line">Drawing a rectangle with width 4 and height 6.</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>Shape</code>类中声明了一个虚函数<code>draw</code>，并在派生类<code>Circle</code>和<code>Rectangle</code>中进行了重写。</li>
<li>在<code>main</code>函数中，通过基类指针<code>shape1</code>和<code>shape2</code>指向派生类对象，调用<code>draw</code>函数时，实际执行的是派生类中重写的版本，实现了运行时多态性。</li>
<li>虚析构函数确保在删除基类指针指向的派生类对象时，正确调用派生类的析构函数，防止资源泄漏。</li>
</ul>
<h3 id="4-3-抽象类的定义与用途"><a href="#4-3-抽象类的定义与用途" class="headerlink" title="4.3 抽象类的定义与用途"></a>4.3 抽象类的定义与用途</h3><p>抽象类是包含至少一个纯虚函数（Pure Virtual Function）的类，不能被实例化，只能作为基类使用。抽象类定义了接口规范，派生类必须实现这些纯虚函数，才能被实例化。</p>
<h4 id="4-3-1-纯虚函数的声明"><a href="#4-3-1-纯虚函数的声明" class="headerlink" title="4.3.1 纯虚函数的声明"></a>4.3.1 纯虚函数的声明</h4><p>纯虚函数通过在函数声明后加上<code>= 0</code>来表示。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractShape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AbstractShape</span>(<span class="type">const</span> std::string&amp; name) : <span class="built_in">name_</span>(name) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 纯虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">AbstractShape</span>() = <span class="keyword">default</span>; <span class="comment">// 虚析构函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::string name_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Triangle</span> : <span class="keyword">public</span> AbstractShape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Triangle</span>(<span class="type">double</span> base, <span class="type">double</span> height)</span><br><span class="line">        : <span class="built_in">AbstractShape</span>(<span class="string">&quot;Triangle&quot;</span>), <span class="built_in">base_</span>(base), <span class="built_in">height_</span>(height) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a triangle with base &quot;</span> &lt;&lt; base_</span><br><span class="line">                  &lt;&lt; <span class="string">&quot; and height &quot;</span> &lt;&lt; height_ &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> base_;</span><br><span class="line">    <span class="type">double</span> height_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span> : <span class="keyword">public</span> AbstractShape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Square</span>(<span class="type">double</span> side) : <span class="built_in">AbstractShape</span>(<span class="string">&quot;Square&quot;</span>), <span class="built_in">side_</span>(side) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a square with side &quot;</span> &lt;&lt; side_ &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> side_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// AbstractShape shape; // 错误，无法实例化抽象类</span></span><br><span class="line"></span><br><span class="line">    AbstractShape* shape1 = <span class="keyword">new</span> <span class="built_in">Triangle</span>(<span class="number">3.0</span>, <span class="number">4.0</span>);</span><br><span class="line">    AbstractShape* shape2 = <span class="keyword">new</span> <span class="built_in">Square</span>(<span class="number">5.0</span>);</span><br><span class="line"></span><br><span class="line">    shape1-&gt;<span class="built_in">draw</span>(); <span class="comment">// 调用Triangle的draw</span></span><br><span class="line">    shape2-&gt;<span class="built_in">draw</span>(); <span class="comment">// 调用Square的draw</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> shape1;</span><br><span class="line">    <span class="keyword">delete</span> shape2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Drawing a triangle with base 3 and height 4.</span><br><span class="line">Drawing a square with side 5.</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>AbstractShape</code>类包含一个纯虚函数<code>draw</code>，因此成为抽象类，不能被实例化。</li>
<li><code>Triangle</code>和<code>Square</code>类继承自<code>AbstractShape</code>并实现了纯虚函数<code>draw</code>，使得它们成为具体类，可以被实例化。</li>
<li>通过基类指针调用<code>draw</code>函数时，实际执行的是派生类中重写的版本，实现了多态性。</li>
</ul>
<h3 id="4-4-多态性的实现与应用"><a href="#4-4-多态性的实现与应用" class="headerlink" title="4.4 多态性的实现与应用"></a>4.4 多态性的实现与应用</h3><p>多态性是面向对象编程的核心特性之一，通过基类指针或引用调用派生类的重写函数，实现不同对象的不同行为。多态性增强了代码的灵活性和可扩展性，特别适用于需要处理不同类型对象的场景。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Animal</span>(<span class="type">const</span> std::string&amp; name) : <span class="built_in">name_</span>(name) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>; <span class="comment">// 纯虚函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Animal</span>() = <span class="keyword">default</span>; <span class="comment">// 虚析构函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::string name_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Dog</span>(<span class="type">const</span> std::string&amp; name) : <span class="built_in">Animal</span>(name) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; name_ &lt;&lt; <span class="string">&quot; says: Woof!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Cat</span>(<span class="type">const</span> std::string&amp; name) : <span class="built_in">Animal</span>(name) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; name_ &lt;&lt; <span class="string">&quot; says: Meow!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类3</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Bird</span>(<span class="type">const</span> std::string&amp; name) : <span class="built_in">Animal</span>(name) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; name_ &lt;&lt; <span class="string">&quot; says: Tweet!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;std::unique_ptr&lt;Animal&gt;&gt; animals;</span><br><span class="line">    animals.<span class="built_in">emplace_back</span>(std::<span class="built_in">make_unique</span>&lt;Dog&gt;(<span class="string">&quot;Buddy&quot;</span>));</span><br><span class="line">    animals.<span class="built_in">emplace_back</span>(std::<span class="built_in">make_unique</span>&lt;Cat&gt;(<span class="string">&quot;Whiskers&quot;</span>));</span><br><span class="line">    animals.<span class="built_in">emplace_back</span>(std::<span class="built_in">make_unique</span>&lt;Bird&gt;(<span class="string">&quot;Tweety&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; animal : animals) &#123;</span><br><span class="line">        animal-&gt;<span class="built_in">speak</span>(); <span class="comment">// 调用各自的speak函数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Buddy says: Woof!</span><br><span class="line">Whiskers says: Meow!</span><br><span class="line">Tweety says: Tweet!</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>Animal</code>是一个抽象基类，定义了纯虚函数<code>speak</code>。</li>
<li><code>Dog</code>、<code>Cat</code>和<code>Bird</code>类继承自<code>Animal</code>并实现了<code>speak</code>函数。</li>
<li>在<code>main</code>函数中，通过<code>std::unique_ptr&lt;Animal&gt;</code>存储不同类型的动物对象，并通过基类指针调用<code>speak</code>函数，实际执行的是各自派生类中的实现，实现了多态性。</li>
<li>使用智能指针（<code>std::unique_ptr</code>）自动管理对象的生命周期，避免手动管理内存。</li>
</ul>
<h3 id="4-5-抽象类的应用场景"><a href="#4-5-抽象类的应用场景" class="headerlink" title="4.5 抽象类的应用场景"></a>4.5 抽象类的应用场景</h3><p>抽象类主要用于定义接口规范，强制派生类实现特定的功能。常见的应用场景包括：</p>
<ul>
<li><strong>接口定义</strong>：定义一组相关的操作，确保所有派生类实现这些操作。</li>
<li><strong>框架设计</strong>：在软件框架中，抽象类作为基类，定义框架所需的基本功能，派生类实现具体的业务逻辑。</li>
<li><strong>多态性实现</strong>：通过抽象类实现多态性，处理不同类型的对象时无需了解具体类型，只需依赖基类接口。</li>
</ul>
<p><strong>示例：图形绘制框架</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Drawable</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>; <span class="comment">// 纯虚函数</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Drawable</span>() = <span class="keyword">default</span>;  <span class="comment">// 虚析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Line</span> : <span class="keyword">public</span> Drawable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a line.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Drawable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a circle.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类3</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">public</span> Drawable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a rectangle.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘图工具</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DrawingTool</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addShape</span><span class="params">(std::unique_ptr&lt;Drawable&gt; shape)</span> </span>&#123;</span><br><span class="line">        shapes_.<span class="built_in">emplace_back</span>(std::<span class="built_in">move</span>(shape));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">render</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; shape : shapes_) &#123;</span><br><span class="line">            shape-&gt;<span class="built_in">draw</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;std::unique_ptr&lt;Drawable&gt;&gt; shapes_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DrawingTool tool;</span><br><span class="line">    tool.<span class="built_in">addShape</span>(std::<span class="built_in">make_unique</span>&lt;Line&gt;());</span><br><span class="line">    tool.<span class="built_in">addShape</span>(std::<span class="built_in">make_unique</span>&lt;Circle&gt;());</span><br><span class="line">    tool.<span class="built_in">addShape</span>(std::<span class="built_in">make_unique</span>&lt;Rectangle&gt;());</span><br><span class="line"></span><br><span class="line">    tool.<span class="built_in">render</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Drawing a line.</span><br><span class="line">Drawing a circle.</span><br><span class="line">Drawing a rectangle.</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>Drawable</code>是一个抽象基类，定义了纯虚函数<code>draw</code>。</li>
<li><code>Line</code>、<code>Circle</code>和<code>Rectangle</code>类继承自<code>Drawable</code>并实现了<code>draw</code>函数，具体绘制不同的图形。</li>
<li><code>DrawingTool</code>类通过存储<code>Drawable</code>类型的智能指针，管理和渲染各种图形对象，实现了绘图工具的多态性和扩展性。</li>
</ul>
<hr>
<h2 id="5-命名空间与模板（Namespaces-and-Templates）"><a href="#5-命名空间与模板（Namespaces-and-Templates）" class="headerlink" title="5. 命名空间与模板（Namespaces and Templates）"></a>5. 命名空间与模板（Namespaces and Templates）</h2><h3 id="5-1-命名空间（Namespaces）"><a href="#5-1-命名空间（Namespaces）" class="headerlink" title="5.1 命名空间（Namespaces）"></a>5.1 命名空间（Namespaces）</h3><h4 id="5-1-1-命名空间的概念"><a href="#5-1-1-命名空间的概念" class="headerlink" title="5.1.1 命名空间的概念"></a>5.1.1 命名空间的概念</h4><p>命名空间是C++中用于组织代码并避免命名冲突的机制。通过将相关的类、函数、变量等封装在一个命名空间中，可以确保不同模块之间的标识符不会相互干扰。</p>
<h4 id="5-1-2-命名空间的定义与使用"><a href="#5-1-2-命名空间的定义与使用" class="headerlink" title="5.1.2 命名空间的定义与使用"></a>5.1.2 命名空间的定义与使用</h4><p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义命名空间Math</span></span><br><span class="line"><span class="keyword">namespace</span> Math &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> PI = <span class="number">3.141592653589793</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">square</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义命名空间Utils</span></span><br><span class="line"><span class="keyword">namespace</span> Utils &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printMessage</span><span class="params">(<span class="type">const</span> std::string&amp; message)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Message: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> radius = <span class="number">5.0</span>;</span><br><span class="line">    <span class="type">double</span> area = Math::PI * Math::<span class="built_in">square</span>(radius);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Area of circle: &quot;</span> &lt;&lt; area &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    Utils::<span class="built_in">printMessage</span>(<span class="string">&quot;Hello, Namespaces!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Area of circle: 78.5398</span><br><span class="line">Message: Hello, Namespaces!</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><strong>命名空间的定义</strong>：通过<code>namespace Math &#123; ... &#125;</code>和<code>namespace Utils &#123; ... &#125;</code>定义了两个命名空间<code>Math</code>和<code>Utils</code>。</li>
<li><strong>命名空间成员的访问</strong>：使用<code>Math::PI</code>和<code>Math::square(radius)</code>访问<code>Math</code>命名空间中的成员，使用<code>Utils::printMessage</code>访问<code>Utils</code>命名空间中的函数。</li>
<li><strong>避免命名冲突</strong>：即使不同命名空间中存在相同名称的函数或变量，通过命名空间前缀可以明确区分它们。</li>
</ul>
<h4 id="5-1-3-使用using声明"><a href="#5-1-3-使用using声明" class="headerlink" title="5.1.3 使用using声明"></a>5.1.3 使用<code>using</code>声明</h4><p>为了简化命名空间成员的访问，可以使用<code>using</code>声明。然而，过度使用<code>using</code>可能会引入命名冲突，需谨慎使用。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Alpha &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">greet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Hello from Alpha!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Beta &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">greet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Hello from Beta!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> Alpha::greet; <span class="comment">// 引入Alpha命名空间的greet函数</span></span><br><span class="line">    <span class="built_in">greet</span>(); <span class="comment">// 调用Alpha::greet</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// greet(); // 仍然只能调用Alpha::greet，Beta::greet不会被引入</span></span><br><span class="line"></span><br><span class="line">    Beta::<span class="built_in">greet</span>(); <span class="comment">// 通过命名空间前缀调用Beta::greet</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hello from Alpha!</span><br><span class="line">Hello from Beta!</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>using Alpha::greet;</code>引入了<code>Alpha</code>命名空间的<code>greet</code>函数，使得可以直接调用<code>greet()</code>而不需要前缀。</li>
<li><code>Beta::greet();</code>仍然需要使用命名空间前缀来调用<code>Beta</code>命名空间的<code>greet</code>函数，避免了命名冲突。</li>
</ul>
<h3 id="5-2-模板（Templates）"><a href="#5-2-模板（Templates）" class="headerlink" title="5.2 模板（Templates）"></a>5.2 模板（Templates）</h3><h4 id="5-2-1-模板的概念"><a href="#5-2-1-模板的概念" class="headerlink" title="5.2.1 模板的概念"></a>5.2.1 模板的概念</h4><p>模板是C++中的一种泛型编程机制，允许编写与类型无关的代码。通过模板，可以实现函数和类的泛型化，提高代码的复用性和灵活性。</p>
<h4 id="5-2-2-函数模板"><a href="#5-2-2-函数模板" class="headerlink" title="5.2.2 函数模板"></a>5.2.2 函数模板</h4><p>函数模板使得同一函数可以处理不同类型的数据。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个函数模板，用于交换两个变量的值</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapValues</span><span class="params">(T&amp; a, T&amp; b)</span> </span>&#123;</span><br><span class="line">    T temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>, y = <span class="number">20</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Before swap: x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, y = &quot;</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">swapValues</span>(x, y);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After swap: x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, y = &quot;</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> m = <span class="number">1.5</span>, n = <span class="number">2.5</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Before swap: m = &quot;</span> &lt;&lt; m &lt;&lt; <span class="string">&quot;, n = &quot;</span> &lt;&lt; n &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">swapValues</span>(m, n);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After swap: m = &quot;</span> &lt;&lt; m &lt;&lt; <span class="string">&quot;, n = &quot;</span> &lt;&lt; n &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::string s1 = <span class="string">&quot;Hello&quot;</span>, s2 = <span class="string">&quot;World&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Before swap: s1 = &quot;</span> &lt;&lt; s1 &lt;&lt; <span class="string">&quot;, s2 = &quot;</span> &lt;&lt; s2 &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">swapValues</span>(s1, s2);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After swap: s1 = &quot;</span> &lt;&lt; s1 &lt;&lt; <span class="string">&quot;, s2 = &quot;</span> &lt;&lt; s2 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Before swap: x = 10, y = 20</span><br><span class="line">After swap: x = 20, y = 10</span><br><span class="line">Before swap: m = 1.5, n = 2.5</span><br><span class="line">After swap: m = 2.5, n = 1.5</span><br><span class="line">Before swap: s1 = Hello, s2 = World</span><br><span class="line">After swap: s1 = World, s2 = Hello</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>swapValues</code>是一个函数模板，使用<code>template &lt;typename T&gt;</code>定义。</li>
<li>可以将<code>swapValues</code>应用于不同类型的数据，如<code>int</code>、<code>double</code>、<code>std::string</code>，无需为每种类型编写单独的交换函数。</li>
</ul>
<h4 id="5-2-3-类模板"><a href="#5-2-3-类模板" class="headerlink" title="5.2.3 类模板"></a>5.2.3 类模板</h4><p>类模板允许定义与类型无关的类，适用于实现容器类和其他泛型类。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个类模板，用于存储一对值</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Pair</span>(T1 first, T2 second) : <span class="built_in">first_</span>(first), <span class="built_in">second_</span>(second) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">T1 <span class="title">getFirst</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> first_; &#125;</span><br><span class="line">    <span class="function">T2 <span class="title">getSecond</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> second_; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setFirst</span><span class="params">(T1 first)</span> </span>&#123; first_ = first; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setSecond</span><span class="params">(T2 second)</span> </span>&#123; second_ = second; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T1 first_;</span><br><span class="line">    T2 second_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用Pair模板存储int和double</span></span><br><span class="line">    <span class="function">Pair&lt;<span class="type">int</span>, <span class="type">double</span>&gt; <span class="title">p1</span><span class="params">(<span class="number">1</span>, <span class="number">3.14</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Pair1: (&quot;</span> &lt;&lt; p1.<span class="built_in">getFirst</span>() &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; p1.<span class="built_in">getSecond</span>() &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用Pair模板存储std::string和char</span></span><br><span class="line">    <span class="function">Pair&lt;std::string, <span class="type">char</span>&gt; <span class="title">p2</span><span class="params">(<span class="string">&quot;Hello&quot;</span>, <span class="string">&#x27;A&#x27;</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Pair2: (&quot;</span> &lt;&lt; p2.<span class="built_in">getFirst</span>() &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; p2.<span class="built_in">getSecond</span>() &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Pair1: (1, 3.14)</span><br><span class="line">Pair2: (Hello, A)</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>Pair</code>是一个类模板，使用<code>template &lt;typename T1, typename T2&gt;</code>定义。</li>
<li>可以创建不同类型的<code>Pair</code>对象，如<code>Pair&lt;int, double&gt;</code>和<code>Pair&lt;std::string, char&gt;</code>，实现了类型的灵活组合。</li>
</ul>
<h4 id="5-2-4-模板特化"><a href="#5-2-4-模板特化" class="headerlink" title="5.2.4 模板特化"></a>5.2.4 模板特化</h4><p>模板特化允许针对特定类型定制模板的行为。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通用模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Printer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> T&amp; data)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Data: &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板特化，针对std::string类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Printer</span>&lt;std::string&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> std::string&amp; data)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;String Data: \&quot;&quot;</span> &lt;&lt; data &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Printer&lt;<span class="type">int</span>&gt; intPrinter;</span><br><span class="line">    intPrinter.<span class="built_in">print</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    Printer&lt;<span class="type">double</span>&gt; doublePrinter;</span><br><span class="line">    doublePrinter.<span class="built_in">print</span>(<span class="number">3.14159</span>);</span><br><span class="line"></span><br><span class="line">    Printer&lt;std::string&gt; stringPrinter;</span><br><span class="line">    stringPrinter.<span class="built_in">print</span>(<span class="string">&quot;Hello, Templates!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Data: 100</span><br><span class="line">Data: 3.14159</span><br><span class="line">String Data: &quot;Hello, Templates!&quot;</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>通用模板<code>Printer&lt;T&gt;</code>定义了如何打印不同类型的数据。</li>
<li>针对<code>std::string</code>类型，进行了模板特化，定制了不同的打印格式。</li>
<li>当使用<code>Printer&lt;std::string&gt;</code>时，调用的是特化后的<code>Printer&lt;std::string&gt;</code>版本，而不是通用模板。</li>
</ul>
<h3 id="5-3-总结"><a href="#5-3-总结" class="headerlink" title="5.3 总结"></a>5.3 总结</h3><p>命名空间和模板是C++中非常重要的高级特性。命名空间帮助组织代码，避免命名冲突，而模板则支持泛型编程，提升代码的复用性和灵活性。通过合理使用命名空间和模板，可以编写出更清晰、更高效、更可维护的代码。</p>
<hr>
<h2 id="6-C-IO流类库（C-IO-Stream-Library）"><a href="#6-C-IO流类库（C-IO-Stream-Library）" class="headerlink" title="6. C++ IO流类库（C++ IO Stream Library）"></a>6. C++ IO流类库（C++ IO Stream Library）</h2><h3 id="6-1-IO流的基本概念"><a href="#6-1-IO流的基本概念" class="headerlink" title="6.1 IO流的基本概念"></a>6.1 IO流的基本概念</h3><p>C++标准库中的IO流（Input&#x2F;Output Streams）提供了用于处理输入和输出的机制。通过IO流，可以实现与控制台、文件、字符串等不同数据源和目标的交互。</p>
<h3 id="6-2-输入输出流对象"><a href="#6-2-输入输出流对象" class="headerlink" title="6.2 输入输出流对象"></a>6.2 输入输出流对象</h3><p>C++标准库主要提供以下IO流对象：</p>
<ul>
<li><code>std::cin</code>：标准输入流，通常与键盘关联。</li>
<li><code>std::cout</code>：标准输出流，通常与控制台关联。</li>
<li><code>std::cerr</code>：标准错误输出流，用于输出错误信息。</li>
<li><code>std::clog</code>：标准日志输出流，用于输出日志信息。</li>
</ul>
<h3 id="6-3-使用std-cin和std-cout"><a href="#6-3-使用std-cin和std-cout" class="headerlink" title="6.3 使用std::cin和std::cout"></a>6.3 使用<code>std::cin</code>和<code>std::cout</code></h3><p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;请输入您的姓名: &quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; name;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;请输入您的年龄: &quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; age;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;您好, &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;! 您今年 &quot;</span> &lt;&lt; age &lt;&lt; <span class="string">&quot; 岁。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">请输入您的姓名: 张三</span><br><span class="line">请输入您的年龄: 25</span><br><span class="line">您好, 张三! 您今年 25 岁。</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>std::cout</code>用于输出提示信息到控制台。</li>
<li><code>std::cin</code>用于从控制台读取用户输入的数据。</li>
<li>使用插入运算符<code>&lt;&lt;</code>和提取运算符<code>&gt;&gt;</code>实现数据的输出和输入。</li>
</ul>
<h3 id="6-4-文件输入输出（File-I-x2F-O）"><a href="#6-4-文件输入输出（File-I-x2F-O）" class="headerlink" title="6.4 文件输入输出（File I&#x2F;O）"></a>6.4 文件输入输出（File I&#x2F;O）</h3><p>C++标准库提供了<code>&lt;fstream&gt;</code>头文件中的<code>std::ifstream</code>和<code>std::ofstream</code>类，用于文件的读取和写入。</p>
<h4 id="6-4-1-写入文件"><a href="#6-4-1-写入文件" class="headerlink" title="6.4.1 写入文件"></a>6.4.1 写入文件</h4><p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::ofstream <span class="title">outFile</span><span class="params">(<span class="string">&quot;example.txt&quot;</span>)</span></span>; <span class="comment">// 打开文件用于写入</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!outFile) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;无法打开文件进行写入。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::string data = <span class="string">&quot;这是写入文件的第一行。\n这是写入文件的第二行。&quot;</span>;</span><br><span class="line">    outFile &lt;&lt; data;</span><br><span class="line"></span><br><span class="line">    outFile.<span class="built_in">close</span>(); <span class="comment">// 关闭文件</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;数据已成功写入文件。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数据已成功写入文件。</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>创建一个<code>std::ofstream</code>对象并指定文件名<code>example.txt</code>，以打开文件进行写入。</li>
<li>使用插入运算符<code>&lt;&lt;</code>将字符串写入文件。</li>
<li>关闭文件以释放资源。</li>
</ul>
<h4 id="6-4-2-读取文件"><a href="#6-4-2-读取文件" class="headerlink" title="6.4.2 读取文件"></a>6.4.2 读取文件</h4><p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::ifstream <span class="title">inFile</span><span class="params">(<span class="string">&quot;example.txt&quot;</span>)</span></span>; <span class="comment">// 打开文件用于读取</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!inFile) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;无法打开文件进行读取。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::string line;</span><br><span class="line">    <span class="keyword">while</span> (std::<span class="built_in">getline</span>(inFile, line)) &#123; <span class="comment">// 逐行读取文件</span></span><br><span class="line">        std::cout &lt;&lt; line &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    inFile.<span class="built_in">close</span>(); <span class="comment">// 关闭文件</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这是写入文件的第一行。</span><br><span class="line">这是写入文件的第二行。</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>创建一个<code>std::ifstream</code>对象并指定文件名<code>example.txt</code>，以打开文件进行读取。</li>
<li>使用<code>std::getline</code>逐行读取文件内容，并输出到控制台。</li>
<li>关闭文件以释放资源。</li>
</ul>
<h3 id="6-5-其他IO流功能"><a href="#6-5-其他IO流功能" class="headerlink" title="6.5 其他IO流功能"></a>6.5 其他IO流功能</h3><h4 id="6-5-1-格式化输出"><a href="#6-5-1-格式化输出" class="headerlink" title="6.5.1 格式化输出"></a>6.5.1 格式化输出</h4><p>C++ IO流支持多种格式化操作，如控制宽度、对齐方式、数值格式等。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> pi = <span class="number">3.141592653589793</span>;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;默认格式:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;pi = &quot;</span> &lt;&lt; pi &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n设置宽度和精度:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; std::fixed &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">4</span>) &lt;&lt; pi &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n科学计数法:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; std::scientific &lt;&lt; pi &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">默认格式:</span><br><span class="line">pi = 3.14159</span><br><span class="line">num = 42</span><br><span class="line"></span><br><span class="line">设置宽度和精度:</span><br><span class="line">    3.1416</span><br><span class="line">        42</span><br><span class="line"></span><br><span class="line">科学计数法:</span><br><span class="line">3.141593e+00</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>std::setw(10)</code>设置输出宽度为10个字符。</li>
<li><code>std::fixed</code>和<code>std::setprecision(4)</code>设置浮点数的固定小数点格式和精度为4位。</li>
<li><code>std::scientific</code>将浮点数以科学计数法格式输出。</li>
</ul>
<h3 id="6-6-总结"><a href="#6-6-总结" class="headerlink" title="6.6 总结"></a>6.6 总结</h3><p>C++的IO流类库提供了强大且灵活的输入输出功能，支持与控制台、文件和其他数据源的交互。通过掌握IO流的基本用法和格式化输出技巧，可以高效地处理各种输入输出需求，编写出功能丰富的应用程序。</p>
<hr>
<h2 id="7-标准模板库（STL）——vector、deque与stack"><a href="#7-标准模板库（STL）——vector、deque与stack" class="headerlink" title="7. 标准模板库（STL）——vector、deque与stack"></a>7. 标准模板库（STL）——<code>vector</code>、<code>deque</code>与<code>stack</code></h2><p>标准模板库（STL）是C++标准库的重要组成部分，提供了一系列通用的数据结构和算法。STL中的容器类（如<code>vector</code>、<code>deque</code>、<code>stack</code>）使得数据管理和操作更加便捷和高效。</p>
<h3 id="7-1-vector"><a href="#7-1-vector" class="headerlink" title="7.1 vector"></a>7.1 <code>vector</code></h3><h4 id="7-1-1-vector的概念"><a href="#7-1-1-vector的概念" class="headerlink" title="7.1.1 vector的概念"></a>7.1.1 <code>vector</code>的概念</h4><p><code>std::vector</code>是一个动态数组，支持随机访问、高效的元素插入和删除操作。<code>vector</code>能够根据需要自动调整大小，是最常用的STL容器之一。</p>
<h4 id="7-1-2-vector的基本用法"><a href="#7-1-2-vector的基本用法" class="headerlink" title="7.1.2 vector的基本用法"></a>7.1.2 <code>vector</code>的基本用法</h4><p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers; <span class="comment">// 创建一个空的vector</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加元素</span></span><br><span class="line">    numbers.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    numbers.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    numbers.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Vector elements: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; numbers.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; numbers[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用迭代器访问</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Using iterators: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = numbers.<span class="built_in">begin</span>(); it != numbers.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改元素</span></span><br><span class="line">    numbers[<span class="number">1</span>] = <span class="number">25</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After modification: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除最后一个元素</span></span><br><span class="line">    numbers.<span class="built_in">pop_back</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After pop_back: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Vector elements: 10 20 30 </span><br><span class="line">Using iterators: 10 20 30 </span><br><span class="line">After modification: 10 25 30 </span><br><span class="line">After pop_back: 10 25 </span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>使用<code>push_back</code>向<code>vector</code>中添加元素。</li>
<li>通过下标和迭代器访问和修改元素。</li>
<li>使用<code>pop_back</code>删除<code>vector</code>的最后一个元素。</li>
</ul>
<h4 id="7-1-3-vector的高级操作"><a href="#7-1-3-vector的高级操作" class="headerlink" title="7.1.3 vector的高级操作"></a>7.1.3 <code>vector</code>的高级操作</h4><p><strong>示例：插入和删除元素</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;std::string&gt; fruits = &#123;<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Cherry&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在第二个位置插入元素</span></span><br><span class="line">    fruits.<span class="built_in">insert</span>(fruits.<span class="built_in">begin</span>() + <span class="number">1</span>, <span class="string">&quot;Blueberry&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After insert: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; fruit : fruits) &#123;</span><br><span class="line">        std::cout &lt;&lt; fruit &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除第三个元素</span></span><br><span class="line">    fruits.<span class="built_in">erase</span>(fruits.<span class="built_in">begin</span>() + <span class="number">2</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After erase: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; fruit : fruits) &#123;</span><br><span class="line">        std::cout &lt;&lt; fruit &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空vector</span></span><br><span class="line">    fruits.<span class="built_in">clear</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After clear, size: &quot;</span> &lt;&lt; fruits.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">After insert: Apple Blueberry Banana Cherry </span><br><span class="line">After erase: Apple Blueberry Cherry </span><br><span class="line">After clear, size: 0</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>insert</code>用于在指定位置插入元素。</li>
<li><code>erase</code>用于删除指定位置的元素。</li>
<li><code>clear</code>用于移除<code>vector</code>中的所有元素。</li>
</ul>
<h3 id="7-2-deque"><a href="#7-2-deque" class="headerlink" title="7.2 deque"></a>7.2 <code>deque</code></h3><h4 id="7-2-1-deque的概念"><a href="#7-2-1-deque的概念" class="headerlink" title="7.2.1 deque的概念"></a>7.2.1 <code>deque</code>的概念</h4><p><code>std::deque</code>（双端队列）是一个可以在两端高效插入和删除元素的序列容器。相比<code>vector</code>，<code>deque</code>在两端的操作更高效，但随机访问性能略低。</p>
<h4 id="7-2-2-deque的基本用法"><a href="#7-2-2-deque的基本用法" class="headerlink" title="7.2.2 deque的基本用法"></a>7.2.2 <code>deque</code>的基本用法</h4><p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::deque&lt;<span class="type">int</span>&gt; d;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在前端和后端添加元素</span></span><br><span class="line">    d.<span class="built_in">push_back</span>(<span class="number">100</span>);</span><br><span class="line">    d.<span class="built_in">push_front</span>(<span class="number">50</span>);</span><br><span class="line">    d.<span class="built_in">push_back</span>(<span class="number">150</span>);</span><br><span class="line">    d.<span class="built_in">push_front</span>(<span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Deque elements: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : d) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改元素</span></span><br><span class="line">    d[<span class="number">1</span>] = <span class="number">75</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After modification: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : d) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除前端和后端元素</span></span><br><span class="line">    d.<span class="built_in">pop_front</span>();</span><br><span class="line">    d.<span class="built_in">pop_back</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After pop operations: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : d) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Deque elements: 25 50 100 150 </span><br><span class="line">After modification: 25 75 100 150 </span><br><span class="line">After pop operations: 75 100 </span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>push_back</code>和<code>push_front</code>用于在<code>deque</code>的后端和前端添加元素。</li>
<li><code>pop_back</code>和<code>pop_front</code>用于从后端和前端删除元素。</li>
<li>通过下标访问和修改元素。</li>
</ul>
<h4 id="7-2-3-deque的高级操作"><a href="#7-2-3-deque的高级操作" class="headerlink" title="7.2.3 deque的高级操作"></a>7.2.3 <code>deque</code>的高级操作</h4><p><strong>示例：插入和删除多个元素</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::deque&lt;<span class="type">int</span>&gt; d = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在位置2插入多个元素</span></span><br><span class="line">    d.<span class="built_in">insert</span>(d.<span class="built_in">begin</span>() + <span class="number">2</span>, <span class="number">3</span>, <span class="number">99</span>); <span class="comment">// 插入三个99</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After insert: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : d) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除范围内的元素</span></span><br><span class="line">    d.<span class="built_in">erase</span>(d.<span class="built_in">begin</span>() + <span class="number">1</span>, d.<span class="built_in">begin</span>() + <span class="number">4</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After erase: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : d) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">After insert: 1 2 99 99 99 3 4 5 </span><br><span class="line">After erase: 1 99 3 4 5 </span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>insert</code>可以插入多个相同的元素或一个范围的元素。</li>
<li><code>erase</code>可以删除指定范围内的元素。</li>
</ul>
<h3 id="7-3-stack"><a href="#7-3-stack" class="headerlink" title="7.3 stack"></a>7.3 <code>stack</code></h3><h4 id="7-3-1-stack的概念"><a href="#7-3-1-stack的概念" class="headerlink" title="7.3.1 stack的概念"></a>7.3.1 <code>stack</code>的概念</h4><p><code>std::stack</code>是一种容器适配器，提供后进先出（LIFO）的数据结构。它默认基于<code>std::deque</code>实现，但也可以使用其他容器（如<code>std::vector</code>、<code>std::list</code>）。</p>
<h4 id="7-3-2-stack的基本用法"><a href="#7-3-2-stack的基本用法" class="headerlink" title="7.3.2 stack的基本用法"></a>7.3.2 <code>stack</code>的基本用法</h4><p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::stack&lt;std::string&gt; s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 压入元素</span></span><br><span class="line">    s.<span class="built_in">push</span>(<span class="string">&quot;Apple&quot;</span>);</span><br><span class="line">    s.<span class="built_in">push</span>(<span class="string">&quot;Banana&quot;</span>);</span><br><span class="line">    s.<span class="built_in">push</span>(<span class="string">&quot;Cherry&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看栈顶元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;栈顶元素: &quot;</span> &lt;&lt; s.<span class="built_in">top</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 弹出元素</span></span><br><span class="line">    s.<span class="built_in">pop</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;弹出后栈顶元素: &quot;</span> &lt;&lt; s.<span class="built_in">top</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查栈是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;栈不为空，大小: &quot;</span> &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">栈顶元素: Cherry</span><br><span class="line">弹出后栈顶元素: Banana</span><br><span class="line">栈不为空，大小: 2</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>push</code>用于向栈顶添加元素。</li>
<li><code>top</code>用于查看栈顶元素。</li>
<li><code>pop</code>用于移除栈顶元素。</li>
<li><code>empty</code>和<code>size</code>用于检查栈的状态。</li>
</ul>
<h4 id="7-3-3-stack的限制"><a href="#7-3-3-stack的限制" class="headerlink" title="7.3.3 stack的限制"></a>7.3.3 <code>stack</code>的限制</h4><p><code>std::stack</code>仅支持有限的操作，如<code>push</code>、<code>pop</code>、<code>top</code>等，不能直接访问栈中的中间元素。如果需要更灵活的访问，可以选择其他容器（如<code>std::vector</code>或<code>std::deque</code>）或使用迭代器。</p>
<h3 id="7-4-总结"><a href="#7-4-总结" class="headerlink" title="7.4 总结"></a>7.4 总结</h3><p>STL中的<code>vector</code>、<code>deque</code>和<code>stack</code>提供了高效、灵活的容器选择，适用于不同的应用场景。通过熟练掌握这些容器的使用，可以显著提升C++程序的性能和可维护性。在Qt开发中，这些容器类同样广泛应用于数据管理、界面构建等方面，是每个Qt开发者必备的工具。</p>
<hr>
<h2 id="8-标准模板库（STL）——queue、set与map"><a href="#8-标准模板库（STL）——queue、set与map" class="headerlink" title="8. 标准模板库（STL）——queue、set与map"></a>8. 标准模板库（STL）——<code>queue</code>、<code>set</code>与<code>map</code></h2><p>标准模板库（STL）中的<code>queue</code>、<code>set</code>和<code>map</code>是常用的容器类型，适用于不同的数据组织和管理需求。理解它们的特性和应用场景，可以有效地提升编程效率和代码质量。</p>
<h3 id="8-1-queue"><a href="#8-1-queue" class="headerlink" title="8.1 queue"></a>8.1 <code>queue</code></h3><h4 id="8-1-1-queue的概念"><a href="#8-1-1-queue的概念" class="headerlink" title="8.1.1 queue的概念"></a>8.1.1 <code>queue</code>的概念</h4><p><code>std::queue</code>是一个先进先出（FIFO）的容器适配器，基于底层容器（如<code>std::deque</code>或<code>std::list</code>）实现。它主要用于需要按顺序处理元素的场景，如任务调度、消息队列等。</p>
<h4 id="8-1-2-queue的基本用法"><a href="#8-1-2-queue的基本用法" class="headerlink" title="8.1.2 queue的基本用法"></a>8.1.2 <code>queue</code>的基本用法</h4><p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::queue&lt;std::string&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入队</span></span><br><span class="line">    q.<span class="built_in">push</span>(<span class="string">&quot;First&quot;</span>);</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="string">&quot;Second&quot;</span>);</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="string">&quot;Third&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问队首元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;队首元素: &quot;</span> &lt;&lt; q.<span class="built_in">front</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问队尾元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;队尾元素: &quot;</span> &lt;&lt; q.<span class="built_in">back</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出队</span></span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;出队后新的队首元素: &quot;</span> &lt;&lt; q.<span class="built_in">front</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查队列是否为空</span></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;出队元素: &quot;</span> &lt;&lt; q.<span class="built_in">front</span>() &lt;&lt; std::endl;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">队首元素: First</span><br><span class="line">队尾元素: Third</span><br><span class="line">出队后新的队首元素: Second</span><br><span class="line">出队元素: Second</span><br><span class="line">出队元素: Third</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>push</code>用于向队尾添加元素。</li>
<li><code>front</code>和<code>back</code>分别用于访问队首和队尾元素。</li>
<li><code>pop</code>用于移除队首元素。</li>
<li><code>empty</code>用于检查队列是否为空。</li>
</ul>
<h4 id="8-1-3-queue的高级操作"><a href="#8-1-3-queue的高级操作" class="headerlink" title="8.1.3 queue的高级操作"></a>8.1.3 <code>queue</code>的高级操作</h4><p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入队多个元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        q.<span class="built_in">push</span>(i * <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用循环处理队列</span></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Processing element: &quot;</span> &lt;&lt; q.<span class="built_in">front</span>() &lt;&lt; std::endl;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Processing element: 10</span><br><span class="line">Processing element: 20</span><br><span class="line">Processing element: 30</span><br><span class="line">Processing element: 40</span><br><span class="line">Processing element: 50</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>使用循环入队和出队元素，实现对队列的批量处理。</li>
</ul>
<h3 id="8-2-set"><a href="#8-2-set" class="headerlink" title="8.2 set"></a>8.2 <code>set</code></h3><h4 id="8-2-1-set的概念"><a href="#8-2-1-set的概念" class="headerlink" title="8.2.1 set的概念"></a>8.2.1 <code>set</code>的概念</h4><p><code>std::set</code>是一个关联容器，存储唯一的、有序的元素。<code>set</code>基于平衡二叉树（通常是红黑树）实现，提供高效的查找、插入和删除操作。</p>
<h4 id="8-2-2-set的基本用法"><a href="#8-2-2-set的基本用法" class="headerlink" title="8.2.2 set的基本用法"></a>8.2.2 <code>set</code>的基本用法</h4><p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::set&lt;std::string&gt; fruits;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    fruits.<span class="built_in">insert</span>(<span class="string">&quot;Apple&quot;</span>);</span><br><span class="line">    fruits.<span class="built_in">insert</span>(<span class="string">&quot;Banana&quot;</span>);</span><br><span class="line">    fruits.<span class="built_in">insert</span>(<span class="string">&quot;Cherry&quot;</span>);</span><br><span class="line">    fruits.<span class="built_in">insert</span>(<span class="string">&quot;Apple&quot;</span>); <span class="comment">// 重复元素，不会被插入</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历set</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Fruits set contains:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; fruit : fruits) &#123;</span><br><span class="line">        std::cout &lt;&lt; fruit &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找元素</span></span><br><span class="line">    <span class="keyword">auto</span> it = fruits.<span class="built_in">find</span>(<span class="string">&quot;Banana&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != fruits.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Found: &quot;</span> &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Banana not found.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除元素</span></span><br><span class="line">    fruits.<span class="built_in">erase</span>(<span class="string">&quot;Cherry&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After erasing Cherry:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; fruit : fruits) &#123;</span><br><span class="line">        std::cout &lt;&lt; fruit &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Fruits set contains:</span><br><span class="line">Apple</span><br><span class="line">Banana</span><br><span class="line">Cherry</span><br><span class="line">Found: Banana</span><br><span class="line">After erasing Cherry:</span><br><span class="line">Apple</span><br><span class="line">Banana</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>insert</code>用于向<code>set</code>中添加元素，重复元素不会被插入。</li>
<li><code>find</code>用于查找元素，返回指向元素的迭代器或<code>end</code>迭代器。</li>
<li><code>erase</code>用于删除指定元素。</li>
</ul>
<h4 id="8-2-3-set的高级操作"><a href="#8-2-3-set的高级操作" class="headerlink" title="8.2.3 set的高级操作"></a>8.2.3 <code>set</code>的高级操作</h4><p><strong>示例：集合运算</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; setA = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; setB = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;;</span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; intersection;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算交集</span></span><br><span class="line">    std::<span class="built_in">set_intersection</span>(setA.<span class="built_in">begin</span>(), setA.<span class="built_in">end</span>(),</span><br><span class="line">                          setB.<span class="built_in">begin</span>(), setB.<span class="built_in">end</span>(),</span><br><span class="line">                          std::<span class="built_in">inserter</span>(intersection, intersection.<span class="built_in">begin</span>()));</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Intersection of setA and setB:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : intersection) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Intersection of setA and setB:</span><br><span class="line">4 5 </span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>使用<code>std::set_intersection</code>算法计算两个<code>set</code>的交集。</li>
<li>通过<code>std::inserter</code>将结果插入到<code>intersection</code>集合中。</li>
</ul>
<h3 id="8-3-map"><a href="#8-3-map" class="headerlink" title="8.3 map"></a>8.3 <code>map</code></h3><h4 id="8-3-1-map的概念"><a href="#8-3-1-map的概念" class="headerlink" title="8.3.1 map的概念"></a>8.3.1 <code>map</code>的概念</h4><p><code>std::map</code>是一个关联容器，存储键值对（key-value pairs），并根据键进行有序存储。<code>map</code>基于平衡二叉树实现，键是唯一的，提供高效的查找、插入和删除操作。</p>
<h4 id="8-3-2-map的基本用法"><a href="#8-3-2-map的基本用法" class="headerlink" title="8.3.2 map的基本用法"></a>8.3.2 <code>map</code>的基本用法</h4><p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::map&lt;std::string, <span class="type">int</span>&gt; ageMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入键值对</span></span><br><span class="line">    ageMap[<span class="string">&quot;Alice&quot;</span>] = <span class="number">30</span>;</span><br><span class="line">    ageMap[<span class="string">&quot;Bob&quot;</span>] = <span class="number">25</span>;</span><br><span class="line">    ageMap[<span class="string">&quot;Charlie&quot;</span>] = <span class="number">35</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历map</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Age Map:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : ageMap) &#123;</span><br><span class="line">        std::cout &lt;&lt; pair.first &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; pair.second &lt;&lt; <span class="string">&quot; years old.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找键</span></span><br><span class="line">    std::string name = <span class="string">&quot;Bob&quot;</span>;</span><br><span class="line">    <span class="keyword">auto</span> it = ageMap.<span class="built_in">find</span>(name);</span><br><span class="line">    <span class="keyword">if</span> (it != ageMap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="string">&quot; years old.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; name &lt;&lt; <span class="string">&quot; not found in the map.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除键值对</span></span><br><span class="line">    ageMap.<span class="built_in">erase</span>(<span class="string">&quot;Charlie&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After erasing Charlie:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : ageMap) &#123;</span><br><span class="line">        std::cout &lt;&lt; pair.first &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; pair.second &lt;&lt; <span class="string">&quot; years old.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Age Map:</span><br><span class="line">Alice is 30 years old.</span><br><span class="line">Bob is 25 years old.</span><br><span class="line">Charlie is 35 years old.</span><br><span class="line">Bob is 25 years old.</span><br><span class="line">After erasing Charlie:</span><br><span class="line">Alice is 30 years old.</span><br><span class="line">Bob is 25 years old.</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>使用下标运算符<code>[]</code>向<code>map</code>中插入或更新键值对。</li>
<li><code>find</code>用于查找特定键，返回指向键值对的迭代器或<code>end</code>迭代器。</li>
<li><code>erase</code>用于删除指定键值对。</li>
</ul>
<h4 id="8-3-3-map的高级操作"><a href="#8-3-3-map的高级操作" class="headerlink" title="8.3.3 map的高级操作"></a>8.3.3 <code>map</code>的高级操作</h4><p><strong>示例：遍历和条件插入</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::map&lt;std::string, <span class="type">int</span>&gt; scoreMap = &#123;</span><br><span class="line">        &#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">85</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">92</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Charlie&quot;</span>, <span class="number">78</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Diana&quot;</span>, <span class="number">88</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历并输出成绩高于80的学生</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Students with scores above 80:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : scoreMap) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pair.second &gt; <span class="number">80</span>) &#123;</span><br><span class="line">            std::cout &lt;&lt; pair.first &lt;&lt; <span class="string">&quot; scored &quot;</span> &lt;&lt; pair.second &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用insert方法插入新键值对</span></span><br><span class="line">    <span class="keyword">auto</span> result = scoreMap.<span class="built_in">insert</span>(&#123;<span class="string">&quot;Eve&quot;</span>, <span class="number">95</span>&#125;);</span><br><span class="line">    <span class="keyword">if</span> (result.second) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Inserted Eve with score &quot;</span> &lt;&lt; result.first-&gt;second &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to insert Eve, key already exists.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试插入已存在的键</span></span><br><span class="line">    result = scoreMap.<span class="built_in">insert</span>(&#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">90</span>&#125;);</span><br><span class="line">    <span class="keyword">if</span> (result.second) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Inserted Alice with score &quot;</span> &lt;&lt; result.first-&gt;second &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to insert Alice, key already exists.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Students with scores above 80:</span><br><span class="line">Alice scored 85</span><br><span class="line">Bob scored 92</span><br><span class="line">Diana scored 88</span><br><span class="line">Inserted Eve with score 95</span><br><span class="line">Failed to insert Alice, key already exists.</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>使用<code>insert</code>方法插入新的键值对，<code>insert</code>返回一个<code>pair</code>，其中<code>second</code>表示插入是否成功。</li>
<li>尝试插入已存在的键（如<code>&quot;Alice&quot;</code>）会失败，避免了键的重复。</li>
</ul>
<h3 id="8-4-总结"><a href="#8-4-总结" class="headerlink" title="8.4 总结"></a>8.4 总结</h3><p>STL中的<code>queue</code>、<code>set</code>和<code>map</code>为C++开发者提供了高效、可靠的数据结构，适用于各种编程需求。通过深入理解它们的特性和应用场景，可以大大提升程序的性能和可维护性。在Qt开发中，这些容器类同样发挥着重要作用，特别是在数据管理和界面交互等方面。</p>
<hr>
<h2 id="9-C-异常处理（Exception-Handling）"><a href="#9-C-异常处理（Exception-Handling）" class="headerlink" title="9. C++异常处理（Exception Handling）"></a>9. C++异常处理（Exception Handling）</h2><h3 id="9-1-异常处理的概念"><a href="#9-1-异常处理的概念" class="headerlink" title="9.1 异常处理的概念"></a>9.1 异常处理的概念</h3><p>异常处理是C++中用于处理运行时错误和意外情况的机制。通过异常处理，可以在程序中优雅地应对错误，避免程序崩溃，并提供恢复或清理资源的机会。</p>
<h3 id="9-2-异常处理的基本语法"><a href="#9-2-异常处理的基本语法" class="headerlink" title="9.2 异常处理的基本语法"></a>9.2 异常处理的基本语法</h3><p>C++提供了<code>try</code>、<code>catch</code>和<code>throw</code>三个关键字来实现异常处理。</p>
<p><strong>基本结构：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 可能抛出异常的代码</span></span><br><span class="line">&#125; <span class="built_in">catch</span> (ExceptionType1 e1) &#123;</span><br><span class="line">    <span class="comment">// 处理ExceptionType1类型的异常</span></span><br><span class="line">&#125; <span class="built_in">catch</span> (ExceptionType2 e2) &#123;</span><br><span class="line">    <span class="comment">// 处理ExceptionType2类型的异常</span></span><br><span class="line">&#125; <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">    <span class="comment">// 处理所有其他类型的异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-3-使用try、catch和throw"><a href="#9-3-使用try、catch和throw" class="headerlink" title="9.3 使用try、catch和throw"></a>9.3 使用<code>try</code>、<code>catch</code>和<code>throw</code></h3><p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数，计算两个数的除法</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">divide</span><span class="params">(<span class="type">double</span> numerator, <span class="type">double</span> denominator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (denominator == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;分母不能为零。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numerator / denominator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> a = <span class="number">10.0</span>, b = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">double</span> result = <span class="built_in">divide</span>(a, b);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;结果: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::invalid_argument&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;异常捕获: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;未知异常发生。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;程序继续运行...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">异常捕获: 分母不能为零。</span><br><span class="line">程序继续运行...</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>divide</code>函数在分母为零时，通过<code>throw</code>抛出<code>std::invalid_argument</code>异常。</li>
<li><code>try</code>块中调用<code>divide</code>函数，可能抛出异常。</li>
<li><code>catch</code>块捕获并处理<code>std::invalid_argument</code>类型的异常，输出错误信息。</li>
<li>程序在异常处理后继续运行，避免了崩溃。</li>
</ul>
<h3 id="9-4-自定义异常类"><a href="#9-4-自定义异常类" class="headerlink" title="9.4 自定义异常类"></a>9.4 自定义异常类</h3><p>除了使用标准库中的异常类外，还可以定义自定义异常类，以提供更具体的错误信息。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义异常类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyException</span> : <span class="keyword">public</span> std::exception &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyException</span>(<span class="type">const</span> std::string&amp; message) : <span class="built_in">msg_</span>(message) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">what</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> msg_.<span class="built_in">c_str</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string msg_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数，模拟错误</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">riskyFunction</span><span class="params">(<span class="type">bool</span> triggerError)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (triggerError) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">MyException</span>(<span class="string">&quot;自定义错误发生！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;函数正常执行。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">riskyFunction</span>(<span class="literal">true</span>);</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> MyException&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;捕获到自定义异常: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;捕获到标准异常: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">捕获到自定义异常: 自定义错误发生！</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>MyException</code>继承自<code>std::exception</code>，并重写了<code>what</code>函数以返回自定义的错误信息。</li>
<li><code>riskyFunction</code>根据参数决定是否抛出<code>MyException</code>。</li>
<li><code>main</code>函数中的<code>try</code>块调用<code>riskyFunction</code>，并通过<code>catch</code>块捕获和处理自定义异常。</li>
</ul>
<h3 id="9-5-异常安全性与最佳实践"><a href="#9-5-异常安全性与最佳实践" class="headerlink" title="9.5 异常安全性与最佳实践"></a>9.5 异常安全性与最佳实践</h3><p>在编写异常处理代码时，应遵循以下最佳实践，确保程序的异常安全性和健壮性：</p>
<ol>
<li><strong>提供有意义的错误信息</strong>：异常对象应包含足够的上下文信息，帮助调试和问题定位。</li>
<li><strong>尽量减少异常的抛出</strong>：只在真正需要时抛出异常，避免在性能敏感的代码中频繁抛出异常。</li>
<li><strong>遵循RAII原则</strong>：通过资源获取即初始化（RAII）管理资源，确保在异常发生时资源被正确释放。</li>
<li><strong>避免资源泄漏</strong>：确保所有资源（如内存、文件句柄）在异常发生时都能被释放，可以使用智能指针和容器类来管理资源。</li>
<li><strong>捕获异常的适当范围</strong>：尽量在需要的地方捕获异常，避免在过大的范围内捕获异常，导致难以理解的错误处理。</li>
<li><strong>使用特定的异常类型</strong>：尽量捕获具体的异常类型，而不是使用通配符<code>catch(...)</code>，以便进行针对性的错误处理。</li>
<li><strong>保持异常规范</strong>：函数应明确声明可能抛出的异常类型，并遵循一致的异常处理策略。</li>
</ol>
<p><strong>示例：使用RAII和智能指针确保异常安全</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 资源类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Resource</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Resource</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;资源已分配。&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    ~<span class="built_in">Resource</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;资源已释放。&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;资源正在使用。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数，使用资源并可能抛出异常</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">useResource</span><span class="params">(<span class="type">bool</span> triggerError)</span> </span>&#123;</span><br><span class="line">    std::unique_ptr&lt;Resource&gt; res = std::<span class="built_in">make_unique</span>&lt;Resource&gt;();</span><br><span class="line">    res-&gt;<span class="built_in">doSomething</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (triggerError) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;在使用资源时发生错误。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// res在函数结束时自动释放，无需手动delete</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">useResource</span>(<span class="literal">true</span>);</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;异常捕获: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">资源已分配。</span><br><span class="line">资源正在使用。</span><br><span class="line">异常捕获: 在使用资源时发生错误。</span><br><span class="line">资源已释放。</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>使用<code>std::unique_ptr</code>管理<code>Resource</code>对象，确保即使在异常发生时，资源也能被自动释放。</li>
<li><code>useResource</code>函数中，当<code>triggerError</code>为<code>true</code>时，抛出<code>std::runtime_error</code>异常。</li>
<li>在<code>main</code>函数中，通过<code>try-catch</code>块捕获并处理异常，避免程序崩溃。</li>
</ul>
<h3 id="9-6-总结"><a href="#9-6-总结" class="headerlink" title="9.6 总结"></a>9.6 总结</h3><p>异常处理是C++中确保程序健壮性和稳定性的重要机制。通过合理使用<code>try</code>、<code>catch</code>和<code>throw</code>，并结合自定义异常类和RAII原则，可以有效地应对运行时错误，提升程序的可靠性。在Qt开发中，异常处理同样至关重要，特别是在处理文件操作、网络通信和动态内存管理等可能出现错误的场景中。</p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章详细介绍了Qt C++语言编程进阶的下半部分内容，涵盖了命名空间与模板、C++ IO流类库、STL容器（<code>vector</code>、<code>deque</code>、<code>stack</code>、<code>queue</code>、<code>set</code>、<code>map</code>）以及C++异常处理机制。这些高级特性和工具不仅丰富了C++的编程能力，也为Qt开发提供了强大的支持，使得开发者能够编写出更加高效、灵活和可维护的应用程序。</p>
<h3 id="主要内容回顾："><a href="#主要内容回顾：" class="headerlink" title="主要内容回顾："></a>主要内容回顾：</h3><ol>
<li><p><strong>命名空间与模板</strong>：</p>
<ul>
<li>命名空间用于组织代码，避免命名冲突。</li>
<li>模板支持泛型编程，实现函数和类的类型泛化和复用。</li>
</ul>
</li>
<li><p><strong>C++ IO流类库</strong>：</p>
<ul>
<li>提供了与控制台和文件的高效输入输出机制。</li>
<li>支持格式化输出，满足各种数据展示需求。</li>
</ul>
</li>
<li><p><strong>STL容器</strong>：</p>
<ul>
<li>**<code>vector</code>**：动态数组，支持随机访问和高效的元素操作。</li>
<li>**<code>deque</code>**：双端队列，支持两端的高效插入和删除。</li>
<li>**<code>stack</code>**：后进先出（LIFO）容器适配器。</li>
<li>**<code>queue</code>**：先进先出（FIFO）容器适配器。</li>
<li>**<code>set</code>**：有序的唯一元素集合，支持高效的查找和集合运算。</li>
<li>**<code>map</code>**：键值对的有序集合，适用于快速查找和关联数据管理。</li>
</ul>
</li>
<li><p><strong>C++异常处理</strong>：</p>
<ul>
<li>通过<code>try</code>、<code>catch</code>和<code>throw</code>实现运行时错误处理。</li>
<li>支持自定义异常类，结合RAII和智能指针确保异常安全性。</li>
</ul>
</li>
</ol>
<h3 id="下一步学习建议："><a href="#下一步学习建议：" class="headerlink" title="下一步学习建议："></a>下一步学习建议：</h3><p>掌握了C++的进阶特性后，建议继续深入以下内容，以全面提升Qt C++编程能力：</p>
<ul>
<li><strong>Qt框架核心概念</strong>：如信号与槽机制、事件处理、Qt的容器类等。</li>
<li><strong>Qt GUI开发</strong>：学习Qt Widgets、Qt Quick等用于构建用户界面的模块。</li>
<li><strong>Qt多线程编程</strong>：掌握Qt提供的多线程类和机制，实现高性能和响应式应用。</li>
<li><strong>Qt网络编程</strong>：了解Qt的网络模块，构建网络应用和服务。</li>
<li><strong>Qt项目实战</strong>：通过实际项目的开发，结合理论知识，巩固和应用所学内容。</li>
</ul>
<p>持续关注，我们将在后续的文章中详细介绍这些内容，帮助您全面掌握Qt C++编程的高级技能，提升开发效率，构建高质量的Qt应用程序。</p>
<hr>
<p><em>如果您对本文内容有任何疑问或建议，欢迎在评论区留言与我们交流。感谢您的阅读与支持！</em></p>
]]></content>
  </entry>
  <entry>
    <title>Qt开发基础体系详解</title>
    <url>/2024/12/26/Qt%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%E4%BD%93%E7%B3%BB%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><span id="more"></span>

<h1 id="Qt开发基础体系详解"><a href="#Qt开发基础体系详解" class="headerlink" title="Qt开发基础体系详解"></a>Qt开发基础体系详解</h1><p>Qt作为一个跨平台的C++应用程序开发框架，以其丰富的功能和高效的开发工具广受开发者青睐。无论您是初学者还是有经验的开发者，掌握Qt的基础安装、开发环境配置、工具使用以及核心机制如信号与槽，都是高效开发Qt应用的关键。本篇文章将详细介绍Qt的下载与安装配置，分别针对Windows和Linux系统的环境安装，深入讲解Qt Creator工具的使用，并探讨Qt独有的信号与槽机制以及Qt中的字符串、数据类型和容器类的应用。</p>
<hr>
<h2 id="1-Qt下载与安装配置"><a href="#1-Qt下载与安装配置" class="headerlink" title="1. Qt下载与安装配置"></a>1. Qt下载与安装配置</h2><h3 id="1-1-从官方网站下载Qt"><a href="#1-1-从官方网站下载Qt" class="headerlink" title="1.1 从官方网站下载Qt"></a>1.1 从官方网站下载Qt</h3><p>要开始Qt开发，首先需要从Qt的官方网站下载Qt框架及相关开发工具。以下是下载步骤：</p>
<ol>
<li><p><strong>访问Qt官方网站</strong>：<br>打开浏览器，访问<a href="https://www.qt.io/download">Qt官方网站</a>。</p>
</li>
<li><p><strong>选择合适的版本</strong>：<br>Qt提供了多个版本，包括开源版和商业版。对于个人学习和开源项目开发，可以选择开源版。点击“Download the Qt Online Installer”按钮下载在线安装程序。</p>
</li>
<li><p><strong>注册或登录Qt账号</strong>：<br>下载和安装Qt需要一个Qt账号。如果您还没有账号，可以点击“Sign Up”进行注册。已有账号的用户可以直接登录。</p>
</li>
<li><p><strong>下载安装程序</strong>：<br>登录后，根据操作系统（Windows、Linux或macOS）选择相应的安装程序下载。</p>
</li>
</ol>
<h3 id="1-2-安装Qt"><a href="#1-2-安装Qt" class="headerlink" title="1.2 安装Qt"></a>1.2 安装Qt</h3><p>下载完成后，按照以下步骤进行Qt的安装：</p>
<ol>
<li><p><strong>运行安装程序</strong>：<br>双击下载的安装程序（如<code>qt-unified-windows-x86-4.x.x-online.exe</code>），启动安装向导。</p>
</li>
<li><p><strong>登录Qt账号</strong>：<br>安装过程中会提示您登录Qt账号，输入您的账号信息后继续。</p>
</li>
<li><p><strong>选择安装组件</strong>：</p>
<ul>
<li><strong>选择安装目录</strong>：默认情况下，Qt会安装在<code>C:\Qt</code>（Windows）或<code>/opt/Qt</code>（Linux）目录下。您可以根据需要更改安装路径。</li>
<li><strong>选择Qt版本和组件</strong>：选择您需要安装的Qt版本（如Qt 5.x或Qt 6.x）和目标编译器（如MinGW、MSVC、Clang等）。对于初学者，建议选择默认推荐的编译器。</li>
</ul>
</li>
<li><p><strong>开始安装</strong>：<br>确认选择后，点击“Next”开始下载和安装Qt组件。安装时间取决于所选组件的大小和网络速度。</p>
</li>
<li><p><strong>完成安装</strong>：<br>安装完成后，您可以选择启动Qt Creator或直接关闭安装向导。</p>
</li>
</ol>
<h3 id="1-3-配置开发环境"><a href="#1-3-配置开发环境" class="headerlink" title="1.3 配置开发环境"></a>1.3 配置开发环境</h3><p>安装完成后，进行以下配置以确保开发环境正常运行：</p>
<ol>
<li><p><strong>设置环境变量</strong>（可选）：<br>虽然Qt安装程序会自动配置环境变量，但有时您可能需要手动设置。例如，在Windows上，可以将Qt的<code>bin</code>目录添加到系统的<code>PATH</code>环境变量中，以便在命令行中直接调用Qt工具。</p>
</li>
<li><p><strong>验证安装</strong>：<br>打开Qt Creator，创建一个简单的“Hello World”项目，编译并运行，以确认安装和配置是否成功。</p>
</li>
</ol>
<hr>
<h2 id="2-Windows-Qt环境安装"><a href="#2-Windows-Qt环境安装" class="headerlink" title="2. Windows Qt环境安装"></a>2. Windows Qt环境安装</h2><p>在Windows系统上安装Qt涉及下载适用于Windows的Qt安装包，并配置必要的编译器和工具链。以下是详细步骤：</p>
<h3 id="2-1-系统要求"><a href="#2-1-系统要求" class="headerlink" title="2.1 系统要求"></a>2.1 系统要求</h3><p>确保您的Windows系统满足以下要求：</p>
<ul>
<li><strong>操作系统</strong>：Windows 7、8、10或更高版本（64位推荐）</li>
<li><strong>磁盘空间</strong>：至少5GB的可用空间</li>
<li><strong>编译器</strong>：推荐使用MinGW（随Qt安装包提供）或Microsoft Visual C++编译器</li>
</ul>
<h3 id="2-2-下载Qt安装程序"><a href="#2-2-下载Qt安装程序" class="headerlink" title="2.2 下载Qt安装程序"></a>2.2 下载Qt安装程序</h3><ol>
<li><p><strong>访问Qt下载页面</strong>：<br>打开浏览器，访问<a href="https://www.qt.io/download">Qt下载页面</a>。</p>
</li>
<li><p><strong>选择Windows版本</strong>：<br>点击“Download the Qt Online Installer”按钮，下载适用于Windows的在线安装程序。</p>
</li>
</ol>
<h3 id="2-3-安装Qt"><a href="#2-3-安装Qt" class="headerlink" title="2.3 安装Qt"></a>2.3 安装Qt</h3><ol>
<li><p><strong>运行安装程序</strong>：<br>双击下载的安装程序（如<code>qt-unified-windows-x86-4.x.x-online.exe</code>），启动安装向导。</p>
</li>
<li><p><strong>登录Qt账号</strong>：<br>按照提示登录您的Qt账号。如果没有账号，请先注册。</p>
</li>
<li><p><strong>选择安装目录</strong>：<br>默认安装目录为<code>C:\Qt</code>，您可以根据需要更改路径。</p>
</li>
<li><p><strong>选择Qt版本和编译器</strong>：</p>
<ul>
<li><strong>Qt版本</strong>：选择您需要的Qt版本（如Qt 5.15或Qt 6.x）。</li>
<li><strong>编译器</strong>：选择MinGW或MSVC编译器。如果选择MinGW，安装程序会自动下载和配置MinGW。如果您已经安装了Visual Studio，选择对应的MSVC编译器。</li>
</ul>
<p><img src="https://www.qt.io/hubfs/Qt%20Solutions%20-%20Home%20Page/2020/June/3-qt-creator.png" alt="Qt安装选择"></p>
</li>
<li><p><strong>选择组件</strong>：<br>根据您的项目需求选择额外的组件，如Qt Charts、Qt Quick Controls等。</p>
</li>
<li><p><strong>开始安装</strong>：<br>点击“Next”开始下载和安装所选组件。下载和安装过程可能需要一些时间，请耐心等待。</p>
</li>
<li><p><strong>完成安装</strong>：<br>安装完成后，您可以选择启动Qt Creator，或者稍后手动启动。</p>
</li>
</ol>
<h3 id="2-4-配置编译器"><a href="#2-4-配置编译器" class="headerlink" title="2.4 配置编译器"></a>2.4 配置编译器</h3><p>如果您选择了MSVC编译器，确保已经安装了相应版本的Visual Studio和C++开发工具。MinGW编译器通常随Qt安装包一起安装，无需额外配置。</p>
<ol>
<li><p><strong>验证编译器</strong>：<br>打开Qt Creator，进入“工具” &gt; “选项” &gt; “构建和运行” &gt; “编译器”，确保所选编译器已正确配置。</p>
</li>
<li><p><strong>配置构建套件</strong>：<br>在“构建和运行” &gt; “套件”中，确认已配置相应的构建套件（Compiler、Debugger、Qt版本）。</p>
</li>
</ol>
<h3 id="2-5-测试安装"><a href="#2-5-测试安装" class="headerlink" title="2.5 测试安装"></a>2.5 测试安装</h3><p>创建一个简单的Qt Widgets应用程序，编译并运行，以确保安装和配置无误。</p>
<p><strong>步骤</strong>：</p>
<ol>
<li>打开Qt Creator。</li>
<li>点击“文件” &gt; “新建文件或项目”。</li>
<li>选择“应用程序” &gt; “Qt Widgets 应用程序”，点击“选择”。</li>
<li>填写项目名称和位置，点击“下一步”。</li>
<li>选择合适的Qt版本和构建套件，点击“下一步”。</li>
<li>点击“完成”创建项目。</li>
<li>在项目中添加一个简单的按钮或标签，编译并运行。</li>
</ol>
<p><strong>预期结果</strong>：<br>出现一个包含按钮或标签的窗口，点击按钮或查看标签内容，验证应用程序正常运行。</p>
<hr>
<h2 id="3-Linux-Qt环境安装"><a href="#3-Linux-Qt环境安装" class="headerlink" title="3. Linux Qt环境安装"></a>3. Linux Qt环境安装</h2><p>在Linux系统上安装Qt可以通过多种方式完成，包括使用包管理器安装预编译的Qt包或从源码编译Qt。以下是详细步骤：</p>
<h3 id="3-1-使用包管理器安装"><a href="#3-1-使用包管理器安装" class="headerlink" title="3.1 使用包管理器安装"></a>3.1 使用包管理器安装</h3><p>多数Linux发行版的官方仓库中都包含Qt的预编译包，安装简单快捷。</p>
<h4 id="3-1-1-Ubuntu-x2F-Debian"><a href="#3-1-1-Ubuntu-x2F-Debian" class="headerlink" title="3.1.1 Ubuntu&#x2F;Debian"></a>3.1.1 Ubuntu&#x2F;Debian</h4><ol>
<li><p><strong>更新包列表</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>安装Qt和Qt Creator</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install qt5-default qtcreator</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>验证安装</strong>：<br>打开Qt Creator，创建并运行一个简单的Qt项目。</p>
</li>
</ol>
<h4 id="3-1-2-Fedora"><a href="#3-1-2-Fedora" class="headerlink" title="3.1.2 Fedora"></a>3.1.2 Fedora</h4><ol>
<li><p><strong>更新包列表</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo dnf update</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>安装Qt和Qt Creator</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo dnf install qt5-qtbase-devel qt-creator</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>验证安装</strong>：<br>打开Qt Creator，创建并运行一个简单的Qt项目。</p>
</li>
</ol>
<h4 id="3-1-3-Arch-Linux"><a href="#3-1-3-Arch-Linux" class="headerlink" title="3.1.3 Arch Linux"></a>3.1.3 Arch Linux</h4><ol>
<li><p><strong>更新包列表</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pacman -Syu</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>安装Qt和Qt Creator</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pacman -S qt5-base qtcreator</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>验证安装</strong>：<br>打开Qt Creator，创建并运行一个简单的Qt项目。</p>
</li>
</ol>
<h3 id="3-2-从源码编译安装"><a href="#3-2-从源码编译安装" class="headerlink" title="3.2 从源码编译安装"></a>3.2 从源码编译安装</h3><p>从源码编译Qt适用于需要自定义构建配置或最新Qt版本的开发者。以下是从源码编译Qt的步骤：</p>
<h4 id="3-2-1-安装依赖"><a href="#3-2-1-安装依赖" class="headerlink" title="3.2.1 安装依赖"></a>3.2.1 安装依赖</h4><p>确保系统已安装构建Qt所需的依赖项。以Ubuntu为例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install build-essential libgl1-mesa-dev</span><br><span class="line">sudo apt install libfontconfig1-dev libdbus-1-dev libfreetype6-dev libicu-dev</span><br><span class="line">sudo apt install libjpeg-dev libpng-dev libssl-dev</span><br></pre></td></tr></table></figure>

<h4 id="3-2-2-下载Qt源码"><a href="#3-2-2-下载Qt源码" class="headerlink" title="3.2.2 下载Qt源码"></a>3.2.2 下载Qt源码</h4><ol>
<li><p><strong>访问Qt下载页面</strong>：<br>访问<a href="https://download.qt.io/archive/qt/">Qt官网源码下载</a>页面，选择所需的Qt版本。</p>
</li>
<li><p><strong>下载源码包</strong>：<br>使用<code>wget</code>或浏览器下载源码压缩包。例如，下载Qt 5.15.2源码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://download.qt.io/archive/qt/5.15/5.15.2/single/qt-everywhere-src-5.15.2.tar.xz</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>解压源码包</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -xf qt-everywhere-src-5.15.2.tar.xz</span><br><span class="line"><span class="built_in">cd</span> qt-everywhere-src-5.15.2</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="3-2-3-配置和编译"><a href="#3-2-3-配置和编译" class="headerlink" title="3.2.3 配置和编译"></a>3.2.3 配置和编译</h4><ol>
<li><p><strong>运行配置脚本</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./configure -prefix /opt/Qt5.15.2 -opensource -confirm-license -nomake examples -nomake tests</span><br></pre></td></tr></table></figure>

<ul>
<li><code>-prefix</code>：指定安装路径。</li>
<li><code>-opensource</code>：选择开源许可。</li>
<li><code>-nomake examples</code>和<code>-nomake tests</code>：跳过示例和测试的编译，加快编译速度。</li>
</ul>
</li>
<li><p><strong>编译Qt</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make -j$(<span class="built_in">nproc</span>)</span><br></pre></td></tr></table></figure>

<p><code>-j$(nproc)</code>选项使用所有可用的CPU核心，加快编译过程。</p>
</li>
<li><p><strong>安装Qt</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>配置环境变量</strong>：<br>添加Qt的<code>bin</code>目录到<code>PATH</code>环境变量中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=/opt/Qt5.15.2/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure>

<p>为了永久生效，可以将上述命令添加到<code>~/.bashrc</code>或<code>~/.profile</code>文件中。</p>
</li>
</ol>
<h4 id="3-2-4-验证安装"><a href="#3-2-4-验证安装" class="headerlink" title="3.2.4 验证安装"></a>3.2.4 验证安装</h4><p>创建一个简单的Qt Widgets应用程序，编译并运行，以确认从源码编译的Qt安装成功。</p>
<p><strong>步骤</strong>：</p>
<ol>
<li>打开Qt Creator，选择刚编译和安装的Qt版本作为构建套件。</li>
<li>创建一个新的Qt Widgets应用项目。</li>
<li>添加一个按钮或标签，编译并运行项目。</li>
</ol>
<p><strong>预期结果</strong>：<br>出现一个包含按钮或标签的窗口，点击按钮或查看标签内容，验证应用程序正常运行。</p>
<hr>
<h2 id="4-Qt-Creator工具介绍与使用"><a href="#4-Qt-Creator工具介绍与使用" class="headerlink" title="4. Qt Creator工具介绍与使用"></a>4. Qt Creator工具介绍与使用</h2><p>Qt Creator是Qt官方提供的集成开发环境（IDE），专为Qt应用程序开发而设计。它提供了丰富的功能，如代码编辑、项目管理、调试、界面设计等，极大地提升了开发效率。</p>
<h3 id="4-1-Qt-Creator的界面概述"><a href="#4-1-Qt-Creator的界面概述" class="headerlink" title="4.1 Qt Creator的界面概述"></a>4.1 Qt Creator的界面概述</h3><p>启动Qt Creator后，您将看到一个现代化的用户界面，主要包括以下几个部分：</p>
<ol>
<li><p><strong>菜单栏</strong>：<br>包含常用的菜单选项，如“文件”、“编辑”、“视图”、“工具”、“帮助”等。</p>
</li>
<li><p><strong>工具栏</strong>：<br>快速访问常用功能，如创建新项目、打开项目、保存、编译、运行、调试等。</p>
</li>
<li><p><strong>项目视图</strong>：<br>显示当前打开的项目及其文件结构，支持多项目管理。</p>
</li>
<li><p><strong>代码编辑器</strong>：<br>核心区域，用于编写和编辑代码，支持语法高亮、代码补全、智能提示等功能。</p>
</li>
<li><p><strong>输出窗口</strong>：<br>显示编译输出、运行日志、调试信息等。</p>
</li>
<li><p><strong>调试视图</strong>：<br>提供断点管理、变量监视、调用堆栈查看等调试功能。</p>
</li>
<li><p><strong>设计器视图</strong>：<br>用于设计Qt Widgets或Qt Quick界面，支持拖放组件、属性编辑等。</p>
</li>
</ol>
<p><img src="https://www.qt.io/hubfs/Qt%20Solutions%20-%20Home%20Page/2020/June/3-qt-creator.png" alt="Qt Creator界面"></p>
<h3 id="4-2-创建和管理项目"><a href="#4-2-创建和管理项目" class="headerlink" title="4.2 创建和管理项目"></a>4.2 创建和管理项目</h3><h4 id="4-2-1-创建新项目"><a href="#4-2-1-创建新项目" class="headerlink" title="4.2.1 创建新项目"></a>4.2.1 创建新项目</h4><ol>
<li><p><strong>启动Qt Creator</strong>：<br>打开Qt Creator，进入欢迎界面。</p>
</li>
<li><p><strong>新建项目</strong>：<br>点击“新建项目”（<code>Ctrl+N</code>），选择“应用程序”下的“Qt Widgets 应用程序”或“Qt Quick 应用程序”，根据需求选择。</p>
</li>
<li><p><strong>配置项目</strong>：</p>
<ul>
<li><strong>项目名称和位置</strong>：填写项目名称和保存路径。</li>
<li><strong>选择Qt版本和构建套件</strong>：选择合适的Qt版本和编译器。</li>
</ul>
</li>
<li><p><strong>设计项目结构</strong>：<br>根据需要选择项目模板，如基本应用、带有示例代码的应用等。</p>
</li>
<li><p><strong>完成创建</strong>：<br>点击“完成”后，Qt Creator将生成项目文件并打开主编辑界面。</p>
</li>
</ol>
<h4 id="4-2-2-管理项目文件"><a href="#4-2-2-管理项目文件" class="headerlink" title="4.2.2 管理项目文件"></a>4.2.2 管理项目文件</h4><p>在项目视图中，您可以看到项目的所有文件和目录结构。常见的文件包括：</p>
<ul>
<li><strong>.pro文件</strong>：Qt项目文件，定义了项目的配置和构建设置。</li>
<li><strong>main.cpp</strong>：主程序入口。</li>
<li><strong>mainwindow.h&#x2F;.cpp&#x2F;.ui</strong>：主窗口类的头文件、实现文件和界面设计文件。</li>
<li><strong>其他源文件和资源文件</strong>：根据项目需要添加的文件。</li>
</ul>
<h3 id="4-3-代码编辑与调试"><a href="#4-3-代码编辑与调试" class="headerlink" title="4.3 代码编辑与调试"></a>4.3 代码编辑与调试</h3><h4 id="4-3-1-代码编辑器"><a href="#4-3-1-代码编辑器" class="headerlink" title="4.3.1 代码编辑器"></a>4.3.1 代码编辑器</h4><p>Qt Creator的代码编辑器提供了丰富的功能，提升代码编写效率：</p>
<ul>
<li><strong>语法高亮</strong>：不同类型的代码元素以不同颜色显示，提升可读性。</li>
<li><strong>代码补全</strong>：智能提示变量、函数、类名等，减少打字错误。</li>
<li><strong>错误提示</strong>：实时显示编译错误和警告，帮助快速定位问题。</li>
<li><strong>代码折叠</strong>：可以折叠或展开代码块，简化代码浏览。</li>
<li><strong>重构工具</strong>：支持重命名、提取函数等代码重构操作。</li>
</ul>
<h4 id="4-3-2-编译与运行"><a href="#4-3-2-编译与运行" class="headerlink" title="4.3.2 编译与运行"></a>4.3.2 编译与运行</h4><ol>
<li><p><strong>编译项目</strong>：<br>点击工具栏中的“构建”按钮（<code>Ctrl+B</code>），Qt Creator将根据项目配置编译源代码。</p>
</li>
<li><p><strong>运行项目</strong>：<br>编译成功后，点击“运行”按钮（<code>Ctrl+R</code>），启动应用程序。</p>
</li>
<li><p><strong>调试项目</strong>：<br>点击“调试”按钮（<code>F5</code>），启动调试模式。您可以设置断点、查看变量、步进代码等，帮助定位和解决问题。</p>
</li>
</ol>
<h4 id="4-3-3-调试工具"><a href="#4-3-3-调试工具" class="headerlink" title="4.3.3 调试工具"></a>4.3.3 调试工具</h4><p>Qt Creator集成了强大的调试工具，支持以下功能：</p>
<ul>
<li><strong>断点管理</strong>：设置、启用、禁用或删除断点。</li>
<li><strong>变量监视</strong>：查看和监控变量的当前值。</li>
<li><strong>调用堆栈</strong>：查看函数调用链，帮助理解程序执行流程。</li>
<li><strong>内存查看</strong>：检查内存分配和指针指向，诊断内存问题。</li>
</ul>
<h3 id="4-4-使用Qt-Designer设计界面"><a href="#4-4-使用Qt-Designer设计界面" class="headerlink" title="4.4 使用Qt Designer设计界面"></a>4.4 使用Qt Designer设计界面</h3><p>Qt Creator集成了Qt Designer，提供可视化的界面设计工具，使得设计复杂的用户界面变得简单直观。</p>
<h4 id="4-4-1-打开Qt-Designer"><a href="#4-4-1-打开Qt-Designer" class="headerlink" title="4.4.1 打开Qt Designer"></a>4.4.1 打开Qt Designer</h4><ol>
<li><p><strong>创建或打开项目</strong>：<br>在Qt Creator中创建一个Qt Widgets应用项目，自动生成主窗口文件（如<code>mainwindow.ui</code>）。</p>
</li>
<li><p><strong>进入设计模式</strong>：<br>双击<code>mainwindow.ui</code>文件，Qt Creator将切换到设计视图，显示Qt Designer界面。</p>
</li>
</ol>
<h4 id="4-4-2-设计界面"><a href="#4-4-2-设计界面" class="headerlink" title="4.4.2 设计界面"></a>4.4.2 设计界面</h4><ol>
<li><p><strong>拖放组件</strong>：<br>从左侧的“部件”面板中拖放按钮、标签、文本框等组件到主窗口中。</p>
</li>
<li><p><strong>调整属性</strong>：<br>选中组件后，在右侧的“属性编辑器”中调整其属性，如大小、位置、文本内容等。</p>
</li>
<li><p><strong>布局管理</strong>：<br>使用布局管理器（如垂直布局、水平布局、网格布局）自动排列和调整组件，确保界面在不同分辨率下的良好显示。</p>
</li>
<li><p><strong>信号与槽连接</strong>：<br>在设计视图中，可以通过右键点击组件选择“转到槽”来自动生成信号与槽的连接代码。</p>
</li>
</ol>
<h4 id="4-4-3-保存和生成代码"><a href="#4-4-3-保存和生成代码" class="headerlink" title="4.4.3 保存和生成代码"></a>4.4.3 保存和生成代码</h4><p>完成界面设计后，保存<code>mainwindow.ui</code>文件，Qt Creator会自动生成对应的<code>ui_mainwindow.h</code>文件，供项目中引用和使用。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_mainwindow.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent) :</span><br><span class="line">    <span class="built_in">QMainWindow</span>(parent),</span><br><span class="line">    <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 连接按钮的点击信号到槽函数</span></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;pushButton, &amp;QPushButton::clicked, <span class="keyword">this</span>, &amp;MainWindow::onButtonClicked);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::onButtonClicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ui-&gt;label-&gt;<span class="built_in">setText</span>(<span class="string">&quot;按钮已点击！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>ui-&gt;setupUi(this)</code>初始化界面。</li>
<li>通过<code>connect</code>函数将按钮的<code>clicked</code>信号连接到自定义槽函数<code>onButtonClicked</code>，实现按钮点击后的行为。</li>
</ul>
<hr>
<h2 id="5-Qt信号与槽机制"><a href="#5-Qt信号与槽机制" class="headerlink" title="5. Qt信号与槽机制"></a>5. Qt信号与槽机制</h2><p>Qt独有的信号与槽机制是其核心特性之一，提供了一种高效的对象间通信方式。通过信号与槽，Qt对象可以在无需了解彼此的情况下进行通信，极大地提高了代码的模块化和可维护性。</p>
<h3 id="5-1-信号与槽的基本概念"><a href="#5-1-信号与槽的基本概念" class="headerlink" title="5.1 信号与槽的基本概念"></a>5.1 信号与槽的基本概念</h3><ul>
<li><p><strong>信号（Signal）</strong>：<br>当对象的状态发生变化时，会发出信号。信号是一个无参数或带参数的事件，表示某个特定事件的发生。</p>
</li>
<li><p><strong>槽（Slot）</strong>：<br>槽是一个可以接收信号的函数。当信号发出时，连接到该信号的槽函数会被自动调用，执行相应的操作。</p>
</li>
</ul>
<h3 id="5-2-信号与槽的连接"><a href="#5-2-信号与槽的连接" class="headerlink" title="5.2 信号与槽的连接"></a>5.2 信号与槽的连接</h3><p>在Qt中，信号与槽通过<code>QObject::connect</code>函数进行连接。连接后，当信号发出时，关联的槽函数会被自动调用。</p>
<h4 id="5-2-1-连接语法"><a href="#5-2-1-连接语法" class="headerlink" title="5.2.1 连接语法"></a>5.2.1 连接语法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QObject::<span class="built_in">connect</span>(sender, <span class="built_in">SIGNAL</span>(signalSignature), receiver, <span class="built_in">SLOT</span>(slotSignature));</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>sender</strong>：发出信号的对象。</li>
<li><strong>signalSignature</strong>：信号的签名（参数列表）。</li>
<li><strong>receiver</strong>：接收信号的对象。</li>
<li><strong>slotSignature</strong>：槽函数的签名。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">connect</span>(button, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>()), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">handleButton</span>()));</span><br></pre></td></tr></table></figure>

<h4 id="5-2-2-新的连接语法（基于函数指针）"><a href="#5-2-2-新的连接语法（基于函数指针）" class="headerlink" title="5.2.2 新的连接语法（基于函数指针）"></a>5.2.2 新的连接语法（基于函数指针）</h4><p>从Qt 5开始，推荐使用基于函数指针的连接语法，提供了类型安全和编译时检查。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">connect</span>(sender, &amp;SenderClass::signal, receiver, &amp;ReceiverClass::slot);</span><br></pre></td></tr></table></figure>

<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">connect</span>(button, &amp;QPushButton::clicked, <span class="keyword">this</span>, &amp;MainWindow::handleButton);</span><br></pre></td></tr></table></figure>

<h3 id="5-3-定义和实现信号与槽"><a href="#5-3-定义和实现信号与槽" class="headerlink" title="5.3 定义和实现信号与槽"></a>5.3 定义和实现信号与槽</h3><h4 id="5-3-1-定义信号和槽"><a href="#5-3-1-定义信号和槽" class="headerlink" title="5.3.1 定义信号和槽"></a>5.3.1 定义信号和槽</h4><p>在Qt中，信号和槽是通过<code>signals</code>和<code>slots</code>关键字在类中声明的。需要继承自<code>QObject</code>并使用<code>Q_OBJECT</code>宏。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLabel&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MainWindow</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mySignal</span><span class="params">(<span class="type">int</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleButton</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">updateLabel</span><span class="params">(<span class="type">int</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QPushButton *button;</span><br><span class="line">    QLabel *label;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="5-3-2-实现槽函数"><a href="#5-3-2-实现槽函数" class="headerlink" title="5.3.2 实现槽函数"></a>5.3.2 实现槽函数</h4><p>在类的实现文件中，实现槽函数和其他成员函数。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    button = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;点击我&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">    label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;初始文本&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">    label-&gt;<span class="built_in">move</span>(<span class="number">0</span>, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">connect</span>(button, &amp;QPushButton::clicked, <span class="keyword">this</span>, &amp;MainWindow::handleButton);</span><br><span class="line">    <span class="built_in">connect</span>(<span class="keyword">this</span>, &amp;MainWindow::mySignal, <span class="keyword">this</span>, &amp;MainWindow::updateLabel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::handleButton</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">emit <span class="title">mySignal</span><span class="params">(<span class="number">42</span>)</span></span>; <span class="comment">// 发出信号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::updateLabel</span><span class="params">(<span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    label-&gt;<span class="built_in">setText</span>(<span class="built_in">QString</span>(<span class="string">&quot;信号传递的值: %1&quot;</span>).<span class="built_in">arg</span>(value));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>当按钮被点击时，<code>handleButton</code>槽函数被调用，发出<code>mySignal</code>信号。</li>
<li><code>mySignal</code>信号携带一个整数参数<code>42</code>，被<code>updateLabel</code>槽函数接收并更新标签文本。</li>
</ul>
<h3 id="5-4-信号与槽的高级用法"><a href="#5-4-信号与槽的高级用法" class="headerlink" title="5.4 信号与槽的高级用法"></a>5.4 信号与槽的高级用法</h3><h4 id="5-4-1-带参数的信号与槽"><a href="#5-4-1-带参数的信号与槽" class="headerlink" title="5.4.1 带参数的信号与槽"></a>5.4.1 带参数的信号与槽</h4><p>信号和槽可以携带参数，实现更复杂的数据传递。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dataReceived</span><span class="params">(<span class="type">const</span> QString &amp;data)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">processData</span><span class="params">(<span class="type">const</span> QString &amp;data)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>连接与使用：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">connect</span>(sender, &amp;SenderClass::dataReceived, receiver, &amp;ReceiverClass::processData);</span><br></pre></td></tr></table></figure>

<h4 id="5-4-2-多个槽连接到同一个信号"><a href="#5-4-2-多个槽连接到同一个信号" class="headerlink" title="5.4.2 多个槽连接到同一个信号"></a>5.4.2 多个槽连接到同一个信号</h4><p>一个信号可以连接到多个槽函数，所有槽都会被依次调用。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">connect</span>(button, &amp;QPushButton::clicked, <span class="keyword">this</span>, &amp;MainWindow::slotOne);</span><br><span class="line"><span class="built_in">connect</span>(button, &amp;QPushButton::clicked, <span class="keyword">this</span>, &amp;MainWindow::slotTwo);</span><br></pre></td></tr></table></figure>

<h4 id="5-4-3-使用Lambda表达式作为槽"><a href="#5-4-3-使用Lambda表达式作为槽" class="headerlink" title="5.4.3 使用Lambda表达式作为槽"></a>5.4.3 使用Lambda表达式作为槽</h4><p>Qt允许使用lambda表达式作为槽函数，实现更灵活的信号处理。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">connect</span>(button, &amp;QPushButton::clicked, <span class="keyword">this</span>, [=]() &#123;</span><br><span class="line">    label-&gt;<span class="built_in">setText</span>(<span class="string">&quot;按钮被点击！&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="5-5-信号与槽的最佳实践"><a href="#5-5-信号与槽的最佳实践" class="headerlink" title="5.5 信号与槽的最佳实践"></a>5.5 信号与槽的最佳实践</h3><ol>
<li><strong>使用新的连接语法</strong>：基于函数指针的连接语法提供了类型安全，减少运行时错误。</li>
<li><strong>保持槽函数简洁</strong>：槽函数应专注于处理信号传递的数据，避免执行复杂的逻辑。</li>
<li><strong>避免循环引用</strong>：在对象间存在双向连接时，使用<code>QObject::deleteLater</code>或<code>weak_ptr</code>避免循环引用导致的内存泄漏。</li>
<li><strong>利用Lambda表达式</strong>：对于简单的信号处理逻辑，使用lambda表达式可以减少代码量，提高可读性。</li>
</ol>
<hr>
<h2 id="6-Qt字符串、数据类型与容器类"><a href="#6-Qt字符串、数据类型与容器类" class="headerlink" title="6. Qt字符串、数据类型与容器类"></a>6. Qt字符串、数据类型与容器类</h2><p>Qt提供了丰富的字符串类、数据类型和容器类，专为高效的跨平台开发设计。这些类在处理文本、数据存储和管理时，提供了强大的功能和便利性。</p>
<h3 id="6-1-QString类"><a href="#6-1-QString类" class="headerlink" title="6.1 QString类"></a>6.1 QString类</h3><p><code>QString</code>是Qt中用于处理Unicode字符串的类，提供了丰富的字符串操作功能。</p>
<h4 id="6-1-1-基本用法"><a href="#6-1-1-基本用法" class="headerlink" title="6.1.1 基本用法"></a>6.1.1 基本用法</h4><p><strong>示例：创建和操作QString</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QString&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建QString对象</span></span><br><span class="line">    QString str1 = <span class="string">&quot;Hello, Qt!&quot;</span>;</span><br><span class="line">    <span class="function">QString <span class="title">str2</span><span class="params">(<span class="string">&quot;C++11&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字符串拼接</span></span><br><span class="line">    QString combined = str1 + <span class="string">&quot; &quot;</span> + str2;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; combined; <span class="comment">// 输出: &quot;Hello, Qt! C++11&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字符串长度</span></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;字符串长度:&quot;</span> &lt;&lt; combined.<span class="built_in">length</span>(); <span class="comment">// 输出: 15</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找子字符串</span></span><br><span class="line">    <span class="type">int</span> index = combined.<span class="built_in">indexOf</span>(<span class="string">&quot;Qt&quot;</span>);</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Qt的位置:&quot;</span> &lt;&lt; index; <span class="comment">// 输出: 7</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 替换子字符串</span></span><br><span class="line">    combined.<span class="built_in">replace</span>(<span class="string">&quot;Qt&quot;</span>, <span class="string">&quot;Qt Framework&quot;</span>);</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; combined; <span class="comment">// 输出: &quot;Hello, Qt Framework C++11&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-1-2-常用函数"><a href="#6-1-2-常用函数" class="headerlink" title="6.1.2 常用函数"></a>6.1.2 常用函数</h4><ul>
<li>**toUpper() &#x2F; toLower()**：转换字符串为全大写或全小写。</li>
<li>**split()**：按指定分隔符分割字符串，返回<code>QStringList</code>。</li>
<li>**arg()**：格式化字符串，替换占位符。</li>
<li>**contains()**：检查字符串是否包含指定子字符串。</li>
<li>**startsWith() &#x2F; endsWith()**：检查字符串是否以指定子字符串开始或结束。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QString greeting = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; greeting.<span class="built_in">toUpper</span>(); <span class="comment">// 输出: &quot;HELLO, WORLD!&quot;</span></span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; greeting.<span class="built_in">toLower</span>(); <span class="comment">// 输出: &quot;hello, world!&quot;</span></span><br><span class="line"></span><br><span class="line">QStringList words = greeting.<span class="built_in">split</span>(<span class="string">&quot;, &quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">const</span> QString&amp; word : words) &#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; word;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// &quot;Hello&quot;</span></span><br><span class="line"><span class="comment">// &quot;World!&quot;</span></span><br><span class="line"></span><br><span class="line">QString templateStr = <span class="string">&quot;My name is %1 and I am %2 years old.&quot;</span>;</span><br><span class="line">QString name = <span class="string">&quot;Alice&quot;</span>;</span><br><span class="line"><span class="type">int</span> age = <span class="number">30</span>;</span><br><span class="line">QString formatted = templateStr.<span class="built_in">arg</span>(name).<span class="built_in">arg</span>(age);</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; formatted; <span class="comment">// 输出: &quot;My name is Alice and I am 30 years old.&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="6-2-QByteArray类"><a href="#6-2-QByteArray类" class="headerlink" title="6.2 QByteArray类"></a>6.2 QByteArray类</h3><p><code>QByteArray</code>用于处理字节数组，适用于二进制数据和原始数据处理。</p>
<h4 id="6-2-1-基本用法"><a href="#6-2-1-基本用法" class="headerlink" title="6.2.1 基本用法"></a>6.2.1 基本用法</h4><p><strong>示例：创建和操作QByteArray</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QByteArray&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建QByteArray对象</span></span><br><span class="line">    QByteArray byteArray1 = <span class="string">&quot;Hello, QByteArray!&quot;</span>;</span><br><span class="line">    <span class="function">QByteArray <span class="title">byteArray2</span><span class="params">(<span class="string">&quot;BinaryData&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字节数组拼接</span></span><br><span class="line">    QByteArray combined = byteArray1 + <span class="string">&quot; &quot;</span> + byteArray2;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; combined; <span class="comment">// 输出: &quot;Hello, QByteArray! BinaryData&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取字节数组长度</span></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;字节数组长度:&quot;</span> &lt;&lt; combined.<span class="built_in">size</span>(); <span class="comment">// 输出: 28</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找子字节数组</span></span><br><span class="line">    <span class="type">int</span> index = combined.<span class="built_in">indexOf</span>(<span class="string">&quot;QByteArray&quot;</span>);</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;QByteArray的位置:&quot;</span> &lt;&lt; index; <span class="comment">// 输出: 7</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 替换子字节数组</span></span><br><span class="line">    combined.<span class="built_in">replace</span>(<span class="string">&quot;QByteArray&quot;</span>, <span class="string">&quot;ByteArray&quot;</span>);</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; combined; <span class="comment">// 输出: &quot;Hello, ByteArray! BinaryData&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-2-2-常用函数"><a href="#6-2-2-常用函数" class="headerlink" title="6.2.2 常用函数"></a>6.2.2 常用函数</h4><ul>
<li>**append() &#x2F; prepend()**：在字节数组末尾或开头添加数据。</li>
<li>**mid()**：提取字节数组的一部分。</li>
<li>**left() &#x2F; right()**：提取字节数组左边或右边的一部分。</li>
<li>**toHex() &#x2F; fromHex()**：进行十六进制编码和解码。</li>
<li>**contains()**：检查字节数组是否包含指定子数组。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QByteArray data = <span class="string">&quot;SampleData&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加数据</span></span><br><span class="line">data.<span class="built_in">append</span>(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">data.<span class="built_in">prepend</span>(<span class="string">&quot;Start-&quot;</span>);</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; data; <span class="comment">// 输出: &quot;Start-SampleData123&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 提取中间部分</span></span><br><span class="line">QByteArray midData = data.<span class="built_in">mid</span>(<span class="number">6</span>, <span class="number">10</span>);</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; midData; <span class="comment">// 输出: &quot;SampleData&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 十六进制转换</span></span><br><span class="line">QByteArray hexData = data.<span class="built_in">toHex</span>();</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; hexData; <span class="comment">// 输出: &quot;53746172742d53616d706c6544617461313233&quot;</span></span><br><span class="line"></span><br><span class="line">QByteArray originalData = QByteArray::<span class="built_in">fromHex</span>(hexData);</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; originalData; <span class="comment">// 输出: &quot;Start-SampleData123&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="6-3-Qt容器类"><a href="#6-3-Qt容器类" class="headerlink" title="6.3 Qt容器类"></a>6.3 Qt容器类</h3><p>Qt提供了多种高效的容器类，用于存储和管理数据。这些容器类包括<code>QList</code>、<code>QVector</code>、<code>QMap</code>、<code>QHash</code>等，适用于不同的数据存储需求。</p>
<h4 id="6-3-1-QList类"><a href="#6-3-1-QList类" class="headerlink" title="6.3.1 QList类"></a>6.3.1 QList类</h4><p><code>QList</code>是一个泛型容器类，提供了列表（双向链表）数据结构，支持快速的插入和删除操作，适用于需要频繁修改数据的场景。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QList&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QString&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建QList对象</span></span><br><span class="line">    QList&lt;QString&gt; fruits;</span><br><span class="line">    fruits &lt;&lt; <span class="string">&quot;Apple&quot;</span> &lt;&lt; <span class="string">&quot;Banana&quot;</span> &lt;&lt; <span class="string">&quot;Cherry&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历QList</span></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;水果列表:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> QString&amp; fruit : fruits) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; fruit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    fruits.<span class="built_in">insert</span>(<span class="number">1</span>, <span class="string">&quot;Blueberry&quot;</span>);</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;插入后:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> QString&amp; fruit : fruits) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; fruit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除元素</span></span><br><span class="line">    fruits.<span class="built_in">removeAt</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;删除后:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> QString&amp; fruit : fruits) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; fruit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-3-2-QLinkedList类"><a href="#6-3-2-QLinkedList类" class="headerlink" title="6.3.2 QLinkedList类"></a>6.3.2 QLinkedList类</h4><p><code>QLinkedList</code>是一个双向链表容器，提供了与<code>QList</code>类似的接口，但在某些操作上性能更优，如在列表中间插入和删除元素。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLinkedList&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QString&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建QLinkedList对象</span></span><br><span class="line">    QLinkedList&lt;QString&gt; animals;</span><br><span class="line">    animals &lt;&lt; <span class="string">&quot;Cat&quot;</span> &lt;&lt; <span class="string">&quot;Dog&quot;</span> &lt;&lt; <span class="string">&quot;Elephant&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历QLinkedList</span></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;动物列表:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> QString&amp; animal : animals) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; animal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    animals.<span class="built_in">insert</span>(<span class="number">1</span>, <span class="string">&quot;Lion&quot;</span>);</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;插入后:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> QString&amp; animal : animals) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; animal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除元素</span></span><br><span class="line">    animals.<span class="built_in">removeOne</span>(<span class="string">&quot;Dog&quot;</span>);</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;删除后:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> QString&amp; animal : animals) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; animal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-3-3-QVector类"><a href="#6-3-3-QVector类" class="headerlink" title="6.3.3 QVector类"></a>6.3.3 QVector类</h4><p><code>QVector</code>是一个动态数组容器，提供了与<code>std::vector</code>类似的功能，支持快速的随机访问和高效的尾部插入操作，适用于需要频繁访问元素的场景。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QVector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QString&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建QVector对象</span></span><br><span class="line">    QVector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历QVector</span></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;数字列表:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> num : numbers) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加元素</span></span><br><span class="line">    numbers.<span class="built_in">append</span>(<span class="number">6</span>);</span><br><span class="line">    numbers.<span class="built_in">prepend</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;添加后:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> num : numbers) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改元素</span></span><br><span class="line">    numbers[<span class="number">3</span>] = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;修改后:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> num : numbers) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-3-4-QMap类与QHash类"><a href="#6-3-4-QMap类与QHash类" class="headerlink" title="6.3.4 QMap类与QHash类"></a>6.3.4 QMap类与QHash类</h4><p><code>QMap</code>和<code>QHash</code>是关联容器，用于存储键值对数据。其中，<code>QMap</code>基于红黑树实现，元素有序存储，适用于需要有序数据的场景；<code>QHash</code>基于哈希表实现，元素无序存储，提供更高的查找效率，适用于需要快速查找的场景。</p>
<p><strong>QMap示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMap&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QString&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建QMap对象</span></span><br><span class="line">    QMap&lt;QString, <span class="type">int</span>&gt; ageMap;</span><br><span class="line">    ageMap[<span class="string">&quot;Alice&quot;</span>] = <span class="number">30</span>;</span><br><span class="line">    ageMap[<span class="string">&quot;Bob&quot;</span>] = <span class="number">25</span>;</span><br><span class="line">    ageMap[<span class="string">&quot;Charlie&quot;</span>] = <span class="number">35</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历QMap</span></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;年龄映射:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = ageMap.<span class="built_in">begin</span>(); it != ageMap.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; it.<span class="built_in">key</span>() &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; it.<span class="built_in">value</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找元素</span></span><br><span class="line">    <span class="keyword">if</span>(ageMap.<span class="built_in">contains</span>(<span class="string">&quot;Bob&quot;</span>)) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Bob的年龄是&quot;</span> &lt;&lt; ageMap[<span class="string">&quot;Bob&quot;</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除元素</span></span><br><span class="line">    ageMap.<span class="built_in">remove</span>(<span class="string">&quot;Charlie&quot;</span>);</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;删除后:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = ageMap.<span class="built_in">begin</span>(); it != ageMap.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; it.<span class="built_in">key</span>() &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; it.<span class="built_in">value</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>QHash示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QHash&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QString&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建QHash对象</span></span><br><span class="line">    QHash&lt;QString, <span class="type">double</span>&gt; priceMap;</span><br><span class="line">    priceMap.<span class="built_in">insert</span>(<span class="string">&quot;Apple&quot;</span>, <span class="number">1.99</span>);</span><br><span class="line">    priceMap.<span class="built_in">insert</span>(<span class="string">&quot;Banana&quot;</span>, <span class="number">0.99</span>);</span><br><span class="line">    priceMap.<span class="built_in">insert</span>(<span class="string">&quot;Cherry&quot;</span>, <span class="number">2.99</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历QHash</span></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;价格映射:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = priceMap.<span class="built_in">begin</span>(); it != priceMap.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; it.<span class="built_in">key</span>() &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; it.<span class="built_in">value</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找元素</span></span><br><span class="line">    <span class="keyword">if</span>(priceMap.<span class="built_in">contains</span>(<span class="string">&quot;Cherry&quot;</span>)) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Cherry的价格是&quot;</span> &lt;&lt; priceMap.<span class="built_in">value</span>(<span class="string">&quot;Cherry&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除元素</span></span><br><span class="line">    priceMap.<span class="built_in">remove</span>(<span class="string">&quot;Banana&quot;</span>);</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;删除后:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = priceMap.<span class="built_in">begin</span>(); it != priceMap.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; it.<span class="built_in">key</span>() &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; it.<span class="built_in">value</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-4-QVariant类应用"><a href="#6-4-QVariant类应用" class="headerlink" title="6.4 QVariant类应用"></a>6.4 QVariant类应用</h3><p><code>QVariant</code>是Qt提供的一个通用数据类型，用于存储任意类型的数据。它类似于C++中的<code>std::variant</code>，但更早在Qt框架中得到广泛应用。<code>QVariant</code>在需要存储不同类型数据的场景中非常有用，如数据库操作、模型视图编程等。</p>
<h4 id="6-4-1-基本用法"><a href="#6-4-1-基本用法" class="headerlink" title="6.4.1 基本用法"></a>6.4.1 基本用法</h4><p><strong>示例：存储和转换不同类型的数据</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QVariant&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QString&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建QVariant对象并存储不同类型的数据</span></span><br><span class="line">    QVariant var1 = <span class="number">42</span>; <span class="comment">// 存储整数</span></span><br><span class="line">    QVariant var2 = <span class="number">3.14</span>; <span class="comment">// 存储浮点数</span></span><br><span class="line">    QVariant var3 = <span class="built_in">QString</span>(<span class="string">&quot;Hello, QVariant!&quot;</span>); <span class="comment">// 存储QString</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问和转换数据</span></span><br><span class="line">    <span class="keyword">if</span>(var1.<span class="built_in">canConvert</span>&lt;<span class="type">int</span>&gt;()) &#123;</span><br><span class="line">        <span class="type">int</span> intValue = var1.<span class="built_in">toInt</span>();</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;整数值:&quot;</span> &lt;&lt; intValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(var2.<span class="built_in">canConvert</span>&lt;<span class="type">double</span>&gt;()) &#123;</span><br><span class="line">        <span class="type">double</span> doubleValue = var2.<span class="built_in">toDouble</span>();</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;浮点数值:&quot;</span> &lt;&lt; doubleValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(var3.<span class="built_in">canConvert</span>&lt;QString&gt;()) &#123;</span><br><span class="line">        QString strValue = var3.<span class="built_in">toString</span>();</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;字符串值:&quot;</span> &lt;&lt; strValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// QVariant与自定义类型的结合</span></span><br><span class="line">    QVariant var4;</span><br><span class="line">    var4.<span class="built_in">setValue</span>(<span class="built_in">QPoint</span>(<span class="number">10</span>, <span class="number">20</span>)); <span class="comment">// 存储QPoint对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(var4.<span class="built_in">canConvert</span>&lt;QPoint&gt;()) &#123;</span><br><span class="line">        QPoint point = var4.<span class="built_in">value</span>&lt;QPoint&gt;();</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;QPoint:&quot;</span> &lt;&lt; point;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">整数值: 42</span><br><span class="line">浮点数值: 3.14</span><br><span class="line">字符串值: &quot;Hello, QVariant!&quot;</span><br><span class="line">QPoint: QPoint(10,20)</span><br></pre></td></tr></table></figure>

<h4 id="6-4-2-常用函数"><a href="#6-4-2-常用函数" class="headerlink" title="6.4.2 常用函数"></a>6.4.2 常用函数</h4><ul>
<li>**canConvert<T>()**：检查是否可以转换为指定类型。</li>
<li>**to<T>()**：转换为指定类型，类似于<code>static_cast</code>。</li>
<li>**value<T>()**：获取存储的值，类型为T。</li>
<li>**setValue()**：存储指定类型的值。</li>
<li>**typeName()**：获取当前存储值的类型名称。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QVariant var = <span class="string">&quot;Sample Text&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(var.<span class="built_in">canConvert</span>&lt;QString&gt;()) &#123;</span><br><span class="line">    QString text = var.<span class="built_in">toString</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;转换为QString:&quot;</span> &lt;&lt; text;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;存储类型:&quot;</span> &lt;&lt; var.<span class="built_in">typeName</span>(); <span class="comment">// 输出: &quot;QString&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="6-5-数据类型转换"><a href="#6-5-数据类型转换" class="headerlink" title="6.5 数据类型转换"></a>6.5 数据类型转换</h3><p>在Qt中，数据类型转换是常见操作，尤其是在不同类型的容器和函数之间传递数据时。Qt提供了丰富的转换函数，支持从一种类型到另一种类型的高效转换。</p>
<h4 id="6-5-1-基本转换"><a href="#6-5-1-基本转换" class="headerlink" title="6.5.1 基本转换"></a>6.5.1 基本转换</h4><p><strong>示例：QString与标准字符串的转换</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QString&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// QString转std::string</span></span><br><span class="line">    QString qstr = <span class="string">&quot;Hello, C++!&quot;</span>;</span><br><span class="line">    std::string stdStr = qstr.<span class="built_in">toStdString</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;std::string:&quot;</span> &lt;&lt; QString::<span class="built_in">fromStdString</span>(stdStr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// std::string转QString</span></span><br><span class="line">    std::string anotherStdStr = <span class="string">&quot;Hello, Qt!&quot;</span>;</span><br><span class="line">    QString anotherQStr = QString::<span class="built_in">fromStdString</span>(anotherStdStr);</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;QString:&quot;</span> &lt;&lt; anotherQStr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">std::string: &quot;Hello, C++!&quot;</span><br><span class="line">QString: &quot;Hello, Qt!&quot;</span><br></pre></td></tr></table></figure>

<h4 id="6-5-2-类型安全转换"><a href="#6-5-2-类型安全转换" class="headerlink" title="6.5.2 类型安全转换"></a>6.5.2 类型安全转换</h4><p>Qt推荐使用<code>QString::arg()</code>进行安全的字符串格式化，避免手动拼接字符串导致的错误。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QString templateStr = <span class="string">&quot;My name is %1 and I am %2 years old.&quot;</span>;</span><br><span class="line">QString name = <span class="string">&quot;Alice&quot;</span>;</span><br><span class="line"><span class="type">int</span> age = <span class="number">30</span>;</span><br><span class="line">QString formatted = templateStr.<span class="built_in">arg</span>(name).<span class="built_in">arg</span>(age);</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; formatted; <span class="comment">// 输出: &quot;My name is Alice and I am 30 years old.&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="6-5-3-数据类型的隐式转换"><a href="#6-5-3-数据类型的隐式转换" class="headerlink" title="6.5.3 数据类型的隐式转换"></a>6.5.3 数据类型的隐式转换</h4><p>Qt中的部分数据类型支持隐式转换，简化了代码编写。例如，<code>QVariant</code>支持隐式转换为常见类型。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QVariant var = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> value = var; <span class="comment">// 隐式转换为int</span></span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;值:&quot;</span> &lt;&lt; value;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">值: 100</span><br></pre></td></tr></table></figure>

<h3 id="6-6-常用容器类"><a href="#6-6-常用容器类" class="headerlink" title="6.6 常用容器类"></a>6.6 常用容器类</h3><p>Qt提供了多种容器类，用于存储和管理不同类型的数据。选择合适的容器类可以提升程序的性能和效率。</p>
<h4 id="6-6-1-QMap类与QHash类"><a href="#6-6-1-QMap类与QHash类" class="headerlink" title="6.6.1 QMap类与QHash类"></a>6.6.1 QMap类与QHash类</h4><p><code>QMap</code>和<code>QHash</code>用于存储键值对数据，具有不同的实现和性能特性。</p>
<ul>
<li><p><strong>QMap</strong>：</p>
<ul>
<li>基于红黑树实现，元素有序存储。</li>
<li>查找、插入和删除操作的时间复杂度为O(log n)。</li>
<li>适用于需要有序数据的场景。</li>
</ul>
</li>
<li><p><strong>QHash</strong>：</p>
<ul>
<li>基于哈希表实现，元素无序存储。</li>
<li>查找、插入和删除操作的平均时间复杂度为O(1)。</li>
<li>适用于需要快速查找的场景。</li>
</ul>
</li>
</ul>
<p><strong>示例：QMap与QHash的使用</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMap&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QHash&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QString&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用QMap</span></span><br><span class="line">    QMap&lt;QString, <span class="type">int</span>&gt; map;</span><br><span class="line">    map.<span class="built_in">insert</span>(<span class="string">&quot;One&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    map.<span class="built_in">insert</span>(<span class="string">&quot;Two&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    map.<span class="built_in">insert</span>(<span class="string">&quot;Three&quot;</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;QMap内容:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = map.<span class="built_in">begin</span>(); it != map.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; it.<span class="built_in">key</span>() &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; it.<span class="built_in">value</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用QHash</span></span><br><span class="line">    QHash&lt;QString, <span class="type">int</span>&gt; hash;</span><br><span class="line">    hash.<span class="built_in">insert</span>(<span class="string">&quot;One&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    hash.<span class="built_in">insert</span>(<span class="string">&quot;Two&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    hash.<span class="built_in">insert</span>(<span class="string">&quot;Three&quot;</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;QHash内容:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = hash.<span class="built_in">begin</span>(); it != hash.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; it.<span class="built_in">key</span>() &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; it.<span class="built_in">value</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">QMap内容:</span><br><span class="line">&quot;One&quot; : 1</span><br><span class="line">&quot;Three&quot; : 3</span><br><span class="line">&quot;Two&quot; : 2</span><br><span class="line">QHash内容:</span><br><span class="line">&quot;Three&quot; : 3</span><br><span class="line">&quot;One&quot; : 1</span><br><span class="line">&quot;Two&quot; : 2</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>QMap</code>中的元素按键有序存储。</li>
<li><code>QHash</code>中的元素无序存储，顺序可能不同。</li>
</ul>
<h4 id="6-6-2-QList类与QLinkedList类"><a href="#6-6-2-QList类与QLinkedList类" class="headerlink" title="6.6.2 QList类与QLinkedList类"></a>6.6.2 QList类与QLinkedList类</h4><p><code>QList</code>和<code>QLinkedList</code>都是列表容器，但在实现和性能上有所不同。</p>
<ul>
<li><p><strong>QList</strong>：</p>
<ul>
<li>基于动态数组实现，支持快速的随机访问。</li>
<li>在列表末尾的插入和删除操作效率高。</li>
<li>适用于需要频繁访问元素但不需要频繁中间插入和删除的场景。</li>
</ul>
</li>
<li><p><strong>QLinkedList</strong>：</p>
<ul>
<li>基于双向链表实现，支持高效的中间插入和删除操作。</li>
<li>不支持随机访问，遍历元素需要线性时间。</li>
<li>适用于需要频繁在列表中间插入和删除元素的场景。</li>
</ul>
</li>
</ul>
<p><strong>示例：QList与QLinkedList的对比</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QList&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLinkedList&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QString&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用QList</span></span><br><span class="line">    QList&lt;QString&gt; list;</span><br><span class="line">    list &lt;&lt; <span class="string">&quot;Apple&quot;</span> &lt;&lt; <span class="string">&quot;Banana&quot;</span> &lt;&lt; <span class="string">&quot;Cherry&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;QList内容:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> QString&amp; fruit : list) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; fruit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在QList中间插入元素</span></span><br><span class="line">    list.<span class="built_in">insert</span>(<span class="number">1</span>, <span class="string">&quot;Blueberry&quot;</span>);</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;QList插入后:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> QString&amp; fruit : list) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; fruit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用QLinkedList</span></span><br><span class="line">    QLinkedList&lt;QString&gt; linkedList;</span><br><span class="line">    linkedList &lt;&lt; <span class="string">&quot;Dog&quot;</span> &lt;&lt; <span class="string">&quot;Elephant&quot;</span> &lt;&lt; <span class="string">&quot;Frog&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;QLinkedList内容:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> QString&amp; animal : linkedList) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; animal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在QLinkedList中间插入元素</span></span><br><span class="line">    <span class="keyword">auto</span> it = linkedList.<span class="built_in">begin</span>();</span><br><span class="line">    std::<span class="built_in">advance</span>(it, <span class="number">1</span>);</span><br><span class="line">    linkedList.<span class="built_in">insert</span>(it, <span class="string">&quot;Lion&quot;</span>);</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;QLinkedList插入后:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> QString&amp; animal : linkedList) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; animal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">QList内容:</span><br><span class="line">&quot;Apple&quot;</span><br><span class="line">&quot;Banana&quot;</span><br><span class="line">&quot;Cherry&quot;</span><br><span class="line">QList插入后:</span><br><span class="line">&quot;Apple&quot;</span><br><span class="line">&quot;Blueberry&quot;</span><br><span class="line">&quot;Banana&quot;</span><br><span class="line">&quot;Cherry&quot;</span><br><span class="line">QLinkedList内容:</span><br><span class="line">&quot;Dog&quot;</span><br><span class="line">&quot;Elephant&quot;</span><br><span class="line">&quot;Frog&quot;</span><br><span class="line">QLinkedList插入后:</span><br><span class="line">&quot;Dog&quot;</span><br><span class="line">&quot;Lion&quot;</span><br><span class="line">&quot;Elephant&quot;</span><br><span class="line">&quot;Frog&quot;</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>QList</code>支持通过索引快速访问和插入元素。</li>
<li><code>QLinkedList</code>适用于在列表中间高效插入和删除元素，但不支持通过索引快速访问。</li>
</ul>
<h3 id="6-6-3-QVariant类的深入应用"><a href="#6-6-3-QVariant类的深入应用" class="headerlink" title="6.6.3 QVariant类的深入应用"></a>6.6.3 QVariant类的深入应用</h3><p><code>QVariant</code>作为一个通用数据类型，可以存储多种不同类型的数据，非常适合在不确定数据类型的场景下使用。</p>
<h4 id="6-6-3-1-存储和检索数据"><a href="#6-6-3-1-存储和检索数据" class="headerlink" title="6.6.3.1 存储和检索数据"></a>6.6.3.1 存储和检索数据</h4><p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QVariant&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QString&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    QVariant var1 = <span class="number">100</span>; <span class="comment">// 存储整数</span></span><br><span class="line">    QVariant var2 = <span class="number">3.14</span>; <span class="comment">// 存储浮点数</span></span><br><span class="line">    QVariant var3 = <span class="built_in">QString</span>(<span class="string">&quot;Qt Framework&quot;</span>); <span class="comment">// 存储QString</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查类型并转换</span></span><br><span class="line">    <span class="keyword">if</span>(var1.<span class="built_in">canConvert</span>&lt;<span class="type">int</span>&gt;()) &#123;</span><br><span class="line">        <span class="type">int</span> intValue = var1.<span class="built_in">toInt</span>();</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;整数值:&quot;</span> &lt;&lt; intValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(var2.<span class="built_in">canConvert</span>&lt;<span class="type">double</span>&gt;()) &#123;</span><br><span class="line">        <span class="type">double</span> doubleValue = var2.<span class="built_in">toDouble</span>();</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;浮点数值:&quot;</span> &lt;&lt; doubleValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(var3.<span class="built_in">canConvert</span>&lt;QString&gt;()) &#123;</span><br><span class="line">        QString strValue = var3.<span class="built_in">toString</span>();</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;字符串值:&quot;</span> &lt;&lt; strValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-6-3-2-使用QVariant与自定义类型"><a href="#6-6-3-2-使用QVariant与自定义类型" class="headerlink" title="6.6.3.2 使用QVariant与自定义类型"></a>6.6.3.2 使用QVariant与自定义类型</h4><p><code>QVariant</code>可以存储自定义类型，但需要使用<code>Q_DECLARE_METATYPE</code>进行声明。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QVariant&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QString&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明元类型</span></span><br><span class="line"><span class="built_in">Q_DECLARE_METATYPE</span>(Point)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册自定义类型</span></span><br><span class="line">    <span class="built_in">qRegisterMetaType</span>&lt;Point&gt;(<span class="string">&quot;Point&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储自定义类型到QVariant</span></span><br><span class="line">    Point p = &#123;<span class="number">10</span>, <span class="number">20</span>&#125;;</span><br><span class="line">    QVariant var;</span><br><span class="line">    var.<span class="built_in">setValue</span>(p);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查并提取自定义类型</span></span><br><span class="line">    <span class="keyword">if</span>(var.<span class="built_in">canConvert</span>&lt;Point&gt;()) &#123;</span><br><span class="line">        Point extracted = var.<span class="built_in">value</span>&lt;Point&gt;();</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Point:&quot;</span> &lt;&lt; extracted.x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; extracted.y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Point: 10 , 20</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>使用<code>Q_DECLARE_METATYPE</code>声明自定义类型，使其可以与<code>QVariant</code>配合使用。</li>
<li>使用<code>qRegisterMetaType</code>注册类型，确保在信号与槽等Qt机制中正常使用。</li>
</ul>
<hr>
<h2 id="7-字符串类应用与常见数据类型"><a href="#7-字符串类应用与常见数据类型" class="headerlink" title="7. 字符串类应用与常见数据类型"></a>7. 字符串类应用与常见数据类型</h2><p>在Qt开发中，字符串处理是非常常见的任务。Qt提供了<code>QString</code>和<code>QByteArray</code>等字符串类，这些类不仅支持Unicode字符，还提供了丰富的操作函数。除此之外，Qt还支持与标准C++数据类型之间的高效转换，使得在不同类型的数据处理之间切换更加便捷。</p>
<h3 id="7-1-QString类的高级应用"><a href="#7-1-QString类的高级应用" class="headerlink" title="7.1 QString类的高级应用"></a>7.1 QString类的高级应用</h3><p><code>QString</code>不仅支持基本的字符串操作，还提供了诸如正则表达式匹配、字符串分割与拼接、大小写转换等高级功能。</p>
<h4 id="7-1-1-正则表达式匹配"><a href="#7-1-1-正则表达式匹配" class="headerlink" title="7.1.1 正则表达式匹配"></a>7.1.1 正则表达式匹配</h4><p>利用<code>QString</code>与<code>QRegularExpression</code>结合，可以方便地进行复杂的字符串匹配和提取操作。</p>
<p><strong>示例：提取邮箱地址中的用户名</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QString&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QRegularExpression&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    QString email = <span class="string">&quot;user@example.com&quot;</span>;</span><br><span class="line">    <span class="function">QRegularExpression <span class="title">regex</span><span class="params">(<span class="string">R&quot;((\w+)@(\w+\.\w+))&quot;</span>)</span></span>;</span><br><span class="line">    QRegularExpressionMatch match = regex.<span class="built_in">match</span>(email);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(match.<span class="built_in">hasMatch</span>()) &#123;</span><br><span class="line">        QString username = match.<span class="built_in">captured</span>(<span class="number">1</span>);</span><br><span class="line">        QString domain = match.<span class="built_in">captured</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;用户名:&quot;</span> &lt;&lt; username;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;域名:&quot;</span> &lt;&lt; domain;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;无效的邮箱地址。&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用户名: &quot;user&quot;</span><br><span class="line">域名: &quot;example.com&quot;</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>QRegularExpression</code>定义了一个用于匹配邮箱地址的正则表达式。</li>
<li><code>regex.match(email)</code>用于匹配整个字符串。</li>
<li><code>captured(1)</code>和<code>captured(2)</code>分别提取匹配的用户名和域名。</li>
</ul>
<h4 id="7-1-2-字符串分割与拼接"><a href="#7-1-2-字符串分割与拼接" class="headerlink" title="7.1.2 字符串分割与拼接"></a>7.1.2 字符串分割与拼接</h4><p><code>QString</code>提供了方便的函数用于字符串的分割与拼接，极大地简化了文本处理工作。</p>
<p><strong>示例：分割CSV格式的字符串</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QString&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QStringList&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    QString csv = <span class="string">&quot;Apple,Banana,Cherry,Date&quot;</span>;</span><br><span class="line">    QStringList fruits = csv.<span class="built_in">split</span>(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;水果列表:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> QString&amp; fruit : fruits) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; fruit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">水果列表:</span><br><span class="line">&quot;Apple&quot;</span><br><span class="line">&quot;Banana&quot;</span><br><span class="line">&quot;Cherry&quot;</span><br><span class="line">&quot;Date&quot;</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>csv.split(&#39;,&#39;)</code>将字符串按逗号分割成多个子字符串，存储在<code>QStringList</code>中。</li>
<li>遍历<code>QStringList</code>，打印每个水果名称。</li>
</ul>
<h3 id="7-2-常见数据类型转换"><a href="#7-2-常见数据类型转换" class="headerlink" title="7.2 常见数据类型转换"></a>7.2 常见数据类型转换</h3><p>在Qt开发中，常常需要在不同的数据类型之间进行转换，如<code>QString</code>与<code>std::string</code>、<code>int</code>与<code>QString</code>之间的转换。Qt提供了丰富的函数来支持这些转换，确保数据处理的高效与安全。</p>
<h4 id="7-2-1-QString与std-string的转换"><a href="#7-2-1-QString与std-string的转换" class="headerlink" title="7.2.1 QString与std::string的转换"></a>7.2.1 QString与std::string的转换</h4><p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QString&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// QString转std::string</span></span><br><span class="line">    QString qstr = <span class="string">&quot;Hello, C++!&quot;</span>;</span><br><span class="line">    std::string stdStr = qstr.<span class="built_in">toStdString</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;std::string:&quot;</span> &lt;&lt; QString::<span class="built_in">fromStdString</span>(stdStr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// std::string转QString</span></span><br><span class="line">    std::string anotherStdStr = <span class="string">&quot;Hello, Qt!&quot;</span>;</span><br><span class="line">    QString anotherQStr = QString::<span class="built_in">fromStdString</span>(anotherStdStr);</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;QString:&quot;</span> &lt;&lt; anotherQStr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">std::string: &quot;Hello, C++!&quot;</span><br><span class="line">QString: &quot;Hello, Qt!&quot;</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>使用<code>QString::toStdString()</code>将<code>QString</code>转换为<code>std::string</code>。</li>
<li>使用<code>QString::fromStdString()</code>将<code>std::string</code>转换为<code>QString</code>。</li>
</ul>
<h4 id="7-2-2-QVariant与自定义类型的转换"><a href="#7-2-2-QVariant与自定义类型的转换" class="headerlink" title="7.2.2 QVariant与自定义类型的转换"></a>7.2.2 QVariant与自定义类型的转换</h4><p><code>QVariant</code>支持存储和转换多种数据类型，包括自定义类型。为了支持自定义类型，必须使用<code>Q_DECLARE_METATYPE</code>和<code>qRegisterMetaType</code>进行声明和注册。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QVariant&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QString&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明元类型</span></span><br><span class="line"><span class="built_in">Q_DECLARE_METATYPE</span>(Point)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册自定义类型</span></span><br><span class="line">    <span class="built_in">qRegisterMetaType</span>&lt;Point&gt;(<span class="string">&quot;Point&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储自定义类型到QVariant</span></span><br><span class="line">    Point p = &#123;<span class="number">10</span>, <span class="number">20</span>&#125;;</span><br><span class="line">    QVariant var;</span><br><span class="line">    var.<span class="built_in">setValue</span>(p);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查并提取自定义类型</span></span><br><span class="line">    <span class="keyword">if</span>(var.<span class="built_in">canConvert</span>&lt;Point&gt;()) &#123;</span><br><span class="line">        Point extracted = var.<span class="built_in">value</span>&lt;Point&gt;();</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Point:&quot;</span> &lt;&lt; extracted.x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; extracted.y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Point: 10 , 20</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>使用<code>Q_DECLARE_METATYPE(Point)</code>声明自定义类型。</li>
<li>使用<code>qRegisterMetaType&lt;Point&gt;(&quot;Point&quot;)</code>注册类型。</li>
<li><code>QVariant</code>能够存储和转换自定义类型<code>Point</code>。</li>
</ul>
<hr>
<h2 id="8-常用容器类"><a href="#8-常用容器类" class="headerlink" title="8. 常用容器类"></a>8. 常用容器类</h2><p>Qt提供了多种容器类，用于存储和管理不同类型的数据。选择合适的容器类可以显著提升程序的性能和代码的可维护性。以下将详细介绍Qt中常用的容器类，并讨论如何根据不同的需求选择合适的容器。</p>
<h3 id="8-1-QMap类、QHash类与QVector类"><a href="#8-1-QMap类、QHash类与QVector类" class="headerlink" title="8.1 QMap类、QHash类与QVector类"></a>8.1 QMap类、QHash类与QVector类</h3><h4 id="8-1-1-QMap类"><a href="#8-1-1-QMap类" class="headerlink" title="8.1.1 QMap类"></a>8.1.1 QMap类</h4><p><code>QMap</code>是一个基于红黑树实现的关联容器，存储键值对数据，键是有序的。它适用于需要有序存储和范围查找的场景。</p>
<p><strong>示例：存储学生成绩</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMap&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QString&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建QMap对象</span></span><br><span class="line">    QMap&lt;QString, <span class="type">int</span>&gt; studentScores;</span><br><span class="line">    studentScores.<span class="built_in">insert</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">90</span>);</span><br><span class="line">    studentScores.<span class="built_in">insert</span>(<span class="string">&quot;Bob&quot;</span>, <span class="number">85</span>);</span><br><span class="line">    studentScores.<span class="built_in">insert</span>(<span class="string">&quot;Charlie&quot;</span>, <span class="number">92</span>);</span><br><span class="line">    studentScores.<span class="built_in">insert</span>(<span class="string">&quot;Diana&quot;</span>, <span class="number">88</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历QMap</span></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;学生成绩:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = studentScores.<span class="built_in">begin</span>(); it != studentScores.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; it.<span class="built_in">key</span>() &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; it.<span class="built_in">value</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找学生成绩</span></span><br><span class="line">    QString name = <span class="string">&quot;Charlie&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(studentScores.<span class="built_in">contains</span>(name)) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; name &lt;&lt; <span class="string">&quot;的成绩是&quot;</span> &lt;&lt; studentScores.<span class="built_in">value</span>(name);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;未找到学生&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;的成绩。&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除学生成绩</span></span><br><span class="line">    studentScores.<span class="built_in">remove</span>(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;删除后:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = studentScores.<span class="built_in">begin</span>(); it != studentScores.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; it.<span class="built_in">key</span>() &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; it.<span class="built_in">value</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">学生成绩:</span><br><span class="line">&quot;Alice&quot; : 90</span><br><span class="line">&quot;Bob&quot; : 85</span><br><span class="line">&quot;Charlie&quot; : 92</span><br><span class="line">&quot;Diana&quot; : 88</span><br><span class="line">&quot;Charlie&quot; 的成绩是 92</span><br><span class="line">删除后:</span><br><span class="line">&quot;Alice&quot; : 90</span><br><span class="line">&quot;Charlie&quot; : 92</span><br><span class="line">&quot;Diana&quot; : 88</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>QMap</code>中的元素按键有序存储。</li>
<li>提供了高效的查找、插入和删除操作。</li>
</ul>
<h4 id="8-1-2-QHash类"><a href="#8-1-2-QHash类" class="headerlink" title="8.1.2 QHash类"></a>8.1.2 QHash类</h4><p><code>QHash</code>是一个基于哈希表实现的关联容器，存储键值对数据，键是无序的。它适用于需要快速查找的场景。</p>
<p><strong>示例：存储产品价格</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QHash&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QString&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建QHash对象</span></span><br><span class="line">    QHash&lt;QString, <span class="type">double</span>&gt; productPrices;</span><br><span class="line">    productPrices.<span class="built_in">insert</span>(<span class="string">&quot;Laptop&quot;</span>, <span class="number">999.99</span>);</span><br><span class="line">    productPrices.<span class="built_in">insert</span>(<span class="string">&quot;Smartphone&quot;</span>, <span class="number">499.49</span>);</span><br><span class="line">    productPrices.<span class="built_in">insert</span>(<span class="string">&quot;Tablet&quot;</span>, <span class="number">299.99</span>);</span><br><span class="line">    productPrices.<span class="built_in">insert</span>(<span class="string">&quot;Headphones&quot;</span>, <span class="number">89.99</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历QHash</span></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;产品价格:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = productPrices.<span class="built_in">begin</span>(); it != productPrices.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; it.<span class="built_in">key</span>() &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; it.<span class="built_in">value</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找产品价格</span></span><br><span class="line">    QString product = <span class="string">&quot;Tablet&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(productPrices.<span class="built_in">contains</span>(product)) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; product &lt;&lt; <span class="string">&quot;的价格是&quot;</span> &lt;&lt; productPrices.<span class="built_in">value</span>(product);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;未找到产品&quot;</span> &lt;&lt; product &lt;&lt; <span class="string">&quot;的价格。&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除产品价格</span></span><br><span class="line">    productPrices.<span class="built_in">remove</span>(<span class="string">&quot;Smartphone&quot;</span>);</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;删除后:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = productPrices.<span class="built_in">begin</span>(); it != productPrices.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; it.<span class="built_in">key</span>() &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; it.<span class="built_in">value</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">产品价格:</span><br><span class="line">&quot;Laptop&quot; : 999.99</span><br><span class="line">&quot;Smartphone&quot; : 499.49</span><br><span class="line">&quot;Tablet&quot; : 299.99</span><br><span class="line">&quot;Headphones&quot; : 89.99</span><br><span class="line">&quot;Tablet&quot; 的价格是 299.99</span><br><span class="line">删除后:</span><br><span class="line">&quot;Laptop&quot; : 999.99</span><br><span class="line">&quot;Tablet&quot; : 299.99</span><br><span class="line">&quot;Headphones&quot; : 89.99</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>QHash</code>中的元素无序存储，但查找速度更快。</li>
<li>适用于需要快速查找但不关心元素顺序的场景。</li>
</ul>
<h4 id="8-1-3-QVector类"><a href="#8-1-3-QVector类" class="headerlink" title="8.1.3 QVector类"></a>8.1.3 QVector类</h4><p><code>QVector</code>是一个动态数组容器，提供了类似于<code>std::vector</code>的功能。它支持快速的随机访问和高效的尾部插入操作，适用于需要频繁访问元素的场景。</p>
<p><strong>示例：存储传感器数据</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QVector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建QVector对象</span></span><br><span class="line">    QVector&lt;<span class="type">double</span>&gt; sensorData;</span><br><span class="line">    sensorData &lt;&lt; <span class="number">23.5</span> &lt;&lt; <span class="number">24.0</span> &lt;&lt; <span class="number">22.8</span> &lt;&lt; <span class="number">25.1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历QVector</span></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;传感器数据:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">double</span> data : sensorData) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加新数据</span></span><br><span class="line">    sensorData.<span class="built_in">append</span>(<span class="number">24.3</span>);</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;添加后:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">double</span> data : sensorData) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改数据</span></span><br><span class="line">    sensorData[<span class="number">2</span>] = <span class="number">23.0</span>;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;修改后:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">double</span> data : sensorData) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">传感器数据:</span><br><span class="line">23.5</span><br><span class="line">24</span><br><span class="line">22.8</span><br><span class="line">25.1</span><br><span class="line">添加后:</span><br><span class="line">23.5</span><br><span class="line">24</span><br><span class="line">22.8</span><br><span class="line">25.1</span><br><span class="line">24.3</span><br><span class="line">修改后:</span><br><span class="line">23.5</span><br><span class="line">24</span><br><span class="line">23</span><br><span class="line">25.1</span><br><span class="line">24.3</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>QVector</code>支持通过索引快速访问和修改元素。</li>
<li>提供高效的尾部插入操作，适用于需要频繁添加元素的场景。</li>
</ul>
<h3 id="8-2-QList类与QLinkedList类"><a href="#8-2-QList类与QLinkedList类" class="headerlink" title="8.2 QList类与QLinkedList类"></a>8.2 QList类与QLinkedList类</h3><p><code>QList</code>和<code>QLinkedList</code>都是Qt中提供的列表容器，但它们在内部实现和性能特性上有所不同，适用于不同的使用场景。</p>
<h4 id="8-2-1-QList类"><a href="#8-2-1-QList类" class="headerlink" title="8.2.1 QList类"></a>8.2.1 QList类</h4><p><code>QList</code>基于动态数组实现，支持快速的随机访问和高效的尾部插入操作，但在列表中间插入和删除元素时性能较低。</p>
<p><strong>适用场景：</strong></p>
<ul>
<li>需要频繁随机访问元素。</li>
<li>不需要频繁在列表中间插入或删除元素。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QList&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QString&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建QList对象</span></span><br><span class="line">    QList&lt;QString&gt; fruitList;</span><br><span class="line">    fruitList &lt;&lt; <span class="string">&quot;Apple&quot;</span> &lt;&lt; <span class="string">&quot;Banana&quot;</span> &lt;&lt; <span class="string">&quot;Cherry&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历QList</span></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;水果列表:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> QString&amp; fruit : fruitList) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; fruit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    fruitList.<span class="built_in">insert</span>(<span class="number">1</span>, <span class="string">&quot;Blueberry&quot;</span>);</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;插入后:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> QString&amp; fruit : fruitList) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; fruit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除元素</span></span><br><span class="line">    fruitList.<span class="built_in">removeAt</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;删除后:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> QString&amp; fruit : fruitList) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; fruit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">水果列表:</span><br><span class="line">&quot;Apple&quot;</span><br><span class="line">&quot;Banana&quot;</span><br><span class="line">&quot;Cherry&quot;</span><br><span class="line">插入后:</span><br><span class="line">&quot;Apple&quot;</span><br><span class="line">&quot;Blueberry&quot;</span><br><span class="line">&quot;Banana&quot;</span><br><span class="line">&quot;Cherry&quot;</span><br><span class="line">删除后:</span><br><span class="line">&quot;Apple&quot;</span><br><span class="line">&quot;Blueberry&quot;</span><br><span class="line">&quot;Cherry&quot;</span><br></pre></td></tr></table></figure>

<h4 id="8-2-2-QLinkedList类"><a href="#8-2-2-QLinkedList类" class="headerlink" title="8.2.2 QLinkedList类"></a>8.2.2 QLinkedList类</h4><p><code>QLinkedList</code>基于双向链表实现，支持高效的中间插入和删除操作，但不支持快速的随机访问。</p>
<p><strong>适用场景：</strong></p>
<ul>
<li>需要频繁在列表中间插入或删除元素。</li>
<li>不需要频繁随机访问元素。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLinkedList&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QString&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建QLinkedList对象</span></span><br><span class="line">    QLinkedList&lt;QString&gt; animalList;</span><br><span class="line">    animalList &lt;&lt; <span class="string">&quot;Dog&quot;</span> &lt;&lt; <span class="string">&quot;Elephant&quot;</span> &lt;&lt; <span class="string">&quot;Frog&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历QLinkedList</span></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;动物列表:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> QString&amp; animal : animalList) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; animal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    <span class="keyword">auto</span> it = animalList.<span class="built_in">begin</span>();</span><br><span class="line">    std::<span class="built_in">advance</span>(it, <span class="number">1</span>);</span><br><span class="line">    animalList.<span class="built_in">insert</span>(it, <span class="string">&quot;Lion&quot;</span>);</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;插入后:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> QString&amp; animal : animalList) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; animal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除元素</span></span><br><span class="line">    animalList.<span class="built_in">removeOne</span>(<span class="string">&quot;Elephant&quot;</span>);</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;删除后:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> QString&amp; animal : animalList) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; animal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">动物列表:</span><br><span class="line">&quot;Dog&quot;</span><br><span class="line">&quot;Elephant&quot;</span><br><span class="line">&quot;Frog&quot;</span><br><span class="line">插入后:</span><br><span class="line">&quot;Dog&quot;</span><br><span class="line">&quot;Lion&quot;</span><br><span class="line">&quot;Elephant&quot;</span><br><span class="line">&quot;Frog&quot;</span><br><span class="line">删除后:</span><br><span class="line">&quot;Dog&quot;</span><br><span class="line">&quot;Lion&quot;</span><br><span class="line">&quot;Frog&quot;</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>QLinkedList</code>允许在列表中间高效地插入和删除元素。</li>
<li>不支持通过索引快速访问元素，适用于需要频繁修改列表内容的场景。</li>
</ul>
<h3 id="8-3-QString与QByteArray的对比与选择"><a href="#8-3-QString与QByteArray的对比与选择" class="headerlink" title="8.3 QString与QByteArray的对比与选择"></a>8.3 QString与QByteArray的对比与选择</h3><p>在Qt中，<code>QString</code>和<code>QByteArray</code>都是处理字符串数据的重要类，但它们适用于不同的应用场景。</p>
<ul>
<li><p><strong>QString</strong>：</p>
<ul>
<li>用于处理Unicode文本。</li>
<li>支持丰富的文本操作，如查找、替换、格式化等。</li>
<li>适用于需要处理和显示文本数据的场景。</li>
</ul>
</li>
<li><p><strong>QByteArray</strong>：</p>
<ul>
<li>用于处理原始字节数据。</li>
<li>支持高效的二进制数据操作，如读写文件、网络传输等。</li>
<li>适用于需要处理二进制数据或编码转换的场景。</li>
</ul>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QString&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QByteArray&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用QString处理文本</span></span><br><span class="line">    QString text = <span class="string">&quot;Hello, Qt!&quot;</span>;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;QString内容:&quot;</span> &lt;&lt; text;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;大写:&quot;</span> &lt;&lt; text.<span class="built_in">toUpper</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用QByteArray处理二进制数据</span></span><br><span class="line">    QByteArray byteData = <span class="string">&quot;BinaryData&quot;</span>;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;QByteArray内容:&quot;</span> &lt;&lt; byteData;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;十六进制:&quot;</span> &lt;&lt; byteData.<span class="built_in">toHex</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">QString内容: &quot;Hello, Qt!&quot;</span><br><span class="line">大写: &quot;HELLO, QT!&quot;</span><br><span class="line">QByteArray内容: &quot;BinaryData&quot;</span><br><span class="line">十六进制: &quot;42696e61727944617461&quot;</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>QString</code>适合用于显示和处理文本数据。</li>
<li><code>QByteArray</code>适合用于处理原始字节数据和进行编码转换。</li>
</ul>
<hr>
<h2 id="9-QMap类、QHash类与QVector类的深入探讨"><a href="#9-QMap类、QHash类与QVector类的深入探讨" class="headerlink" title="9. QMap类、QHash类与QVector类的深入探讨"></a>9. QMap类、QHash类与QVector类的深入探讨</h2><p>在Qt中，<code>QMap</code>、<code>QHash</code>和<code>QVector</code>是三种常用的容器类，它们各自有不同的特点和适用场景。理解它们的内部实现和性能特性，有助于在实际项目中选择最合适的容器。</p>
<h3 id="9-1-QMap类"><a href="#9-1-QMap类" class="headerlink" title="9.1 QMap类"></a>9.1 QMap类</h3><p><code>QMap</code>基于红黑树实现，提供了有序的键值对存储。它的主要特点包括：</p>
<ul>
<li><strong>有序存储</strong>：元素按键的升序排列。</li>
<li><strong>高效查找</strong>：查找、插入和删除操作的时间复杂度为O(log n)。</li>
<li><strong>支持范围操作</strong>：可以高效地进行范围查找和迭代。</li>
</ul>
<p><strong>使用场景：</strong></p>
<ul>
<li>需要有序存储和按键范围查询。</li>
<li>需要按键顺序遍历元素。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMap&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QString&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建QMap对象</span></span><br><span class="line">    QMap&lt;QString, <span class="type">int</span>&gt; employeeAges;</span><br><span class="line">    employeeAges.<span class="built_in">insert</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>);</span><br><span class="line">    employeeAges.<span class="built_in">insert</span>(<span class="string">&quot;Bob&quot;</span>, <span class="number">25</span>);</span><br><span class="line">    employeeAges.<span class="built_in">insert</span>(<span class="string">&quot;Charlie&quot;</span>, <span class="number">35</span>);</span><br><span class="line">    employeeAges.<span class="built_in">insert</span>(<span class="string">&quot;Diana&quot;</span>, <span class="number">28</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历QMap</span></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;员工年龄:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = employeeAges.<span class="built_in">begin</span>(); it != employeeAges.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; it.<span class="built_in">key</span>() &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; it.<span class="built_in">value</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找员工年龄</span></span><br><span class="line">    QString name = <span class="string">&quot;Charlie&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(employeeAges.<span class="built_in">contains</span>(name)) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; name &lt;&lt; <span class="string">&quot;的年龄是&quot;</span> &lt;&lt; employeeAges.<span class="built_in">value</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除员工</span></span><br><span class="line">    employeeAges.<span class="built_in">remove</span>(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;删除后:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = employeeAges.<span class="built_in">begin</span>(); it != employeeAges.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; it.<span class="built_in">key</span>() &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; it.<span class="built_in">value</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 范围查找</span></span><br><span class="line">    QMap&lt;QString, <span class="type">int</span>&gt;::const_iterator rangeStart = employeeAges.<span class="built_in">find</span>(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">    QMap&lt;QString, <span class="type">int</span>&gt;::const_iterator rangeEnd = employeeAges.<span class="built_in">find</span>(<span class="string">&quot;Charlie&quot;</span>);</span><br><span class="line">    QMap&lt;QString, <span class="type">int</span>&gt; rangeMap = employeeAges.<span class="built_in">mid</span>(rangeStart.<span class="built_in">key</span>(), rangeEnd.<span class="built_in">key</span>());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;范围查找 (Alice - Charlie):&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = rangeMap.<span class="built_in">begin</span>(); it != rangeMap.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; it.<span class="built_in">key</span>() &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; it.<span class="built_in">value</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">员工年龄:</span><br><span class="line">&quot;Alice&quot; : 30</span><br><span class="line">&quot;Bob&quot; : 25</span><br><span class="line">&quot;Charlie&quot; : 35</span><br><span class="line">&quot;Diana&quot; : 28</span><br><span class="line">&quot;Charlie&quot; 的年龄是 35</span><br><span class="line">删除后:</span><br><span class="line">&quot;Alice&quot; : 30</span><br><span class="line">&quot;Charlie&quot; : 35</span><br><span class="line">&quot;Diana&quot; : 28</span><br><span class="line">范围查找 (Alice - Charlie):</span><br><span class="line">&quot;Alice&quot; : 30</span><br><span class="line">&quot;Charlie&quot; : 35</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>QMap</code>中的元素按键有序存储，便于有序遍历和范围查找。</li>
<li>使用<code>mid()</code>函数可以高效地提取键的范围内的子集。</li>
</ul>
<h3 id="9-2-QHash类"><a href="#9-2-QHash类" class="headerlink" title="9.2 QHash类"></a>9.2 QHash类</h3><p><code>QHash</code>基于哈希表实现，提供了无序的键值对存储。它的主要特点包括：</p>
<ul>
<li><strong>无序存储</strong>：元素的存储顺序与插入顺序无关。</li>
<li><strong>高效查找</strong>：查找、插入和删除操作的平均时间复杂度为O(1)。</li>
<li><strong>灵活性</strong>：适用于需要快速查找的场景，但不关心元素的顺序。</li>
</ul>
<p><strong>使用场景：</strong></p>
<ul>
<li>需要快速查找和访问元素。</li>
<li>不需要有序存储和遍历。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QHash&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QString&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建QHash对象</span></span><br><span class="line">    QHash&lt;QString, <span class="type">double</span>&gt; productPrices;</span><br><span class="line">    productPrices.<span class="built_in">insert</span>(<span class="string">&quot;Laptop&quot;</span>, <span class="number">999.99</span>);</span><br><span class="line">    productPrices.<span class="built_in">insert</span>(<span class="string">&quot;Smartphone&quot;</span>, <span class="number">499.49</span>);</span><br><span class="line">    productPrices.<span class="built_in">insert</span>(<span class="string">&quot;Tablet&quot;</span>, <span class="number">299.99</span>);</span><br><span class="line">    productPrices.<span class="built_in">insert</span>(<span class="string">&quot;Headphones&quot;</span>, <span class="number">89.99</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历QHash</span></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;产品价格:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = productPrices.<span class="built_in">begin</span>(); it != productPrices.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; it.<span class="built_in">key</span>() &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; it.<span class="built_in">value</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找产品价格</span></span><br><span class="line">    QString product = <span class="string">&quot;Tablet&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(productPrices.<span class="built_in">contains</span>(product)) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; product &lt;&lt; <span class="string">&quot;的价格是&quot;</span> &lt;&lt; productPrices.<span class="built_in">value</span>(product);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除产品</span></span><br><span class="line">    productPrices.<span class="built_in">remove</span>(<span class="string">&quot;Smartphone&quot;</span>);</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;删除后:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = productPrices.<span class="built_in">begin</span>(); it != productPrices.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; it.<span class="built_in">key</span>() &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; it.<span class="built_in">value</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">产品价格:</span><br><span class="line">&quot;Laptop&quot; : 999.99</span><br><span class="line">&quot;Smartphone&quot; : 499.49</span><br><span class="line">&quot;Tablet&quot; : 299.99</span><br><span class="line">&quot;Headphones&quot; : 89.99</span><br><span class="line">&quot;Tablet&quot; 的价格是 299.99</span><br><span class="line">删除后:</span><br><span class="line">&quot;Laptop&quot; : 999.99</span><br><span class="line">&quot;Tablet&quot; : 299.99</span><br><span class="line">&quot;Headphones&quot; : 89.99</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>QHash</code>提供了快速的查找和访问功能，适用于不需要有序存储的场景。</li>
<li>元素的存储顺序与插入顺序无关，但查找效率更高。</li>
</ul>
<h3 id="9-3-QVector类"><a href="#9-3-QVector类" class="headerlink" title="9.3 QVector类"></a>9.3 QVector类</h3><p><code>QVector</code>是一个动态数组容器，提供了类似于<code>std::vector</code>的功能，支持快速的随机访问和高效的尾部插入操作。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QVector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QString&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建QVector对象</span></span><br><span class="line">    QVector&lt;<span class="type">int</span>&gt; numbers;</span><br><span class="line">    numbers &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="number">2</span> &lt;&lt; <span class="number">3</span> &lt;&lt; <span class="number">4</span> &lt;&lt; <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历QVector</span></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;数字列表:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> num : numbers) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加元素</span></span><br><span class="line">    numbers.<span class="built_in">append</span>(<span class="number">6</span>);</span><br><span class="line">    numbers.<span class="built_in">prepend</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;添加后:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> num : numbers) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改元素</span></span><br><span class="line">    numbers[<span class="number">3</span>] = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;修改后:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> num : numbers) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数字列表:</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">添加后:</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">修改后:</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">10</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>QVector</code>支持通过索引快速访问和修改元素，适用于需要频繁访问元素的场景。</li>
<li>提供高效的尾部插入操作，适合动态数组的应用需求。</li>
</ul>
<hr>
<h2 id="10-QList类与QLinkedList类的比较"><a href="#10-QList类与QLinkedList类的比较" class="headerlink" title="10. QList类与QLinkedList类的比较"></a>10. QList类与QLinkedList类的比较</h2><p><code>QList</code>和<code>QLinkedList</code>都是Qt中提供的列表容器，但它们在内部实现和性能特性上有所不同，适用于不同的使用场景。理解它们的区别有助于在实际开发中选择最合适的容器。</p>
<h3 id="10-1-QList类"><a href="#10-1-QList类" class="headerlink" title="10.1 QList类"></a>10.1 QList类</h3><p><code>QList</code>基于动态数组实现，提供了快速的随机访问和高效的尾部插入操作。但在列表中间插入和删除元素时，性能较低，因为需要移动元素。</p>
<p><strong>适用场景：</strong></p>
<ul>
<li>需要频繁随机访问元素。</li>
<li>不需要频繁在列表中间插入或删除元素。</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>快速的随机访问（O(1)时间复杂度）。</li>
<li>高效的尾部插入和删除操作。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>在列表中间插入或删除元素时，性能较低（O(n)时间复杂度）。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QList&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QString&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建QList对象</span></span><br><span class="line">    QList&lt;QString&gt; list;</span><br><span class="line">    list &lt;&lt; <span class="string">&quot;Apple&quot;</span> &lt;&lt; <span class="string">&quot;Banana&quot;</span> &lt;&lt; <span class="string">&quot;Cherry&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历QList</span></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;QList内容:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> QString&amp; fruit : list) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; fruit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    list.<span class="built_in">insert</span>(<span class="number">1</span>, <span class="string">&quot;Blueberry&quot;</span>);</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;插入后:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> QString&amp; fruit : list) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; fruit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除元素</span></span><br><span class="line">    list.<span class="built_in">removeAt</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;删除后:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> QString&amp; fruit : list) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; fruit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">QList内容:</span><br><span class="line">&quot;Apple&quot;</span><br><span class="line">&quot;Banana&quot;</span><br><span class="line">&quot;Cherry&quot;</span><br><span class="line">插入后:</span><br><span class="line">&quot;Apple&quot;</span><br><span class="line">&quot;Blueberry&quot;</span><br><span class="line">&quot;Banana&quot;</span><br><span class="line">&quot;Cherry&quot;</span><br><span class="line">删除后:</span><br><span class="line">&quot;Apple&quot;</span><br><span class="line">&quot;Blueberry&quot;</span><br><span class="line">&quot;Cherry&quot;</span><br></pre></td></tr></table></figure>

<h3 id="10-2-QLinkedList类"><a href="#10-2-QLinkedList类" class="headerlink" title="10.2 QLinkedList类"></a>10.2 QLinkedList类</h3><p><code>QLinkedList</code>基于双向链表实现，支持高效的中间插入和删除操作，但不支持快速的随机访问。每次访问元素都需要从头或尾部开始遍历。</p>
<p><strong>适用场景：</strong></p>
<ul>
<li>需要频繁在列表中间插入或删除元素。</li>
<li>不需要频繁随机访问元素。</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>高效的中间插入和删除操作（O(1)时间复杂度）。</li>
<li>不需要移动元素，适合链表结构。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>不支持快速的随机访问（O(n)时间复杂度）。</li>
<li>较高的内存开销，因为每个元素需要存储前后指针。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLinkedList&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QString&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建QLinkedList对象</span></span><br><span class="line">    QLinkedList&lt;QString&gt; linkedList;</span><br><span class="line">    linkedList &lt;&lt; <span class="string">&quot;Dog&quot;</span> &lt;&lt; <span class="string">&quot;Elephant&quot;</span> &lt;&lt; <span class="string">&quot;Frog&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历QLinkedList</span></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;QLinkedList内容:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> QString&amp; animal : linkedList) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; animal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    <span class="keyword">auto</span> it = linkedList.<span class="built_in">begin</span>();</span><br><span class="line">    std::<span class="built_in">advance</span>(it, <span class="number">1</span>);</span><br><span class="line">    linkedList.<span class="built_in">insert</span>(it, <span class="string">&quot;Lion&quot;</span>);</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;插入后:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> QString&amp; animal : linkedList) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; animal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除元素</span></span><br><span class="line">    linkedList.<span class="built_in">removeOne</span>(<span class="string">&quot;Elephant&quot;</span>);</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;删除后:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> QString&amp; animal : linkedList) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; animal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">QLinkedList内容:</span><br><span class="line">&quot;Dog&quot;</span><br><span class="line">&quot;Elephant&quot;</span><br><span class="line">&quot;Frog&quot;</span><br><span class="line">插入后:</span><br><span class="line">&quot;Dog&quot;</span><br><span class="line">&quot;Lion&quot;</span><br><span class="line">&quot;Elephant&quot;</span><br><span class="line">&quot;Frog&quot;</span><br><span class="line">删除后:</span><br><span class="line">&quot;Dog&quot;</span><br><span class="line">&quot;Lion&quot;</span><br><span class="line">&quot;Frog&quot;</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>QLinkedList</code>允许在列表中间高效地插入和删除元素。</li>
<li>不支持通过索引快速访问元素，适用于需要频繁修改列表内容的场景。</li>
</ul>
<h3 id="10-3-选择合适的容器类"><a href="#10-3-选择合适的容器类" class="headerlink" title="10.3 选择合适的容器类"></a>10.3 选择合适的容器类</h3><p>在选择Qt容器类时，应根据具体的应用需求和操作特性进行选择：</p>
<ul>
<li><strong>需要快速随机访问</strong>：选择<code>QVector</code>或<code>QList</code>。</li>
<li><strong>需要频繁中间插入和删除</strong>：选择<code>QLinkedList</code>。</li>
<li><strong>需要有序键值对存储</strong>：选择<code>QMap</code>。</li>
<li><strong>需要快速查找无序键值对存储</strong>：选择<code>QHash</code>。</li>
</ul>
<p>了解各个容器类的内部实现和性能特性，有助于在项目中做出最佳的容器选择，提升程序的整体性能和效率。</p>
<hr>
<h2 id="11-QVariant类应用"><a href="#11-QVariant类应用" class="headerlink" title="11. QVariant类应用"></a>11. QVariant类应用</h2><p><code>QVariant</code>是Qt提供的一个通用数据类型，能够存储多种不同类型的数据。它类似于C++中的<code>std::variant</code>，但更早在Qt框架中得到广泛应用。<code>QVariant</code>在需要存储不同类型数据的场景中非常有用，如数据库操作、模型视图编程等。</p>
<h3 id="11-1-QVariant的基本用法"><a href="#11-1-QVariant的基本用法" class="headerlink" title="11.1 QVariant的基本用法"></a>11.1 QVariant的基本用法</h3><p><code>QVariant</code>可以存储多种类型的数据，并提供了便捷的类型转换方法。</p>
<p><strong>示例：存储和转换不同类型的数据</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QVariant&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QString&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建QVariant对象并存储不同类型的数据</span></span><br><span class="line">    QVariant var1 = <span class="number">42</span>; <span class="comment">// 存储整数</span></span><br><span class="line">    QVariant var2 = <span class="number">3.14</span>; <span class="comment">// 存储浮点数</span></span><br><span class="line">    QVariant var3 = <span class="built_in">QString</span>(<span class="string">&quot;Hello, QVariant!&quot;</span>); <span class="comment">// 存储QString</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问和转换数据</span></span><br><span class="line">    <span class="keyword">if</span>(var1.<span class="built_in">canConvert</span>&lt;<span class="type">int</span>&gt;()) &#123;</span><br><span class="line">        <span class="type">int</span> intValue = var1.<span class="built_in">toInt</span>();</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;整数值:&quot;</span> &lt;&lt; intValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(var2.<span class="built_in">canConvert</span>&lt;<span class="type">double</span>&gt;()) &#123;</span><br><span class="line">        <span class="type">double</span> doubleValue = var2.<span class="built_in">toDouble</span>();</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;浮点数值:&quot;</span> &lt;&lt; doubleValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(var3.<span class="built_in">canConvert</span>&lt;QString&gt;()) &#123;</span><br><span class="line">        QString strValue = var3.<span class="built_in">toString</span>();</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;字符串值:&quot;</span> &lt;&lt; strValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">整数值: 42</span><br><span class="line">浮点数值: 3.14</span><br><span class="line">字符串值: &quot;Hello, QVariant!&quot;</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>QVariant</code>能够存储多种类型的数据，如整数、浮点数和<code>QString</code>。</li>
<li>使用<code>canConvert&lt;T&gt;()</code>方法检查是否可以转换为指定类型，使用<code>to&lt;T&gt;()</code>方法进行类型转换。</li>
</ul>
<h3 id="11-2-QVariant与自定义类型的结合"><a href="#11-2-QVariant与自定义类型的结合" class="headerlink" title="11.2 QVariant与自定义类型的结合"></a>11.2 QVariant与自定义类型的结合</h3><p><code>QVariant</code>支持存储自定义类型，但需要进行相应的声明和注册。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QVariant&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QString&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明元类型</span></span><br><span class="line"><span class="built_in">Q_DECLARE_METATYPE</span>(Point)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册自定义类型</span></span><br><span class="line">    <span class="built_in">qRegisterMetaType</span>&lt;Point&gt;(<span class="string">&quot;Point&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储自定义类型到QVariant</span></span><br><span class="line">    Point p = &#123;<span class="number">10</span>, <span class="number">20</span>&#125;;</span><br><span class="line">    QVariant var;</span><br><span class="line">    var.<span class="built_in">setValue</span>(p);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查并提取自定义类型</span></span><br><span class="line">    <span class="keyword">if</span>(var.<span class="built_in">canConvert</span>&lt;Point&gt;()) &#123;</span><br><span class="line">        Point extracted = var.<span class="built_in">value</span>&lt;Point&gt;();</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Point:&quot;</span> &lt;&lt; extracted.x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; extracted.y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Point: 10 , 20</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>使用<code>Q_DECLARE_METATYPE(Point)</code>声明自定义类型，使其能够与<code>QVariant</code>配合使用。</li>
<li>使用<code>qRegisterMetaType&lt;Point&gt;(&quot;Point&quot;)</code>注册类型，确保在信号与槽等Qt机制中正常使用。</li>
<li><code>QVariant</code>能够存储和转换自定义类型<code>Point</code>。</li>
</ul>
<h3 id="11-3-QVariant在模型视图编程中的应用"><a href="#11-3-QVariant在模型视图编程中的应用" class="headerlink" title="11.3 QVariant在模型视图编程中的应用"></a>11.3 QVariant在模型视图编程中的应用</h3><p>在Qt的模型视图架构中，<code>QVariant</code>被广泛用于存储和传递数据。通过<code>QVariant</code>，模型可以存储不同类型的数据，并在视图中进行展示和编辑。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QStandardItemModel&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QStandardItem&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建标准项目模型</span></span><br><span class="line">    <span class="function">QStandardItemModel <span class="title">model</span><span class="params">(<span class="number">2</span>, <span class="number">2</span>)</span></span>; <span class="comment">// 2行2列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置表头</span></span><br><span class="line">    model.<span class="built_in">setHeaderData</span>(<span class="number">0</span>, Qt::Horizontal, <span class="string">&quot;Name&quot;</span>);</span><br><span class="line">    model.<span class="built_in">setHeaderData</span>(<span class="number">1</span>, Qt::Horizontal, <span class="string">&quot;Age&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填充数据</span></span><br><span class="line">    QStandardItem *item1 = <span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">    QStandardItem *item2 = <span class="keyword">new</span> <span class="built_in">QStandardItem</span>();</span><br><span class="line">    item2-&gt;<span class="built_in">setData</span>(<span class="number">30</span>, Qt::EditRole);</span><br><span class="line"></span><br><span class="line">    model.<span class="built_in">setItem</span>(<span class="number">0</span>, <span class="number">0</span>, item1);</span><br><span class="line">    model.<span class="built_in">setItem</span>(<span class="number">0</span>, <span class="number">1</span>, item2);</span><br><span class="line"></span><br><span class="line">    QStandardItem *item3 = <span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">    QStandardItem *item4 = <span class="keyword">new</span> <span class="built_in">QStandardItem</span>();</span><br><span class="line">    item4-&gt;<span class="built_in">setData</span>(<span class="number">25</span>, Qt::EditRole);</span><br><span class="line"></span><br><span class="line">    model.<span class="built_in">setItem</span>(<span class="number">1</span>, <span class="number">0</span>, item3);</span><br><span class="line">    model.<span class="built_in">setItem</span>(<span class="number">1</span>, <span class="number">1</span>, item4);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问和打印数据</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> row = <span class="number">0</span>; row &lt; model.<span class="built_in">rowCount</span>(); ++row) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> col = <span class="number">0</span>; col &lt; model.<span class="built_in">columnCount</span>(); ++col) &#123;</span><br><span class="line">            QVariant data = model.<span class="built_in">data</span>(model.<span class="built_in">index</span>(row, col), Qt::EditRole);</span><br><span class="line">            <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Row&quot;</span> &lt;&lt; row &lt;&lt; <span class="string">&quot;Col&quot;</span> &lt;&lt; col &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Row 0 Col 0 : &quot;Alice&quot;</span><br><span class="line">Row 0 Col 1 : 30</span><br><span class="line">Row 1 Col 0 : &quot;Bob&quot;</span><br><span class="line">Row 1 Col 1 : 25</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>使用<code>QStandardItemModel</code>创建一个简单的模型，存储员工姓名和年龄。</li>
<li>通过<code>QVariant</code>存储不同类型的数据（<code>QString</code>和<code>int</code>）。</li>
<li>通过<code>model.data()</code>方法访问数据，并进行打印。</li>
</ul>
<p><strong>总结：</strong></p>
<ul>
<li><code>QVariant</code>在Qt的模型视图编程中起到了关键的桥梁作用，支持存储和传递多种类型的数据，确保数据的灵活性和通用性。</li>
</ul>
<hr>
<h2 id="12-常用算法及正则表达式"><a href="#12-常用算法及正则表达式" class="headerlink" title="12. 常用算法及正则表达式"></a>12. 常用算法及正则表达式</h2><p>在Qt开发中，除了丰富的容器类外，还提供了多种算法和正则表达式支持，帮助开发者高效地处理数据和进行文本匹配。</p>
<h3 id="12-1-常用算法"><a href="#12-1-常用算法" class="headerlink" title="12.1 常用算法"></a>12.1 常用算法</h3><p>Qt提供了一系列算法函数，类似于标准C++库中的算法。这些算法函数主要集中在<code>QtAlgorithms</code>模块，提供了排序、查找、遍历等功能。</p>
<h4 id="12-1-1-排序算法"><a href="#12-1-1-排序算法" class="headerlink" title="12.1.1 排序算法"></a>12.1.1 排序算法</h4><p>使用<code>qSort</code>或<code>std::sort</code>对容器进行排序。虽然<code>qSort</code>在Qt 5中已经被弃用，但在某些旧项目中仍可能使用。</p>
<p><strong>示例：使用std::sort对QVector进行排序</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QVector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    QVector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;排序前:&quot;</span> &lt;&lt; numbers;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用std::sort排序</span></span><br><span class="line">    std::<span class="built_in">sort</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;排序后:&quot;</span> &lt;&lt; numbers;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">排序前: QVector(5, 2, 9, 1, 5, 6)</span><br><span class="line">排序后: QVector(1, 2, 5, 5, 6, 9)</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>使用<code>std::sort</code>对<code>QVector</code>中的整数进行升序排序。</li>
</ul>
<h4 id="12-1-2-查找算法"><a href="#12-1-2-查找算法" class="headerlink" title="12.1.2 查找算法"></a>12.1.2 查找算法</h4><p>使用<code>std::find</code>在容器中查找特定元素。</p>
<p><strong>示例：查找QList中的特定字符串</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QList&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QString&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    QList&lt;QString&gt; fruits = &#123;<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Cherry&quot;</span>, <span class="string">&quot;Date&quot;</span>&#125;;</span><br><span class="line">    QString target = <span class="string">&quot;Cherry&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用std::find查找元素</span></span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">find</span>(fruits.<span class="built_in">begin</span>(), fruits.<span class="built_in">end</span>(), target);</span><br><span class="line">    <span class="keyword">if</span>(it != fruits.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;找到水果:&quot;</span> &lt;&lt; *it;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;未找到水果:&quot;</span> &lt;&lt; target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">找到水果: &quot;Cherry&quot;</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>使用<code>std::find</code>在<code>QList</code>中查找指定的字符串“Cherry”。</li>
</ul>
<h4 id="12-1-3-遍历算法"><a href="#12-1-3-遍历算法" class="headerlink" title="12.1.3 遍历算法"></a>12.1.3 遍历算法</h4><p>使用<code>std::for_each</code>对容器中的每个元素执行特定操作。</p>
<p><strong>示例：使用std::for_each遍历QVector并打印元素</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QVector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    QVector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用std::for_each遍历并打印元素</span></span><br><span class="line">    std::for_each(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), [](<span class="type">int</span> num) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; num;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>使用<code>std::for_each</code>和lambda表达式遍历<code>QVector</code>，并打印每个元素的值。</li>
</ul>
<h3 id="12-2-正则表达式支持"><a href="#12-2-正则表达式支持" class="headerlink" title="12.2 正则表达式支持"></a>12.2 正则表达式支持</h3><p>Qt提供了<code>QRegularExpression</code>类，支持使用正则表达式进行复杂的文本匹配和处理。</p>
<h4 id="12-2-1-QRegularExpression的基本使用"><a href="#12-2-1-QRegularExpression的基本使用" class="headerlink" title="12.2.1 QRegularExpression的基本使用"></a>12.2.1 QRegularExpression的基本使用</h4><p><strong>示例：验证用户输入的邮箱地址</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QString&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QRegularExpression&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    QString email = <span class="string">&quot;user@example.com&quot;</span>;</span><br><span class="line">    <span class="function">QRegularExpression <span class="title">regex</span><span class="params">(<span class="string">R&quot;((\w+)(\.\w+)*@(\w+\.)+(\w+))&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    QRegularExpressionMatch match = regex.<span class="built_in">match</span>(email);</span><br><span class="line">    <span class="keyword">if</span>(match.<span class="built_in">hasMatch</span>()) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;有效的邮箱地址。&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;无效的邮箱地址。&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">有效的邮箱地址。</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>使用<code>QRegularExpression</code>定义了一个用于匹配邮箱地址的正则表达式。</li>
<li><code>match.hasMatch()</code>判断字符串是否匹配该正则表达式。</li>
</ul>
<h4 id="12-2-2-字符串替换"><a href="#12-2-2-字符串替换" class="headerlink" title="12.2.2 字符串替换"></a>12.2.2 字符串替换</h4><p>使用<code>QRegularExpression</code>和<code>QString::replace</code>进行复杂的字符串替换操作。</p>
<p><strong>示例：将文本中的特定关键词替换为强调格式</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QString&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QRegularExpression&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    QString text = <span class="string">&quot;C++11 introduced many features like auto, lambda, and smart pointers.&quot;</span>;</span><br><span class="line">    <span class="function">QRegularExpression <span class="title">regex</span><span class="params">(<span class="string">R&quot;(\b(auto|lambda|smart pointers)\b)&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    QString replacedText = text.<span class="built_in">replace</span>(regex, <span class="string">&quot;&lt;strong&gt;\\1&lt;/strong&gt;&quot;</span>);</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; replacedText;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;C++11 introduced many features like &lt;strong&gt;auto&lt;/strong&gt;, &lt;strong&gt;lambda&lt;/strong&gt;, and &lt;strong&gt;smart pointers&lt;/strong&gt;.&quot;</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>使用正则表达式匹配<code>auto</code>、<code>lambda</code>和<code>smart pointers</code>关键词。</li>
<li>使用<code>replace</code>函数将匹配的关键词替换为带有HTML标签的强调格式。</li>
</ul>
<h4 id="12-2-3-字符串分割与提取"><a href="#12-2-3-字符串分割与提取" class="headerlink" title="12.2.3 字符串分割与提取"></a>12.2.3 字符串分割与提取</h4><p>使用<code>QRegularExpression</code>结合<code>QString::split</code>进行复杂的字符串分割和提取操作。</p>
<p><strong>示例：按多个分隔符分割字符串</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QString&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QRegularExpression&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QStringList&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    QString data = <span class="string">&quot;apple, banana; cherry|date&quot;</span>;</span><br><span class="line">    <span class="function">QRegularExpression <span class="title">regex</span><span class="params">(<span class="string">R&quot;([,;|])&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    QStringList fruits = data.<span class="built_in">split</span>(regex);</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;水果列表:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> QString&amp; fruit : fruits) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; fruit.<span class="built_in">trimmed</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">水果列表:</span><br><span class="line">&quot;apple&quot;</span><br><span class="line">&quot;banana&quot;</span><br><span class="line">&quot;cherry&quot;</span><br><span class="line">&quot;date&quot;</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>使用正则表达式匹配逗号、分号和竖线作为分隔符。</li>
<li>使用<code>split</code>函数按匹配的分隔符分割字符串，并使用<code>trimmed()</code>去除多余的空格。</li>
</ul>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>通过系统地学习Qt开发基础体系，您已经掌握了Qt框架的核心组件和技术。这些知识将为您在实际项目中高效开发和维护Qt应用程序提供坚实的基础。继续深入学习和实践，结合高级功能和最佳实践，您将能够构建出功能丰富、性能优异且用户友好的Qt应用程序。</p>
<hr>
<p><em>感谢您的阅读与支持！如果您对本文内容有任何疑问或建议，欢迎在评论区留言与我们交流。请继续关注我们的系列文章，深入了解Qt C++开发的更多高级特性和实战技巧。</em></p>
]]></content>
  </entry>
  <entry>
    <title>Qt开发常用控件详解(1)</title>
    <url>/2024/12/26/Qt%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E6%8E%A7%E4%BB%B6%E8%AF%A6%E8%A7%A3-1/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><span id="more"></span>

<h1 id="Qt开发常用控件详解"><a href="#Qt开发常用控件详解" class="headerlink" title="Qt开发常用控件详解"></a>Qt开发常用控件详解</h1><p>在Qt框架中，控件（Widgets）是构建图形用户界面的基石。Qt提供了丰富的控件库，涵盖了布局管理、按钮、容器、视图、输入和显示等各个方面，满足不同应用场景的需求。掌握这些常用控件的使用方法和最佳实践，是高效开发Qt应用程序的关键。本文将详细介绍Qt开发中常用的控件类别，包括布局管理器和空白控件、按钮与容器控件、基于模型的视图控件、基于项的视图控件、输入控件以及显示控件。同时，我们还将探讨Qt中常用的算法和正则表达式支持，展示如何在项目中应用这些功能。</p>
<hr>
<h2 id="1-Layouts-amp-Spacers"><a href="#1-Layouts-amp-Spacers" class="headerlink" title="1. Layouts &amp; Spacers"></a>1. Layouts &amp; Spacers</h2><h3 id="1-1-布局管理器（Layouts）"><a href="#1-1-布局管理器（Layouts）" class="headerlink" title="1.1 布局管理器（Layouts）"></a>1.1 布局管理器（Layouts）</h3><p>布局管理器是Qt中用于自动排列和调整控件大小的工具。使用布局管理器可以确保用户界面在不同分辨率和窗口大小下都能保持良好的布局。Qt提供了几种常用的布局管理器：</p>
<ul>
<li><strong>QHBoxLayout</strong>：水平布局管理器，按水平方向排列控件。</li>
<li><strong>QVBoxLayout</strong>：垂直布局管理器，按垂直方向排列控件。</li>
<li><strong>QGridLayout</strong>：网格布局管理器，按行和列排列控件。</li>
<li><strong>QFormLayout</strong>：表单布局管理器，适用于表单输入界面。</li>
</ul>
<h3 id="1-2-Spacer（空白控件）"><a href="#1-2-Spacer（空白控件）" class="headerlink" title="1.2 Spacer（空白控件）"></a>1.2 Spacer（空白控件）</h3><p>Spacer（间隔控件）用于在布局中添加弹性空间，帮助控件之间保持适当的间距或将控件推向布局的一侧。Qt提供了两种主要的间隔控件：</p>
<ul>
<li><strong>QSpacerItem</strong>：通用的间隔项，可用于任何布局中。</li>
<li><strong>QSpacerWidget</strong>：基于QWidget的间隔控件，已在Qt 5中弃用，推荐使用QSpacerItem。</li>
</ul>
<h3 id="1-3-示例：使用布局管理器和间隔控件设计界面"><a href="#1-3-示例：使用布局管理器和间隔控件设计界面" class="headerlink" title="1.3 示例：使用布局管理器和间隔控件设计界面"></a>1.3 示例：使用布局管理器和间隔控件设计界面</h3><p>以下示例展示了如何使用QVBoxLayout和QHBoxLayout结合间隔控件来设计一个简洁美观的用户界面。</p>
<p><strong>示例代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QHBoxLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QVBoxLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QSpacerItem&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建主窗口</span></span><br><span class="line">    QWidget window;</span><br><span class="line">    window.<span class="built_in">setWindowTitle</span>(<span class="string">&quot;布局管理器与间隔控件示例&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建按钮</span></span><br><span class="line">    QPushButton *button1 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;按钮1&quot;</span>);</span><br><span class="line">    QPushButton *button2 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;按钮2&quot;</span>);</span><br><span class="line">    QPushButton *button3 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;按钮3&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建水平布局管理器</span></span><br><span class="line">    QHBoxLayout *hLayout = <span class="keyword">new</span> QHBoxLayout;</span><br><span class="line">    hLayout-&gt;<span class="built_in">addWidget</span>(button1);</span><br><span class="line">    hLayout-&gt;<span class="built_in">addWidget</span>(button2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加间隔控件，将button3推向右侧</span></span><br><span class="line">    QSpacerItem *spacer = <span class="keyword">new</span> <span class="built_in">QSpacerItem</span>(<span class="number">40</span>, <span class="number">20</span>, QSizePolicy::Expanding, QSizePolicy::Minimum);</span><br><span class="line">    hLayout-&gt;<span class="built_in">addItem</span>(spacer);</span><br><span class="line">    hLayout-&gt;<span class="built_in">addWidget</span>(button3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建垂直布局管理器</span></span><br><span class="line">    QVBoxLayout *vLayout = <span class="keyword">new</span> QVBoxLayout;</span><br><span class="line">    vLayout-&gt;<span class="built_in">addLayout</span>(hLayout);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置主窗口的布局</span></span><br><span class="line">    window.<span class="built_in">setLayout</span>(vLayout);</span><br><span class="line">    window.<span class="built_in">resize</span>(<span class="number">400</span>, <span class="number">200</span>);</span><br><span class="line">    window.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<p><img src="https://i.imgur.com/XYZ1234.png" alt="布局管理器与间隔控件示例"></p>
<p><strong>解释：</strong></p>
<ul>
<li><strong>QHBoxLayout</strong>用于水平排列按钮1和按钮2。</li>
<li><strong>QSpacerItem</strong>被添加到水平布局中，起到弹性空间的作用，将按钮3推向布局的右侧。</li>
<li><strong>QVBoxLayout</strong>将水平布局嵌套在垂直布局中，确保界面在垂直方向上的灵活性。</li>
</ul>
<h3 id="1-4-布局管理器的最佳实践"><a href="#1-4-布局管理器的最佳实践" class="headerlink" title="1.4 布局管理器的最佳实践"></a>1.4 布局管理器的最佳实践</h3><ol>
<li><strong>避免在控件之间使用固定大小</strong>：尽量使用布局管理器自动调整控件大小，以适应不同的窗口尺寸。</li>
<li><strong>合理使用嵌套布局</strong>：通过嵌套使用QHBoxLayout和QVBoxLayout，可以设计复杂且灵活的界面。</li>
<li><strong>使用间隔控件优化布局</strong>：适当添加间隔控件，确保控件之间的间距合理，提升界面的美观性。</li>
</ol>
<hr>
<h2 id="2-Buttons-amp-Containers"><a href="#2-Buttons-amp-Containers" class="headerlink" title="2. Buttons &amp; Containers"></a>2. Buttons &amp; Containers</h2><h3 id="2-1-按钮控件（Buttons）"><a href="#2-1-按钮控件（Buttons）" class="headerlink" title="2.1 按钮控件（Buttons）"></a>2.1 按钮控件（Buttons）</h3><p>按钮是用户界面中最常用的控件之一，用于触发各种操作和事件。Qt提供了多种按钮控件，满足不同的需求：</p>
<ul>
<li><strong>QPushButton</strong>：标准按钮，用于执行命令。</li>
<li><strong>QToolButton</strong>：工具按钮，通常用于工具栏中，支持图标显示。</li>
<li><strong>QRadioButton</strong>：单选按钮，用于在多个选项中选择一个。</li>
<li><strong>QCheckBox</strong>：复选框，用于选择或取消选择多个选项。</li>
<li><strong>QCommandLinkButton</strong>：命令链接按钮，带有描述文本，类似于Windows Vista中的链接按钮。</li>
</ul>
<h3 id="2-2-容器控件（Containers）"><a href="#2-2-容器控件（Containers）" class="headerlink" title="2.2 容器控件（Containers）"></a>2.2 容器控件（Containers）</h3><p>容器控件用于组织和管理其他控件，提供分组和结构化界面的能力。常用的容器控件包括：</p>
<ul>
<li><strong>QGroupBox</strong>：分组框，用于在视觉上分组相关的控件。</li>
<li><strong>QFrame</strong>：框架控件，提供多种边框样式。</li>
<li><strong>QScrollArea</strong>：滚动区域控件，允许在有限的空间内显示超出视图范围的内容。</li>
</ul>
<h3 id="2-3-示例：使用QPushButton和QGroupBox构建界面"><a href="#2-3-示例：使用QPushButton和QGroupBox构建界面" class="headerlink" title="2.3 示例：使用QPushButton和QGroupBox构建界面"></a>2.3 示例：使用QPushButton和QGroupBox构建界面</h3><p>以下示例展示了如何使用QPushButton和QGroupBox来创建一个分组按钮的用户界面。</p>
<p><strong>示例代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QGroupBox&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QVBoxLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QHBoxLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建主窗口</span></span><br><span class="line">    QWidget window;</span><br><span class="line">    window.<span class="built_in">setWindowTitle</span>(<span class="string">&quot;按钮与容器控件示例&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建QGroupBox</span></span><br><span class="line">    QGroupBox *groupBox = <span class="keyword">new</span> <span class="built_in">QGroupBox</span>(<span class="string">&quot;操作选项&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建按钮</span></span><br><span class="line">    QPushButton *btnStart = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;开始&quot;</span>);</span><br><span class="line">    QPushButton *btnStop = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;停止&quot;</span>);</span><br><span class="line">    QPushButton *btnPause = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;暂停&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接按钮信号到槽</span></span><br><span class="line">    QObject::<span class="built_in">connect</span>(btnStart, &amp;QPushButton::clicked, []()&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;开始按钮被点击&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    QObject::<span class="built_in">connect</span>(btnStop, &amp;QPushButton::clicked, []()&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;停止按钮被点击&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    QObject::<span class="built_in">connect</span>(btnPause, &amp;QPushButton::clicked, []()&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;暂停按钮被点击&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建布局管理器</span></span><br><span class="line">    QHBoxLayout *hLayout = <span class="keyword">new</span> QHBoxLayout;</span><br><span class="line">    hLayout-&gt;<span class="built_in">addWidget</span>(btnStart);</span><br><span class="line">    hLayout-&gt;<span class="built_in">addWidget</span>(btnStop);</span><br><span class="line">    hLayout-&gt;<span class="built_in">addWidget</span>(btnPause);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置QGroupBox的布局</span></span><br><span class="line">    groupBox-&gt;<span class="built_in">setLayout</span>(hLayout);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建主布局</span></span><br><span class="line">    QVBoxLayout *vLayout = <span class="keyword">new</span> QVBoxLayout;</span><br><span class="line">    vLayout-&gt;<span class="built_in">addWidget</span>(groupBox);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置主窗口的布局</span></span><br><span class="line">    window.<span class="built_in">setLayout</span>(vLayout);</span><br><span class="line">    window.<span class="built_in">resize</span>(<span class="number">300</span>, <span class="number">150</span>);</span><br><span class="line">    window.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<p><img src="https://i.imgur.com/ABC5678.png" alt="按钮与容器控件示例"></p>
<p><strong>解释：</strong></p>
<ul>
<li><strong>QGroupBox</strong>用于视觉上分组“开始”、“停止”和“暂停”按钮。</li>
<li>按钮的点击信号通过<code>QObject::connect</code>连接到lambda槽函数，打印相应的调试信息。</li>
<li><strong>QHBoxLayout</strong>在<code>QGroupBox</code>内部水平排列按钮，确保界面整洁有序。</li>
</ul>
<h3 id="2-4-QPushButton的高级功能"><a href="#2-4-QPushButton的高级功能" class="headerlink" title="2.4 QPushButton的高级功能"></a>2.4 QPushButton的高级功能</h3><p><strong>设置图标和快捷键：</strong></p>
<p>可以为QPushButton设置图标和快捷键，提升用户体验。</p>
<p><strong>示例代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QPushButton *btnSave = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;保存&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">btnSave-&gt;<span class="built_in">setIcon</span>(<span class="built_in">QIcon</span>(<span class="string">&quot;:/icons/save.png&quot;</span>)); <span class="comment">// 设置图标</span></span><br><span class="line">btnSave-&gt;<span class="built_in">setShortcut</span>(<span class="built_in">QKeySequence</span>(Qt::CTRL + Qt::Key_S)); <span class="comment">// 设置快捷键</span></span><br><span class="line"><span class="built_in">connect</span>(btnSave, &amp;QPushButton::clicked, <span class="keyword">this</span>, &amp;MainWindow::saveData);</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>setIcon</code>方法为按钮设置图标，提升界面的视觉效果。</li>
<li><code>setShortcut</code>方法为按钮设置快捷键，允许用户通过键盘快速触发按钮操作。</li>
</ul>
<h3 id="2-5-QGroupBox的高级应用"><a href="#2-5-QGroupBox的高级应用" class="headerlink" title="2.5 QGroupBox的高级应用"></a>2.5 QGroupBox的高级应用</h3><p><strong>示例：嵌套使用QGroupBox</strong></p>
<p>通过嵌套使用多个QGroupBox，可以创建更复杂的界面布局。</p>
<p><strong>示例代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QGroupBox&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QVBoxLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QHBoxLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建主窗口</span></span><br><span class="line">    QWidget window;</span><br><span class="line">    window.<span class="built_in">setWindowTitle</span>(<span class="string">&quot;嵌套QGroupBox示例&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建第一个QGroupBox</span></span><br><span class="line">    QGroupBox *groupBox1 = <span class="keyword">new</span> <span class="built_in">QGroupBox</span>(<span class="string">&quot;文件操作&quot;</span>);</span><br><span class="line">    QPushButton *btnOpen = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;打开&quot;</span>);</span><br><span class="line">    QPushButton *btnClose = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;关闭&quot;</span>);</span><br><span class="line"></span><br><span class="line">    QHBoxLayout *hLayout1 = <span class="keyword">new</span> QHBoxLayout;</span><br><span class="line">    hLayout1-&gt;<span class="built_in">addWidget</span>(btnOpen);</span><br><span class="line">    hLayout1-&gt;<span class="built_in">addWidget</span>(btnClose);</span><br><span class="line">    groupBox1-&gt;<span class="built_in">setLayout</span>(hLayout1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建第二个QGroupBox</span></span><br><span class="line">    QGroupBox *groupBox2 = <span class="keyword">new</span> <span class="built_in">QGroupBox</span>(<span class="string">&quot;编辑操作&quot;</span>);</span><br><span class="line">    QPushButton *btnCut = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;剪切&quot;</span>);</span><br><span class="line">    QPushButton *btnCopy = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;复制&quot;</span>);</span><br><span class="line">    QPushButton *btnPaste = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;粘贴&quot;</span>);</span><br><span class="line"></span><br><span class="line">    QHBoxLayout *hLayout2 = <span class="keyword">new</span> QHBoxLayout;</span><br><span class="line">    hLayout2-&gt;<span class="built_in">addWidget</span>(btnCut);</span><br><span class="line">    hLayout2-&gt;<span class="built_in">addWidget</span>(btnCopy);</span><br><span class="line">    hLayout2-&gt;<span class="built_in">addWidget</span>(btnPaste);</span><br><span class="line">    groupBox2-&gt;<span class="built_in">setLayout</span>(hLayout2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建主布局</span></span><br><span class="line">    QVBoxLayout *vLayout = <span class="keyword">new</span> QVBoxLayout;</span><br><span class="line">    vLayout-&gt;<span class="built_in">addWidget</span>(groupBox1);</span><br><span class="line">    vLayout-&gt;<span class="built_in">addWidget</span>(groupBox2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置主窗口的布局</span></span><br><span class="line">    window.<span class="built_in">setLayout</span>(vLayout);</span><br><span class="line">    window.<span class="built_in">resize</span>(<span class="number">400</span>, <span class="number">200</span>);</span><br><span class="line">    window.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<p><img src="https://i.imgur.com/DEF91011.png" alt="嵌套QGroupBox示例"></p>
<p><strong>解释：</strong></p>
<ul>
<li>创建了两个QGroupBox，分别用于“文件操作”和“编辑操作”。</li>
<li>每个QGroupBox内部使用QHBoxLayout水平排列相关按钮，增强界面的组织性和可读性。</li>
</ul>
<h3 id="2-6-布局管理器与容器控件的结合使用"><a href="#2-6-布局管理器与容器控件的结合使用" class="headerlink" title="2.6 布局管理器与容器控件的结合使用"></a>2.6 布局管理器与容器控件的结合使用</h3><p>通过将布局管理器与容器控件结合使用，可以设计出更加复杂和灵活的用户界面。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QGroupBox&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QVBoxLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QHBoxLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QGridLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建主窗口</span></span><br><span class="line">    QWidget window;</span><br><span class="line">    window.<span class="built_in">setWindowTitle</span>(<span class="string">&quot;布局与容器结合示例&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建QGroupBox1</span></span><br><span class="line">    QGroupBox *groupBox1 = <span class="keyword">new</span> <span class="built_in">QGroupBox</span>(<span class="string">&quot;基本操作&quot;</span>);</span><br><span class="line">    QPushButton *btnAdd = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;添加&quot;</span>);</span><br><span class="line">    QPushButton *btnDelete = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;删除&quot;</span>);</span><br><span class="line"></span><br><span class="line">    QHBoxLayout *hLayout1 = <span class="keyword">new</span> QHBoxLayout;</span><br><span class="line">    hLayout1-&gt;<span class="built_in">addWidget</span>(btnAdd);</span><br><span class="line">    hLayout1-&gt;<span class="built_in">addWidget</span>(btnDelete);</span><br><span class="line">    groupBox1-&gt;<span class="built_in">setLayout</span>(hLayout1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建QGroupBox2</span></span><br><span class="line">    QGroupBox *groupBox2 = <span class="keyword">new</span> <span class="built_in">QGroupBox</span>(<span class="string">&quot;高级操作&quot;</span>);</span><br><span class="line">    QPushButton *btnEdit = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;编辑&quot;</span>);</span><br><span class="line">    QPushButton *btnSearch = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;搜索&quot;</span>);</span><br><span class="line"></span><br><span class="line">    QHBoxLayout *hLayout2 = <span class="keyword">new</span> QHBoxLayout;</span><br><span class="line">    hLayout2-&gt;<span class="built_in">addWidget</span>(btnEdit);</span><br><span class="line">    hLayout2-&gt;<span class="built_in">addWidget</span>(btnSearch);</span><br><span class="line">    groupBox2-&gt;<span class="built_in">setLayout</span>(hLayout2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建网格布局</span></span><br><span class="line">    QGridLayout *gridLayout = <span class="keyword">new</span> QGridLayout;</span><br><span class="line">    gridLayout-&gt;<span class="built_in">addWidget</span>(groupBox1, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    gridLayout-&gt;<span class="built_in">addWidget</span>(groupBox2, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建主布局</span></span><br><span class="line">    QVBoxLayout *vLayout = <span class="keyword">new</span> QVBoxLayout;</span><br><span class="line">    vLayout-&gt;<span class="built_in">addLayout</span>(gridLayout);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置主窗口的布局</span></span><br><span class="line">    window.<span class="built_in">setLayout</span>(vLayout);</span><br><span class="line">    window.<span class="built_in">resize</span>(<span class="number">500</span>, <span class="number">300</span>);</span><br><span class="line">    window.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<p><img src="https://i.imgur.com/GHI1213.png" alt="布局与容器结合示例"></p>
<p><strong>解释：</strong></p>
<ul>
<li>使用QGridLayout将两个QGroupBox放置在网格的不同位置。</li>
<li>每个QGroupBox内部使用QHBoxLayout水平排列按钮，实现复杂的界面布局。</li>
</ul>
<h3 id="2-7-小结"><a href="#2-7-小结" class="headerlink" title="2.7 小结"></a>2.7 小结</h3><p>布局管理器和容器控件是构建美观且响应式用户界面的重要工具。通过合理使用布局管理器和容器控件，可以确保应用程序在不同屏幕尺寸和分辨率下都能保持良好的用户体验。同时，结合按钮控件的使用，能够创建功能齐全且易于操作的用户界面。</p>
<hr>
<h2 id="3-Item-Views"><a href="#3-Item-Views" class="headerlink" title="3. Item Views"></a>3. Item Views</h2><h3 id="3-1-基于模型的视图控件"><a href="#3-1-基于模型的视图控件" class="headerlink" title="3.1 基于模型的视图控件"></a>3.1 基于模型的视图控件</h3><p>Qt的模型视图架构（Model-View Architecture）提供了一种高效的数据管理和显示方式。基于模型的视图控件将数据存储在模型中，视图负责展示数据，控制器处理用户交互。这种架构促进了数据与视图的分离，提高了代码的可维护性和复用性。</p>
<p>常见的基于模型的视图控件包括：</p>
<ul>
<li><strong>QListView</strong>：列表视图，用于显示线性列表数据。</li>
<li><strong>QTableView</strong>：表格视图，用于显示二维表格数据。</li>
<li><strong>QTreeView</strong>：树形视图，用于显示层次结构数据。</li>
</ul>
<h3 id="3-2-示例：使用QListView展示数据"><a href="#3-2-示例：使用QListView展示数据" class="headerlink" title="3.2 示例：使用QListView展示数据"></a>3.2 示例：使用QListView展示数据</h3><p>以下示例展示了如何使用QListView结合QStringListModel来展示简单的列表数据。</p>
<p><strong>示例代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QListView&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QStringListModel&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建QListView</span></span><br><span class="line">    QListView listView;</span><br><span class="line">    listView.<span class="built_in">setWindowTitle</span>(<span class="string">&quot;QListView 示例&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建QStringListModel</span></span><br><span class="line">    QStringList data;</span><br><span class="line">    data &lt;&lt; <span class="string">&quot;Apple&quot;</span> &lt;&lt; <span class="string">&quot;Banana&quot;</span> &lt;&lt; <span class="string">&quot;Cherry&quot;</span> &lt;&lt; <span class="string">&quot;Date&quot;</span> &lt;&lt; <span class="string">&quot;Elderberry&quot;</span>;</span><br><span class="line">    QStringListModel *model = <span class="keyword">new</span> <span class="built_in">QStringListModel</span>(data, &amp;listView);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置模型到视图</span></span><br><span class="line">    listView.<span class="built_in">setModel</span>(model);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示视图</span></span><br><span class="line">    listView.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<p><img src="https://i.imgur.com/JKL1415.png" alt="QListView 示例"></p>
<p><strong>解释：</strong></p>
<ul>
<li><strong>QListView</strong>作为视图控件，负责展示数据。</li>
<li><strong>QStringListModel</strong>作为模型，存储并管理字符串列表数据。</li>
<li>使用<code>setModel</code>方法将模型关联到视图，视图自动更新显示数据。</li>
</ul>
<h3 id="3-3-示例：使用QTableView展示数据"><a href="#3-3-示例：使用QTableView展示数据" class="headerlink" title="3.3 示例：使用QTableView展示数据"></a>3.3 示例：使用QTableView展示数据</h3><p>以下示例展示了如何使用QTableView结合QStandardItemModel来展示二维表格数据。</p>
<p><strong>示例代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTableView&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QStandardItemModel&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QStandardItem&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建QTableView</span></span><br><span class="line">    QTableView tableView;</span><br><span class="line">    tableView.<span class="built_in">setWindowTitle</span>(<span class="string">&quot;QTableView 示例&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建QStandardItemModel</span></span><br><span class="line">    <span class="function">QStandardItemModel <span class="title">model</span><span class="params">(<span class="number">3</span>, <span class="number">2</span>)</span></span>; <span class="comment">// 3行2列</span></span><br><span class="line">    model.<span class="built_in">setHeaderData</span>(<span class="number">0</span>, Qt::Horizontal, <span class="string">&quot;姓名&quot;</span>);</span><br><span class="line">    model.<span class="built_in">setHeaderData</span>(<span class="number">1</span>, Qt::Horizontal, <span class="string">&quot;年龄&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填充数据</span></span><br><span class="line">    QList&lt;QStandardItem *&gt; row1;</span><br><span class="line">    row1 &lt;&lt; <span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;Alice&quot;</span>) &lt;&lt; <span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;30&quot;</span>);</span><br><span class="line">    QList&lt;QStandardItem *&gt; row2;</span><br><span class="line">    row2 &lt;&lt; <span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;Bob&quot;</span>) &lt;&lt; <span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;25&quot;</span>);</span><br><span class="line">    QList&lt;QStandardItem *&gt; row3;</span><br><span class="line">    row3 &lt;&lt; <span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;Charlie&quot;</span>) &lt;&lt; <span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;35&quot;</span>);</span><br><span class="line"></span><br><span class="line">    model.<span class="built_in">appendRow</span>(row1);</span><br><span class="line">    model.<span class="built_in">appendRow</span>(row2);</span><br><span class="line">    model.<span class="built_in">appendRow</span>(row3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置模型到视图</span></span><br><span class="line">    tableView.<span class="built_in">setModel</span>(&amp;model);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示视图</span></span><br><span class="line">    tableView.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<p><img src="https://i.imgur.com/MNO1617.png" alt="QTableView 示例"></p>
<p><strong>解释：</strong></p>
<ul>
<li><strong>QTableView</strong>作为视图控件，负责展示二维表格数据。</li>
<li><strong>QStandardItemModel</strong>作为模型，存储并管理表格数据，包括行和列。</li>
<li>使用<code>setHeaderData</code>设置表头信息，使用<code>appendRow</code>添加数据行。</li>
<li>视图自动显示模型中的数据。</li>
</ul>
<h3 id="3-4-示例：使用QTreeView展示数据"><a href="#3-4-示例：使用QTreeView展示数据" class="headerlink" title="3.4 示例：使用QTreeView展示数据"></a>3.4 示例：使用QTreeView展示数据</h3><p>以下示例展示了如何使用QTreeView结合QStandardItemModel来展示层次结构数据。</p>
<p><strong>示例代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTreeView&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QStandardItemModel&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QStandardItem&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建QTreeView</span></span><br><span class="line">    QTreeView treeView;</span><br><span class="line">    treeView.<span class="built_in">setWindowTitle</span>(<span class="string">&quot;QTreeView 示例&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建QStandardItemModel</span></span><br><span class="line">    QStandardItemModel model;</span><br><span class="line">    model.<span class="built_in">setHorizontalHeaderLabels</span>(&#123;<span class="string">&quot;名称&quot;</span>, <span class="string">&quot;描述&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建根节点</span></span><br><span class="line">    QStandardItem *rootItem = model.<span class="built_in">invisibleRootItem</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一级节点</span></span><br><span class="line">    QStandardItem *parent1 = <span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;文件&quot;</span>);</span><br><span class="line">    QStandardItem *parent1Desc = <span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;文件操作&quot;</span>);</span><br><span class="line">    rootItem-&gt;<span class="built_in">appendRow</span>(&#123;parent1, parent1Desc&#125;);</span><br><span class="line"></span><br><span class="line">    QStandardItem *parent2 = <span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;编辑&quot;</span>);</span><br><span class="line">    QStandardItem *parent2Desc = <span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;编辑操作&quot;</span>);</span><br><span class="line">    rootItem-&gt;<span class="built_in">appendRow</span>(&#123;parent2, parent2Desc&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建二级节点</span></span><br><span class="line">    QStandardItem *child1 = <span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;新建&quot;</span>);</span><br><span class="line">    QStandardItem *child1Desc = <span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;创建新文件&quot;</span>);</span><br><span class="line">    parent1-&gt;<span class="built_in">appendRow</span>(&#123;child1, child1Desc&#125;);</span><br><span class="line"></span><br><span class="line">    QStandardItem *child2 = <span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;打开&quot;</span>);</span><br><span class="line">    QStandardItem *child2Desc = <span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;打开现有文件&quot;</span>);</span><br><span class="line">    parent1-&gt;<span class="built_in">appendRow</span>(&#123;child2, child2Desc&#125;);</span><br><span class="line"></span><br><span class="line">    QStandardItem *child3 = <span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;复制&quot;</span>);</span><br><span class="line">    QStandardItem *child3Desc = <span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;复制选中内容&quot;</span>);</span><br><span class="line">    parent2-&gt;<span class="built_in">appendRow</span>(&#123;child3, child3Desc&#125;);</span><br><span class="line"></span><br><span class="line">    QStandardItem *child4 = <span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;粘贴&quot;</span>);</span><br><span class="line">    QStandardItem *child4Desc = <span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;粘贴内容&quot;</span>);</span><br><span class="line">    parent2-&gt;<span class="built_in">appendRow</span>(&#123;child4, child4Desc&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置模型到视图</span></span><br><span class="line">    treeView.<span class="built_in">setModel</span>(&amp;model);</span><br><span class="line">    treeView.<span class="built_in">expandAll</span>(); <span class="comment">// 展开所有节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示视图</span></span><br><span class="line">    treeView.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<p><img src="https://i.imgur.com/PQR1819.png" alt="QTreeView 示例"></p>
<p><strong>解释：</strong></p>
<ul>
<li><strong>QTreeView</strong>作为视图控件，负责展示层次结构数据。</li>
<li><strong>QStandardItemModel</strong>作为模型，存储并管理树形数据结构。</li>
<li>通过<code>appendRow</code>方法添加父节点和子节点，构建树形结构。</li>
<li>使用<code>expandAll</code>方法展开所有节点，便于查看数据。</li>
</ul>
<h3 id="3-5-模型视图架构的优势"><a href="#3-5-模型视图架构的优势" class="headerlink" title="3.5 模型视图架构的优势"></a>3.5 模型视图架构的优势</h3><ul>
<li><strong>数据与视图分离</strong>：模型负责数据管理，视图负责数据展示，提高了代码的模块化和可维护性。</li>
<li><strong>灵活的数据展示</strong>：同一个模型可以被多个视图使用，如一个模型可以同时被QListView和QTableView展示。</li>
<li><strong>高效的数据操作</strong>：模型视图架构优化了大规模数据的处理和展示，提升了应用程序的性能。</li>
</ul>
<h3 id="3-6-小结"><a href="#3-6-小结" class="headerlink" title="3.6 小结"></a>3.6 小结</h3><p>基于模型的视图控件是Qt中处理和展示复杂数据的重要工具。通过理解和应用模型视图架构，开发者可以构建高效、灵活且可维护的用户界面，满足不同的数据展示需求。</p>
<hr>
<h2 id="4-Item-Widgets"><a href="#4-Item-Widgets" class="headerlink" title="4. Item Widgets"></a>4. Item Widgets</h2><h3 id="4-1-基于项的视图控件"><a href="#4-1-基于项的视图控件" class="headerlink" title="4.1 基于项的视图控件"></a>4.1 基于项的视图控件</h3><p>除了基于模型的视图控件，Qt还提供了基于项的视图控件，这些控件更加直观和易于使用，适用于简单的数据展示场景。常见的基于项的视图控件包括：</p>
<ul>
<li><strong>QListWidget</strong>：列表项视图，继承自QListView，提供简化的API。</li>
<li><strong>QTreeWidget</strong>：树形项视图，继承自QTreeView，提供简化的API。</li>
<li><strong>QTableWidget</strong>：表格项视图，继承自QTableView，提供简化的API。</li>
</ul>
<h3 id="4-2-示例：使用QListWidget展示数据"><a href="#4-2-示例：使用QListWidget展示数据" class="headerlink" title="4.2 示例：使用QListWidget展示数据"></a>4.2 示例：使用QListWidget展示数据</h3><p>以下示例展示了如何使用QListWidget来展示和管理简单的列表数据。</p>
<p><strong>示例代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QListWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建QListWidget</span></span><br><span class="line">    QListWidget listWidget;</span><br><span class="line">    listWidget.<span class="built_in">setWindowTitle</span>(<span class="string">&quot;QListWidget 示例&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加列表项</span></span><br><span class="line">    listWidget.<span class="built_in">addItem</span>(<span class="string">&quot;Item 1&quot;</span>);</span><br><span class="line">    listWidget.<span class="built_in">addItem</span>(<span class="string">&quot;Item 2&quot;</span>);</span><br><span class="line">    listWidget.<span class="built_in">addItem</span>(<span class="string">&quot;Item 3&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加带有图标的列表项</span></span><br><span class="line">    QListWidgetItem *item4 = <span class="keyword">new</span> <span class="built_in">QListWidgetItem</span>(<span class="built_in">QIcon</span>(<span class="string">&quot;:/icons/icon.png&quot;</span>), <span class="string">&quot;Item 4&quot;</span>);</span><br><span class="line">    listWidget.<span class="built_in">addItem</span>(item4);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 响应列表项点击信号</span></span><br><span class="line">    QObject::<span class="built_in">connect</span>(&amp;listWidget, &amp;QListWidget::itemClicked, [&amp;](QListWidgetItem *item)&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;点击了：&quot;</span> &lt;&lt; item-&gt;<span class="built_in">text</span>();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示列表</span></span><br><span class="line">    listWidget.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<p><img src="https://i.imgur.com/STU2021.png" alt="QListWidget 示例"></p>
<p><strong>解释：</strong></p>
<ul>
<li><strong>QListWidget</strong>提供了一个简单的接口来管理列表项，无需手动创建模型。</li>
<li>使用<code>addItem</code>方法添加文本项或带有图标的项。</li>
<li>通过<code>itemClicked</code>信号连接到槽函数，响应用户的点击操作。</li>
</ul>
<h3 id="4-3-示例：使用QTreeWidget展示数据"><a href="#4-3-示例：使用QTreeWidget展示数据" class="headerlink" title="4.3 示例：使用QTreeWidget展示数据"></a>4.3 示例：使用QTreeWidget展示数据</h3><p>以下示例展示了如何使用QTreeWidget来展示和管理树形数据。</p>
<p><strong>示例代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTreeWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTreeWidgetItem&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建QTreeWidget</span></span><br><span class="line">    QTreeWidget treeWidget;</span><br><span class="line">    treeWidget.<span class="built_in">setWindowTitle</span>(<span class="string">&quot;QTreeWidget 示例&quot;</span>);</span><br><span class="line">    treeWidget.<span class="built_in">setColumnCount</span>(<span class="number">2</span>);</span><br><span class="line">    treeWidget.<span class="built_in">setHeaderLabels</span>(&#123;<span class="string">&quot;名称&quot;</span>, <span class="string">&quot;描述&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建根节点</span></span><br><span class="line">    QTreeWidgetItem *root = <span class="keyword">new</span> <span class="built_in">QTreeWidgetItem</span>(&amp;treeWidget);</span><br><span class="line">    root-&gt;<span class="built_in">setText</span>(<span class="number">0</span>, <span class="string">&quot;文件&quot;</span>);</span><br><span class="line">    root-&gt;<span class="built_in">setText</span>(<span class="number">1</span>, <span class="string">&quot;文件操作&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建子节点</span></span><br><span class="line">    QTreeWidgetItem *child1 = <span class="keyword">new</span> <span class="built_in">QTreeWidgetItem</span>(root);</span><br><span class="line">    child1-&gt;<span class="built_in">setText</span>(<span class="number">0</span>, <span class="string">&quot;新建&quot;</span>);</span><br><span class="line">    child1-&gt;<span class="built_in">setText</span>(<span class="number">1</span>, <span class="string">&quot;创建新文件&quot;</span>);</span><br><span class="line"></span><br><span class="line">    QTreeWidgetItem *child2 = <span class="keyword">new</span> <span class="built_in">QTreeWidgetItem</span>(root);</span><br><span class="line">    child2-&gt;<span class="built_in">setText</span>(<span class="number">0</span>, <span class="string">&quot;打开&quot;</span>);</span><br><span class="line">    child2-&gt;<span class="built_in">setText</span>(<span class="number">1</span>, <span class="string">&quot;打开现有文件&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 展开所有节点</span></span><br><span class="line">    treeWidget.<span class="built_in">expandAll</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 响应节点点击信号</span></span><br><span class="line">    QObject::<span class="built_in">connect</span>(&amp;treeWidget, &amp;QTreeWidget::itemClicked, [&amp;](QTreeWidgetItem *item, <span class="type">int</span> column)&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;点击了：&quot;</span> &lt;&lt; item-&gt;<span class="built_in">text</span>(<span class="number">0</span>) &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; item-&gt;<span class="built_in">text</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示树形视图</span></span><br><span class="line">    treeWidget.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<p><img src="https://i.imgur.com/VWX2223.png" alt="QTreeWidget 示例"></p>
<p><strong>解释：</strong></p>
<ul>
<li><strong>QTreeWidget</strong>提供了一个简化的接口来管理树形数据，无需手动创建模型。</li>
<li>使用<code>QTreeWidgetItem</code>创建根节点和子节点，并设置其文本内容。</li>
<li>通过<code>itemClicked</code>信号连接到槽函数，响应用户的点击操作。</li>
</ul>
<h3 id="4-4-示例：使用QTableWidget展示数据"><a href="#4-4-示例：使用QTableWidget展示数据" class="headerlink" title="4.4 示例：使用QTableWidget展示数据"></a>4.4 示例：使用QTableWidget展示数据</h3><p>以下示例展示了如何使用QTableWidget来展示和管理表格数据。</p>
<p><strong>示例代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTableWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTableWidgetItem&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建QTableWidget</span></span><br><span class="line">    QTableWidget tableWidget;</span><br><span class="line">    tableWidget.<span class="built_in">setWindowTitle</span>(<span class="string">&quot;QTableWidget 示例&quot;</span>);</span><br><span class="line">    tableWidget.<span class="built_in">setRowCount</span>(<span class="number">3</span>);</span><br><span class="line">    tableWidget.<span class="built_in">setColumnCount</span>(<span class="number">2</span>);</span><br><span class="line">    tableWidget.<span class="built_in">setHorizontalHeaderLabels</span>(&#123;<span class="string">&quot;姓名&quot;</span>, <span class="string">&quot;年龄&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填充数据</span></span><br><span class="line">    tableWidget.<span class="built_in">setItem</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">new</span> <span class="built_in">QTableWidgetItem</span>(<span class="string">&quot;Alice&quot;</span>));</span><br><span class="line">    tableWidget.<span class="built_in">setItem</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="keyword">new</span> <span class="built_in">QTableWidgetItem</span>(<span class="string">&quot;30&quot;</span>));</span><br><span class="line"></span><br><span class="line">    tableWidget.<span class="built_in">setItem</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="keyword">new</span> <span class="built_in">QTableWidgetItem</span>(<span class="string">&quot;Bob&quot;</span>));</span><br><span class="line">    tableWidget.<span class="built_in">setItem</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="keyword">new</span> <span class="built_in">QTableWidgetItem</span>(<span class="string">&quot;25&quot;</span>));</span><br><span class="line"></span><br><span class="line">    tableWidget.<span class="built_in">setItem</span>(<span class="number">2</span>, <span class="number">0</span>, <span class="keyword">new</span> <span class="built_in">QTableWidgetItem</span>(<span class="string">&quot;Charlie&quot;</span>));</span><br><span class="line">    tableWidget.<span class="built_in">setItem</span>(<span class="number">2</span>, <span class="number">1</span>, <span class="keyword">new</span> <span class="built_in">QTableWidgetItem</span>(<span class="string">&quot;35&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 响应单元格点击信号</span></span><br><span class="line">    QObject::<span class="built_in">connect</span>(&amp;tableWidget, &amp;QTableWidget::cellClicked, [&amp;](<span class="type">int</span> row, <span class="type">int</span> column)&#123;</span><br><span class="line">        QString name = tableWidget.<span class="built_in">item</span>(row, <span class="number">0</span>)-&gt;<span class="built_in">text</span>();</span><br><span class="line">        QString age = tableWidget.<span class="built_in">item</span>(row, <span class="number">1</span>)-&gt;<span class="built_in">text</span>();</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;点击了：&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; age;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示表格</span></span><br><span class="line">    tableWidget.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<p><img src="https://i.imgur.com/YZA2425.png" alt="QTableWidget 示例"></p>
<p><strong>解释：</strong></p>
<ul>
<li><strong>QTableWidget</strong>提供了一个简化的接口来管理表格数据，无需手动创建模型。</li>
<li>使用<code>setItem</code>方法填充表格单元格数据。</li>
<li>通过<code>cellClicked</code>信号连接到槽函数，响应用户的点击操作。</li>
</ul>
<h3 id="4-5-QTableWidget的高级功能"><a href="#4-5-QTableWidget的高级功能" class="headerlink" title="4.5 QTableWidget的高级功能"></a>4.5 QTableWidget的高级功能</h3><p><strong>设置单元格编辑属性：</strong></p>
<p>可以控制单元格的编辑行为，如只读、可编辑等。</p>
<p><strong>示例代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QTableWidgetItem *item = <span class="keyword">new</span> <span class="built_in">QTableWidgetItem</span>(<span class="string">&quot;Read-Only&quot;</span>);</span><br><span class="line">item-&gt;<span class="built_in">setFlags</span>(item-&gt;<span class="built_in">flags</span>() &amp; ~Qt::ItemIsEditable); <span class="comment">// 设置为只读</span></span><br><span class="line">tableWidget.<span class="built_in">setItem</span>(<span class="number">0</span>, <span class="number">0</span>, item);</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>使用<code>setFlags</code>方法修改单元格的标志，取消<code>Qt::ItemIsEditable</code>标志，将单元格设置为只读。</li>
</ul>
<h3 id="4-6-小结"><a href="#4-6-小结" class="headerlink" title="4.6 小结"></a>4.6 小结</h3><p>基于项的视图控件如QListWidget、QTreeWidget和QTableWidget提供了简化的数据展示和管理接口，适用于简单或中等复杂度的数据展示场景。它们易于使用，适合快速开发，但在处理大规模数据或需要高度定制化的场景时，基于模型的视图控件更为合适。</p>
<hr>
<h2 id="5-Input-Widgets"><a href="#5-Input-Widgets" class="headerlink" title="5. Input Widgets"></a>5. Input Widgets</h2><h3 id="5-1-输入控件概述"><a href="#5-1-输入控件概述" class="headerlink" title="5.1 输入控件概述"></a>5.1 输入控件概述</h3><p>输入控件用于获取用户的输入信息，是用户与应用程序交互的主要方式。Qt提供了多种输入控件，支持文本输入、数值输入、选择输入等多种形式。</p>
<h3 id="5-2-常用输入控件"><a href="#5-2-常用输入控件" class="headerlink" title="5.2 常用输入控件"></a>5.2 常用输入控件</h3><ul>
<li><strong>QLineEdit</strong>：单行文本输入框，用于接收用户的文本输入。</li>
<li><strong>QTextEdit</strong>：多行文本编辑器，用于接收和显示大量文本。</li>
<li><strong>QSpinBox</strong>：数值输入框，允许用户通过点击按钮或键盘输入整数值。</li>
<li><strong>QDoubleSpinBox</strong>：数值输入框，允许用户输入浮点数值。</li>
<li><strong>QComboBox</strong>：下拉列表框，允许用户从预定义选项中选择一项。</li>
<li><strong>QCheckBox</strong>：复选框，允许用户选择或取消选择某个选项。</li>
<li><strong>QRadioButton</strong>：单选按钮，允许用户在一组互斥的选项中选择一项。</li>
<li><strong>QSlider</strong>：滑块控件，允许用户通过拖动滑块选择一个范围内的数值。</li>
<li><strong>QDateEdit</strong>：日期输入框，允许用户选择日期。</li>
<li><strong>QTimeEdit</strong>：时间输入框，允许用户选择时间。</li>
</ul>
<h3 id="5-3-示例：使用QLineEdit和QPushButton获取用户输入"><a href="#5-3-示例：使用QLineEdit和QPushButton获取用户输入" class="headerlink" title="5.3 示例：使用QLineEdit和QPushButton获取用户输入"></a>5.3 示例：使用QLineEdit和QPushButton获取用户输入</h3><p>以下示例展示了如何使用QLineEdit获取用户的文本输入，并通过QPushButton触发操作。</p>
<p><strong>示例代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLineEdit&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QVBoxLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLabel&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建主窗口</span></span><br><span class="line">    QWidget window;</span><br><span class="line">    window.<span class="built_in">setWindowTitle</span>(<span class="string">&quot;输入控件示例&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建QLineEdit</span></span><br><span class="line">    QLineEdit *lineEdit = <span class="keyword">new</span> QLineEdit;</span><br><span class="line">    lineEdit-&gt;<span class="built_in">setPlaceholderText</span>(<span class="string">&quot;请输入您的姓名&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建QPushButton</span></span><br><span class="line">    QPushButton *btnSubmit = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;提交&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建QLabel显示结果</span></span><br><span class="line">    QLabel *label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;等待输入...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接按钮信号到槽</span></span><br><span class="line">    QObject::<span class="built_in">connect</span>(btnSubmit, &amp;QPushButton::clicked, [&amp;]()&#123;</span><br><span class="line">        QString name = lineEdit-&gt;<span class="built_in">text</span>();</span><br><span class="line">        <span class="keyword">if</span>(!name.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">            label-&gt;<span class="built_in">setText</span>(<span class="string">&quot;您好, &quot;</span> + name + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">            <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;用户输入：&quot;</span> &lt;&lt; name;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            label-&gt;<span class="built_in">setText</span>(<span class="string">&quot;请输入您的姓名。&quot;</span>);</span><br><span class="line">            <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;用户未输入姓名。&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建布局管理器</span></span><br><span class="line">    QVBoxLayout *vLayout = <span class="keyword">new</span> QVBoxLayout;</span><br><span class="line">    vLayout-&gt;<span class="built_in">addWidget</span>(lineEdit);</span><br><span class="line">    vLayout-&gt;<span class="built_in">addWidget</span>(btnSubmit);</span><br><span class="line">    vLayout-&gt;<span class="built_in">addWidget</span>(label);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置主窗口的布局</span></span><br><span class="line">    window.<span class="built_in">setLayout</span>(vLayout);</span><br><span class="line">    window.<span class="built_in">resize</span>(<span class="number">300</span>, <span class="number">150</span>);</span><br><span class="line">    window.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<p><img src="https://i.imgur.com/UVW2526.png" alt="输入控件示例"></p>
<p><strong>解释：</strong></p>
<ul>
<li><strong>QLineEdit</strong>用于获取用户的文本输入，设置了占位符提示“请输入您的姓名”。</li>
<li><strong>QPushButton</strong>用于触发提交操作，当用户点击按钮时，获取QLineEdit中的文本并更新QLabel显示。</li>
<li>通过<code>QObject::connect</code>将按钮的<code>clicked</code>信号连接到一个lambda槽函数，实现动态响应用户输入。</li>
</ul>
<h3 id="5-4-示例：使用QSpinBox和QSlider输入数值"><a href="#5-4-示例：使用QSpinBox和QSlider输入数值" class="headerlink" title="5.4 示例：使用QSpinBox和QSlider输入数值"></a>5.4 示例：使用QSpinBox和QSlider输入数值</h3><p>以下示例展示了如何使用QSpinBox和QSlider来获取和展示用户的数值输入。</p>
<p><strong>示例代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QSpinBox&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QSlider&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLabel&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QVBoxLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建主窗口</span></span><br><span class="line">    QWidget window;</span><br><span class="line">    window.<span class="built_in">setWindowTitle</span>(<span class="string">&quot;数值输入控件示例&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建QSpinBox</span></span><br><span class="line">    QSpinBox *spinBox = <span class="keyword">new</span> QSpinBox;</span><br><span class="line">    spinBox-&gt;<span class="built_in">setRange</span>(<span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">    spinBox-&gt;<span class="built_in">setValue</span>(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建QSlider</span></span><br><span class="line">    QSlider *slider = <span class="keyword">new</span> <span class="built_in">QSlider</span>(Qt::Horizontal);</span><br><span class="line">    slider-&gt;<span class="built_in">setRange</span>(<span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">    slider-&gt;<span class="built_in">setValue</span>(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建QLabel显示数值</span></span><br><span class="line">    QLabel *label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;当前值: 50&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接SpinBox和Slider的值变化信号到槽</span></span><br><span class="line">    QObject::<span class="built_in">connect</span>(spinBox, QOverload&lt;<span class="type">int</span>&gt;::<span class="built_in">of</span>(&amp;QSpinBox::valueChanged), [&amp;](<span class="type">int</span> value)&#123;</span><br><span class="line">        slider-&gt;<span class="built_in">setValue</span>(value);</span><br><span class="line">        label-&gt;<span class="built_in">setText</span>(<span class="string">&quot;当前值: &quot;</span> + QString::<span class="built_in">number</span>(value));</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;SpinBox值变化:&quot;</span> &lt;&lt; value;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    QObject::<span class="built_in">connect</span>(slider, &amp;QSlider::valueChanged, [&amp;](<span class="type">int</span> value)&#123;</span><br><span class="line">        spinBox-&gt;<span class="built_in">setValue</span>(value);</span><br><span class="line">        label-&gt;<span class="built_in">setText</span>(<span class="string">&quot;当前值: &quot;</span> + QString::<span class="built_in">number</span>(value));</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Slider值变化:&quot;</span> &lt;&lt; value;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建布局管理器</span></span><br><span class="line">    QVBoxLayout *vLayout = <span class="keyword">new</span> QVBoxLayout;</span><br><span class="line">    vLayout-&gt;<span class="built_in">addWidget</span>(spinBox);</span><br><span class="line">    vLayout-&gt;<span class="built_in">addWidget</span>(slider);</span><br><span class="line">    vLayout-&gt;<span class="built_in">addWidget</span>(label);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置主窗口的布局</span></span><br><span class="line">    window.<span class="built_in">setLayout</span>(vLayout);</span><br><span class="line">    window.<span class="built_in">resize</span>(<span class="number">300</span>, <span class="number">200</span>);</span><br><span class="line">    window.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<p><img src="https://i.imgur.com/XYZ2829.png" alt="数值输入控件示例"></p>
<p><strong>解释：</strong></p>
<ul>
<li><strong>QSpinBox</strong>和<strong>QSlider</strong>都用于获取用户的数值输入，范围设置为0到100，初始值为50。</li>
<li>当用户在SpinBox或Slider中改变数值时，通过信号与槽机制同步更新对方的值，并在QLabel中显示当前值。</li>
<li>通过<code>QOverload&lt;int&gt;::of</code>语法解决了信号重载的问题，确保信号与槽的正确连接。</li>
</ul>
<h3 id="5-5-QComboBox的高级用法"><a href="#5-5-QComboBox的高级用法" class="headerlink" title="5.5 QComboBox的高级用法"></a>5.5 QComboBox的高级用法</h3><p><strong>添加可编辑项和自定义绘制：</strong></p>
<p>可以设置QComboBox为可编辑状态，并自定义每个项的显示内容。</p>
<p><strong>示例代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QComboBox&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建QComboBox</span></span><br><span class="line">    QComboBox comboBox;</span><br><span class="line">    comboBox.<span class="built_in">setWindowTitle</span>(<span class="string">&quot;QComboBox 示例&quot;</span>);</span><br><span class="line">    comboBox.<span class="built_in">setEditable</span>(<span class="literal">true</span>); <span class="comment">// 设置为可编辑</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加项</span></span><br><span class="line">    comboBox.<span class="built_in">addItem</span>(<span class="string">&quot;Option 1&quot;</span>);</span><br><span class="line">    comboBox.<span class="built_in">addItem</span>(<span class="string">&quot;Option 2&quot;</span>);</span><br><span class="line">    comboBox.<span class="built_in">addItem</span>(<span class="string">&quot;Option 3&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加带有用户数据的项</span></span><br><span class="line">    comboBox.<span class="built_in">addItem</span>(<span class="string">&quot;Option 4&quot;</span>, <span class="built_in">QVariant</span>(<span class="number">42</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接信号到槽</span></span><br><span class="line">    QObject::<span class="built_in">connect</span>(&amp;comboBox, QOverload&lt;<span class="type">int</span>&gt;::<span class="built_in">of</span>(&amp;QComboBox::currentIndexChanged), [&amp;](<span class="type">int</span> index)&#123;</span><br><span class="line">        QString text = comboBox.<span class="built_in">currentText</span>();</span><br><span class="line">        QVariant data = comboBox.<span class="built_in">itemData</span>(index);</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;当前选中项：&quot;</span> &lt;&lt; text &lt;&lt; <span class="string">&quot;, 数据：&quot;</span> &lt;&lt; data.<span class="built_in">toInt</span>();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示QComboBox</span></span><br><span class="line">    comboBox.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<p><img src="https://i.imgur.com/BCD3031.png" alt="QComboBox 示例"></p>
<p><strong>解释：</strong></p>
<ul>
<li><strong>QComboBox</strong>设置为可编辑，允许用户输入自定义文本。</li>
<li>使用<code>addItem</code>方法添加带有用户数据的项，通过<code>itemData</code>方法获取关联的数据。</li>
<li>通过<code>currentIndexChanged</code>信号连接到槽函数，实时响应用户的选择变化。</li>
</ul>
<h3 id="5-6-小结"><a href="#5-6-小结" class="headerlink" title="5.6 小结"></a>5.6 小结</h3><p>输入控件是用户与应用程序交互的桥梁，Qt提供了丰富的输入控件来满足不同的输入需求。通过合理选择和配置输入控件，可以提升用户体验，确保应用程序的易用性和功能性。</p>
<hr>
<h2 id="6-Display-Widgets"><a href="#6-Display-Widgets" class="headerlink" title="6. Display Widgets"></a>6. Display Widgets</h2><h3 id="6-1-显示控件概述"><a href="#6-1-显示控件概述" class="headerlink" title="6.1 显示控件概述"></a>6.1 显示控件概述</h3><p>显示控件用于展示信息和数据，是用户界面中不可或缺的一部分。Qt提供了多种显示控件，支持文本显示、图像显示、进度显示等多种形式。</p>
<h3 id="6-2-常用显示控件"><a href="#6-2-常用显示控件" class="headerlink" title="6.2 常用显示控件"></a>6.2 常用显示控件</h3><ul>
<li><strong>QLabel</strong>：标签控件，用于显示文本或图像。</li>
<li><strong>QTextBrowser</strong>：文本浏览器，用于显示富文本内容，支持超链接。</li>
<li><strong>QProgressBar</strong>：进度条控件，用于显示任务的完成进度。</li>
<li><strong>QLCDNumber</strong>：LCD数字显示控件，用于显示数字信息。</li>
<li><strong>QDial</strong>：旋钮控件，类似于音量调节器。</li>
<li><strong>QLCDNumber</strong>：LCD样式的数字显示控件。</li>
<li><strong>QToolTip</strong>：提示工具，用于显示悬停提示信息。</li>
</ul>
<h3 id="6-3-示例：使用QLabel显示文本和图像"><a href="#6-3-示例：使用QLabel显示文本和图像" class="headerlink" title="6.3 示例：使用QLabel显示文本和图像"></a>6.3 示例：使用QLabel显示文本和图像</h3><p>以下示例展示了如何使用QLabel来显示文本和图像。</p>
<p><strong>示例代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLabel&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPixmap&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QVBoxLayout&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建主窗口</span></span><br><span class="line">    QWidget window;</span><br><span class="line">    window.<span class="built_in">setWindowTitle</span>(<span class="string">&quot;QLabel 示例&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建QLabel用于显示文本</span></span><br><span class="line">    QLabel *textLabel = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;欢迎使用Qt！&quot;</span>);</span><br><span class="line">    textLabel-&gt;<span class="built_in">setAlignment</span>(Qt::AlignCenter);</span><br><span class="line">    textLabel-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;QLabel &#123; font-size: 24px; color: blue; &#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建QLabel用于显示图像</span></span><br><span class="line">    QLabel *imageLabel = <span class="keyword">new</span> QLabel;</span><br><span class="line">    <span class="function">QPixmap <span class="title">pixmap</span><span class="params">(<span class="string">&quot;:/images/logo.png&quot;</span>)</span></span>; <span class="comment">// 确保资源文件中有此图像</span></span><br><span class="line">    imageLabel-&gt;<span class="built_in">setPixmap</span>(pixmap.<span class="built_in">scaled</span>(<span class="number">200</span>, <span class="number">200</span>, Qt::KeepAspectRatio));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建布局管理器</span></span><br><span class="line">    QVBoxLayout *vLayout = <span class="keyword">new</span> QVBoxLayout;</span><br><span class="line">    vLayout-&gt;<span class="built_in">addWidget</span>(textLabel);</span><br><span class="line">    vLayout-&gt;<span class="built_in">addWidget</span>(imageLabel);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置主窗口的布局</span></span><br><span class="line">    window.<span class="built_in">setLayout</span>(vLayout);</span><br><span class="line">    window.<span class="built_in">resize</span>(<span class="number">300</span>, <span class="number">400</span>);</span><br><span class="line">    window.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<p><img src="https://i.imgur.com/EFG3242.png" alt="QLabel 示例"></p>
<p><strong>解释：</strong></p>
<ul>
<li><strong>QLabel</strong>用于显示居中的文本，设置了自定义的字体大小和颜色。</li>
<li><strong>QLabel</strong>还可以用于显示图像，通过设置QPixmap实现。</li>
<li>使用<code>scaled</code>方法调整图像大小，保持纵横比不变。</li>
</ul>
<h3 id="6-4-示例：使用QProgressBar显示任务进度"><a href="#6-4-示例：使用QProgressBar显示任务进度" class="headerlink" title="6.4 示例：使用QProgressBar显示任务进度"></a>6.4 示例：使用QProgressBar显示任务进度</h3><p>以下示例展示了如何使用QProgressBar来显示任务的完成进度，并通过按钮控制进度条的更新。</p>
<p><strong>示例代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QProgressBar&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QVBoxLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTimer&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建主窗口</span></span><br><span class="line">    QWidget window;</span><br><span class="line">    window.<span class="built_in">setWindowTitle</span>(<span class="string">&quot;QProgressBar 示例&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建QProgressBar</span></span><br><span class="line">    QProgressBar *progressBar = <span class="keyword">new</span> QProgressBar;</span><br><span class="line">    progressBar-&gt;<span class="built_in">setRange</span>(<span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">    progressBar-&gt;<span class="built_in">setValue</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建QPushButton</span></span><br><span class="line">    QPushButton *btnStart = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;开始任务&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建布局管理器</span></span><br><span class="line">    QVBoxLayout *vLayout = <span class="keyword">new</span> QVBoxLayout;</span><br><span class="line">    vLayout-&gt;<span class="built_in">addWidget</span>(progressBar);</span><br><span class="line">    vLayout-&gt;<span class="built_in">addWidget</span>(btnStart);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置主窗口的布局</span></span><br><span class="line">    window.<span class="built_in">setLayout</span>(vLayout);</span><br><span class="line">    window.<span class="built_in">resize</span>(<span class="number">300</span>, <span class="number">150</span>);</span><br><span class="line">    window.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建计时器</span></span><br><span class="line">    QTimer timer;</span><br><span class="line">    timer.<span class="built_in">setInterval</span>(<span class="number">100</span>); <span class="comment">// 每100毫秒更新一次</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> progress = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接按钮信号到槽函数</span></span><br><span class="line">    QObject::<span class="built_in">connect</span>(btnStart, &amp;QPushButton::clicked, [&amp;]()&#123;</span><br><span class="line">        progress = <span class="number">0</span>;</span><br><span class="line">        progressBar-&gt;<span class="built_in">setValue</span>(progress);</span><br><span class="line">        timer.<span class="built_in">start</span>();</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;任务开始&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接计时器信号到槽函数</span></span><br><span class="line">    QObject::<span class="built_in">connect</span>(&amp;timer, &amp;QTimer::timeout, [&amp;]()&#123;</span><br><span class="line">        progress += <span class="number">1</span>;</span><br><span class="line">        progressBar-&gt;<span class="built_in">setValue</span>(progress);</span><br><span class="line">        <span class="keyword">if</span>(progress &gt;= <span class="number">100</span>) &#123;</span><br><span class="line">            timer.<span class="built_in">stop</span>();</span><br><span class="line">            <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;任务完成&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<p><img src="https://i.imgur.com/HJK3434.png" alt="QProgressBar 示例"></p>
<p><strong>解释：</strong></p>
<ul>
<li><strong>QProgressBar</strong>设置了范围从0到100，初始值为0。</li>
<li><strong>QPushButton</strong>用于启动任务，当按钮被点击时，进度条开始自动更新。</li>
<li><strong>QTimer</strong>用于模拟任务进度的逐步完成，通过<code>timeout</code>信号更新进度条的值。</li>
<li>当进度达到100时，停止计时器并打印任务完成的信息。</li>
</ul>
<h3 id="6-5-示例：使用QLCDNumber显示动态数字"><a href="#6-5-示例：使用QLCDNumber显示动态数字" class="headerlink" title="6.5 示例：使用QLCDNumber显示动态数字"></a>6.5 示例：使用QLCDNumber显示动态数字</h3><p>以下示例展示了如何使用QLCDNumber动态显示数字，并通过QTimer更新显示内容。</p>
<p><strong>示例代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLCDNumber&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QVBoxLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTimer&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建主窗口</span></span><br><span class="line">    QWidget window;</span><br><span class="line">    window.<span class="built_in">setWindowTitle</span>(<span class="string">&quot;QLCDNumber 示例&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建QLCDNumber</span></span><br><span class="line">    QLCDNumber *lcd = <span class="keyword">new</span> QLCDNumber;</span><br><span class="line">    lcd-&gt;<span class="built_in">setDigitCount</span>(<span class="number">5</span>);</span><br><span class="line">    lcd-&gt;<span class="built_in">display</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建布局管理器</span></span><br><span class="line">    QVBoxLayout *vLayout = <span class="keyword">new</span> QVBoxLayout;</span><br><span class="line">    vLayout-&gt;<span class="built_in">addWidget</span>(lcd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置主窗口的布局</span></span><br><span class="line">    window.<span class="built_in">setLayout</span>(vLayout);</span><br><span class="line">    window.<span class="built_in">resize</span>(<span class="number">200</span>, <span class="number">100</span>);</span><br><span class="line">    window.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建计时器</span></span><br><span class="line">    QTimer timer;</span><br><span class="line">    timer.<span class="built_in">setInterval</span>(<span class="number">1000</span>); <span class="comment">// 每秒更新一次</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接计时器信号到槽函数</span></span><br><span class="line">    QObject::<span class="built_in">connect</span>(&amp;timer, &amp;QTimer::timeout, [&amp;]()&#123;</span><br><span class="line">        count++;</span><br><span class="line">        lcd-&gt;<span class="built_in">display</span>(count);</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;当前计数:&quot;</span> &lt;&lt; count;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    timer.<span class="built_in">start</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<p><img src="https://i.imgur.com/IJK4545.png" alt="QLCDNumber 示例"></p>
<p><strong>解释：</strong></p>
<ul>
<li><strong>QLCDNumber</strong>设置了5位数字显示，初始值为0。</li>
<li><strong>QTimer</strong>每秒触发一次，通过<code>timeout</code>信号更新显示的数字，实现动态计数效果。</li>
<li>通过<code>lcd-&gt;display(count)</code>方法更新显示内容，实时反映计数变化。</li>
</ul>
<h3 id="6-6-QProgressBar与QLCDNumber的结合使用"><a href="#6-6-QProgressBar与QLCDNumber的结合使用" class="headerlink" title="6.6 QProgressBar与QLCDNumber的结合使用"></a>6.6 QProgressBar与QLCDNumber的结合使用</h3><p>可以将QProgressBar和QLCDNumber结合使用，实时显示任务的进度和完成度。</p>
<p><strong>示例代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QProgressBar&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLCDNumber&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QVBoxLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTimer&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建主窗口</span></span><br><span class="line">    QWidget window;</span><br><span class="line">    window.<span class="built_in">setWindowTitle</span>(<span class="string">&quot;进度与数字显示示例&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建QProgressBar</span></span><br><span class="line">    QProgressBar *progressBar = <span class="keyword">new</span> QProgressBar;</span><br><span class="line">    progressBar-&gt;<span class="built_in">setRange</span>(<span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">    progressBar-&gt;<span class="built_in">setValue</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建QLCDNumber</span></span><br><span class="line">    QLCDNumber *lcd = <span class="keyword">new</span> QLCDNumber;</span><br><span class="line">    lcd-&gt;<span class="built_in">setDigitCount</span>(<span class="number">3</span>);</span><br><span class="line">    lcd-&gt;<span class="built_in">display</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建QPushButton</span></span><br><span class="line">    QPushButton *btnStart = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;开始任务&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建布局管理器</span></span><br><span class="line">    QVBoxLayout *vLayout = <span class="keyword">new</span> QVBoxLayout;</span><br><span class="line">    vLayout-&gt;<span class="built_in">addWidget</span>(progressBar);</span><br><span class="line">    vLayout-&gt;<span class="built_in">addWidget</span>(lcd);</span><br><span class="line">    vLayout-&gt;<span class="built_in">addWidget</span>(btnStart);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置主窗口的布局</span></span><br><span class="line">    window.<span class="built_in">setLayout</span>(vLayout);</span><br><span class="line">    window.<span class="built_in">resize</span>(<span class="number">300</span>, <span class="number">200</span>);</span><br><span class="line">    window.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建计时器</span></span><br><span class="line">    QTimer timer;</span><br><span class="line">    timer.<span class="built_in">setInterval</span>(<span class="number">100</span>); <span class="comment">// 每100毫秒更新一次</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> progress = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接按钮信号到槽函数</span></span><br><span class="line">    QObject::<span class="built_in">connect</span>(btnStart, &amp;QPushButton::clicked, [&amp;]()&#123;</span><br><span class="line">        progress = <span class="number">0</span>;</span><br><span class="line">        progressBar-&gt;<span class="built_in">setValue</span>(progress);</span><br><span class="line">        lcd-&gt;<span class="built_in">display</span>(progress);</span><br><span class="line">        timer.<span class="built_in">start</span>();</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;任务开始&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接计时器信号到槽函数</span></span><br><span class="line">    QObject::<span class="built_in">connect</span>(&amp;timer, &amp;QTimer::timeout, [&amp;]()&#123;</span><br><span class="line">        progress += <span class="number">1</span>;</span><br><span class="line">        progressBar-&gt;<span class="built_in">setValue</span>(progress);</span><br><span class="line">        lcd-&gt;<span class="built_in">display</span>(progress);</span><br><span class="line">        <span class="keyword">if</span>(progress &gt;= <span class="number">100</span>) &#123;</span><br><span class="line">            timer.<span class="built_in">stop</span>();</span><br><span class="line">            <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;任务完成&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<p><img src="https://i.imgur.com/JKL5656.png" alt="进度与数字显示示例"></p>
<p><strong>解释：</strong></p>
<ul>
<li><strong>QProgressBar</strong>和<strong>QLCDNumber</strong>分别显示任务的进度和当前进度值。</li>
<li>当用户点击“开始任务”按钮时，计时器开始，每100毫秒更新一次进度条和数字显示。</li>
<li>当进度达到100时，停止计时器并打印任务完成的信息。</li>
</ul>
<h3 id="6-7-小结"><a href="#6-7-小结" class="headerlink" title="6.7 小结"></a>6.7 小结</h3><p>显示控件在用户界面中用于展示各种信息和数据。通过合理使用QLabel、QProgressBar、QLCDNumber等显示控件，可以有效地传达应用程序的状态和反馈，提升用户体验。同时，结合布局管理器和其他控件，能够创建功能丰富且美观的用户界面。</p>
<hr>
<h2 id="7-常用算法及正则表达式"><a href="#7-常用算法及正则表达式" class="headerlink" title="7. 常用算法及正则表达式"></a>7. 常用算法及正则表达式</h2><h3 id="7-1-Qt中提供的常用算法"><a href="#7-1-Qt中提供的常用算法" class="headerlink" title="7.1 Qt中提供的常用算法"></a>7.1 Qt中提供的常用算法</h3><p>Qt提供了一系列与标准C++库类似的算法，主要集中在<code>QtAlgorithms</code>模块。这些算法包括排序、查找、遍历等，帮助开发者高效地处理数据。</p>
<h3 id="7-2-示例：使用Qt算法进行排序和查找"><a href="#7-2-示例：使用Qt算法进行排序和查找" class="headerlink" title="7.2 示例：使用Qt算法进行排序和查找"></a>7.2 示例：使用Qt算法进行排序和查找</h3><p><strong>示例代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QVector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    QVector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;排序前:&quot;</span> &lt;&lt; numbers;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用std::sort进行升序排序</span></span><br><span class="line">    std::<span class="built_in">sort</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;排序后:&quot;</span> &lt;&lt; numbers;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用std::binary_search查找元素</span></span><br><span class="line">    <span class="type">bool</span> found = std::<span class="built_in">binary_search</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;是否找到5:&quot;</span> &lt;&lt; found;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">排序前: QVector(5, 2, 9, 1, 5, 6)</span><br><span class="line">排序后: QVector(1, 2, 5, 5, 6, 9)</span><br><span class="line">是否找到5: true</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>使用<code>std::sort</code>对QVector中的整数进行升序排序。</li>
<li>使用<code>std::binary_search</code>在排序后的QVector中查找特定元素。</li>
</ul>
<h3 id="7-3-Qt中的正则表达式支持"><a href="#7-3-Qt中的正则表达式支持" class="headerlink" title="7.3 Qt中的正则表达式支持"></a>7.3 Qt中的正则表达式支持</h3><p>Qt提供了强大的正则表达式支持，通过<code>QRegularExpression</code>类实现复杂的文本匹配和处理功能。</p>
<h3 id="7-4-示例：使用QRegularExpression进行模式匹配"><a href="#7-4-示例：使用QRegularExpression进行模式匹配" class="headerlink" title="7.4 示例：使用QRegularExpression进行模式匹配"></a>7.4 示例：使用QRegularExpression进行模式匹配</h3><p><strong>示例代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QString&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QRegularExpression&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    QString text = <span class="string">&quot;Contact us at support@example.com or sales@example.org.&quot;</span>;</span><br><span class="line">    <span class="function">QRegularExpression <span class="title">emailRegex</span><span class="params">(<span class="string">R&quot;((\w+@\w+\.\w+))&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    QRegularExpressionMatchIterator i = emailRegex.<span class="built_in">globalMatch</span>(text);</span><br><span class="line">    <span class="keyword">while</span> (i.<span class="built_in">hasNext</span>()) &#123;</span><br><span class="line">        QRegularExpressionMatch match = i.<span class="built_in">next</span>();</span><br><span class="line">        QString email = match.<span class="built_in">captured</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;找到邮箱:&quot;</span> &lt;&lt; email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">找到邮箱: &quot;support@example.com&quot;</span><br><span class="line">找到邮箱: &quot;sales@example.org&quot;</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>使用<code>QRegularExpression</code>定义一个匹配邮箱地址的正则表达式。</li>
<li>使用<code>globalMatch</code>方法获取所有匹配项，并通过迭代器遍历匹配结果。</li>
</ul>
<h3 id="7-5-示例：使用QString-replace与QRegularExpression进行复杂替换"><a href="#7-5-示例：使用QString-replace与QRegularExpression进行复杂替换" class="headerlink" title="7.5 示例：使用QString::replace与QRegularExpression进行复杂替换"></a>7.5 示例：使用QString::replace与QRegularExpression进行复杂替换</h3><p><strong>示例代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QString&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QRegularExpression&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    QString text = <span class="string">&quot;The quick brown fox jumps over the lazy dog.&quot;</span>;</span><br><span class="line">    <span class="function">QRegularExpression <span class="title">regex</span><span class="params">(<span class="string">R&quot;(quick\s+brown\s+fox)&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    QString replacedText = text.<span class="built_in">replace</span>(regex, <span class="string">&quot;swift red fox&quot;</span>);</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;替换后:&quot;</span> &lt;&lt; replacedText;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">替换后: &quot;The swift red fox jumps over the lazy dog.&quot;</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>使用正则表达式匹配“quick brown fox”模式。</li>
<li>使用<code>replace</code>方法将匹配的部分替换为“swift red fox”。</li>
</ul>
<h3 id="7-6-小结"><a href="#7-6-小结" class="headerlink" title="7.6 小结"></a>7.6 小结</h3><p>Qt中的常用算法和正则表达式支持为数据处理和文本匹配提供了强大的工具。通过合理使用这些功能，开发者可以实现高效且复杂的数据操作和文本处理逻辑，提升应用程序的功能性和用户体验。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文详细介绍了Qt开发中常用的控件类别，包括布局管理器与间隔控件、按钮与容器控件、基于模型的视图控件、基于项的视图控件、输入控件以及显示控件。同时，探讨了Qt中常用的算法和正则表达式支持，展示了如何在实际项目中应用这些功能。</p>
<h3 id="主要内容回顾："><a href="#主要内容回顾：" class="headerlink" title="主要内容回顾："></a>主要内容回顾：</h3><ol>
<li><p><strong>Layouts &amp; Spacers</strong>：</p>
<ul>
<li>讲解了不同类型的布局管理器（QHBoxLayout、QVBoxLayout、QGridLayout、QFormLayout）及其应用。</li>
<li>介绍了QSpacerItem的使用，帮助优化控件间的间距和布局。</li>
</ul>
</li>
<li><p><strong>Buttons &amp; Containers</strong>：</p>
<ul>
<li>介绍了各种按钮控件（QPushButton、QToolButton、QRadioButton、QCheckBox、QCommandLinkButton）的使用方法和应用场景。</li>
<li>探讨了容器控件（QGroupBox、QFrame、QScrollArea）的功能和使用技巧。</li>
</ul>
</li>
<li><p><strong>Item Views</strong>：</p>
<ul>
<li>说明了基于模型的视图控件（QListView、QTableView、QTreeView）的使用方法及其在数据展示中的优势。</li>
<li>通过示例展示了如何结合模型类（QStringListModel、QStandardItemModel）使用视图控件。</li>
</ul>
</li>
<li><p><strong>Item Widgets</strong>：</p>
<ul>
<li>介绍了基于项的视图控件（QListWidget、QTreeWidget、QTableWidget）的简化接口和使用方法。</li>
<li>通过示例展示了如何快速创建和管理项视图控件。</li>
</ul>
</li>
<li><p><strong>Input Widgets</strong>：</p>
<ul>
<li>讲解了常用的输入控件（QLineEdit、QTextEdit、QSpinBox、QDoubleSpinBox、QComboBox、QCheckBox、QRadioButton、QSlider、QDateEdit、QTimeEdit）的功能和使用场景。</li>
<li>通过示例展示了如何获取和处理用户输入。</li>
</ul>
</li>
<li><p><strong>Display Widgets</strong>：</p>
<ul>
<li>介绍了常用的显示控件（QLabel、QTextBrowser、QProgressBar、QLCDNumber、QDial、QToolTip）的使用方法和应用场景。</li>
<li>通过示例展示了如何动态更新和展示信息。</li>
</ul>
</li>
<li><p><strong>常用算法及正则表达式</strong>：</p>
<ul>
<li>探讨了Qt提供的常用算法函数，如排序、查找和遍历。</li>
<li>介绍了Qt中强大的正则表达式支持，通过QRegularExpression实现复杂的文本匹配和处理。</li>
</ul>
</li>
</ol>
<h3 id="下一步学习建议："><a href="#下一步学习建议：" class="headerlink" title="下一步学习建议："></a>下一步学习建议：</h3><p>掌握了Qt开发常用控件的使用方法后，建议继续深入学习以下高级内容，以全面提升Qt C++编程能力：</p>
<ul>
<li><p><strong>类型特性检测：<code>type_traits</code>库的应用</strong>：</p>
<ul>
<li>学习如何使用<code>std::is_integral</code>、<code>std::is_rvalue_reference</code>、<code>std::is_arithmetic</code>、<code>std::is_volatile</code>、<code>std::is_class</code>等进行类型判断，辅助模板元编程。</li>
</ul>
</li>
<li><p><strong>变量模板与内联变量（C++14）</strong>：</p>
<ul>
<li>探索C++14中的变量模板和<code>inline</code>变量的概念，了解它们在实际编程中的应用。</li>
</ul>
</li>
<li><p><strong>多线程编程的高级工具</strong>：</p>
<ul>
<li>深入了解线程局部存储、锁的优化策略、线程池等高级多线程编程工具，提升并发编程的能力。</li>
</ul>
</li>
<li><p><strong>模板编程的高级技巧</strong>：</p>
<ul>
<li>掌握模板元编程、SFINAE（替换失败不是错误）等高级模板编程技术，提升代码的泛化和复用能力。</li>
</ul>
</li>
<li><p><strong>Qt框架的核心概念与高级功能</strong>：</p>
<ul>
<li>深入学习Qt的信号与槽机制、事件处理、模型-视图架构、Qt Quick等高级功能，构建更复杂和功能丰富的应用程序。</li>
</ul>
</li>
<li><p><strong>数据库集成与操作</strong>：</p>
<ul>
<li>学习Qt的数据库模块，了解如何集成和操作不同类型的数据库，进行数据持久化管理。</li>
</ul>
</li>
<li><p><strong>网络编程</strong>：</p>
<ul>
<li>探索Qt的网络模块，掌握TCP&#x2F;IP通信、HTTP请求处理等网络编程技能。</li>
</ul>
</li>
<li><p><strong>图形用户界面设计</strong>：</p>
<ul>
<li>学习Qt Designer的高级使用技巧，设计复杂的用户界面，并结合动画和样式表提升界面体验。</li>
</ul>
</li>
<li><p><strong>资源管理与多语言支持</strong>：</p>
<ul>
<li>掌握Qt的资源系统，管理应用程序资源，了解如何实现多语言支持，提升应用的国际化能力。</li>
</ul>
</li>
</ul>
<p>通过持续学习和实践，结合本文所介绍的基础知识，您将能够更加高效地利用Qt框架进行C++开发，构建出功能丰富、性能优异且用户友好的应用程序。</p>
<hr>
<p><em>感谢您的阅读与支持！如果您对本文内容有任何疑问或建议，欢迎在评论区留言与我们交流。请继续关注我们的系列文章，深入了解Qt C++开发的更多高级特性和实战技巧。</em></p>
]]></content>
  </entry>
  <entry>
    <title>Qt开发常用控件详解(2)</title>
    <url>/2024/12/26/Qt%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E6%8E%A7%E4%BB%B6%E8%AF%A6%E8%A7%A3-2/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><span id="more"></span>

<h1 id="Qt开发常用控件详解（2）"><a href="#Qt开发常用控件详解（2）" class="headerlink" title="Qt开发常用控件详解（2）"></a>Qt开发常用控件详解（2）</h1><p>在Qt框架中，控件（Widgets）是构建图形用户界面的基石。Qt提供了丰富的控件库，涵盖了布局管理、按钮、容器、视图、输入和显示等各个方面，满足不同应用场景的需求。掌握这些常用控件的使用方法和最佳实践，是高效开发Qt应用程序的关键。本文将详细介绍Qt开发中常用的控件类别，包括布局管理器和空白控件、按钮与容器控件、基于模型的视图控件、基于项的视图控件、输入控件以及显示控件。通过这些内容的学习，您将能够构建美观、功能丰富且高效的用户界面。</p>
<hr>
<h2 id="1-Layouts-amp-Spacers"><a href="#1-Layouts-amp-Spacers" class="headerlink" title="1. Layouts &amp; Spacers"></a>1. Layouts &amp; Spacers</h2><h3 id="1-1-布局管理器（Layouts）"><a href="#1-1-布局管理器（Layouts）" class="headerlink" title="1.1 布局管理器（Layouts）"></a>1.1 布局管理器（Layouts）</h3><p>布局管理器用于自动排列和调整控件的大小，以适应不同的窗口尺寸和分辨率。Qt提供了多种布局管理器，每种布局管理器适用于不同的布局需求。</p>
<h4 id="常用布局管理器"><a href="#常用布局管理器" class="headerlink" title="常用布局管理器"></a>常用布局管理器</h4><ul>
<li><strong>QHBoxLayout</strong>：水平布局管理器，按水平方向排列控件。</li>
<li><strong>QVBoxLayout</strong>：垂直布局管理器，按垂直方向排列控件。</li>
<li><strong>QGridLayout</strong>：网格布局管理器，按行和列排列控件。</li>
<li><strong>QFormLayout</strong>：表单布局管理器，适用于表单输入界面。</li>
</ul>
<h4 id="示例：使用QVBoxLayout和QHBoxLayout"><a href="#示例：使用QVBoxLayout和QHBoxLayout" class="headerlink" title="示例：使用QVBoxLayout和QHBoxLayout"></a>示例：使用QVBoxLayout和QHBoxLayout</h4><p>以下示例展示了如何使用<code>QVBoxLayout</code>和<code>QHBoxLayout</code>结合布局管理器来设计一个简洁美观的用户界面。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QHBoxLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QVBoxLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QSpacerItem&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建主窗口</span></span><br><span class="line">    QWidget window;</span><br><span class="line">    window.<span class="built_in">setWindowTitle</span>(<span class="string">&quot;布局管理器示例&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建按钮</span></span><br><span class="line">    QPushButton *button1 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;按钮1&quot;</span>);</span><br><span class="line">    QPushButton *button2 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;按钮2&quot;</span>);</span><br><span class="line">    QPushButton *button3 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;按钮3&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建水平布局管理器</span></span><br><span class="line">    QHBoxLayout *hLayout = <span class="keyword">new</span> QHBoxLayout;</span><br><span class="line">    hLayout-&gt;<span class="built_in">addWidget</span>(button1);</span><br><span class="line">    hLayout-&gt;<span class="built_in">addWidget</span>(button2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加间隔控件，将button3推向右侧</span></span><br><span class="line">    QSpacerItem *spacer = <span class="keyword">new</span> <span class="built_in">QSpacerItem</span>(<span class="number">40</span>, <span class="number">20</span>, QSizePolicy::Expanding, QSizePolicy::Minimum);</span><br><span class="line">    hLayout-&gt;<span class="built_in">addItem</span>(spacer);</span><br><span class="line">    hLayout-&gt;<span class="built_in">addWidget</span>(button3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建垂直布局管理器</span></span><br><span class="line">    QVBoxLayout *vLayout = <span class="keyword">new</span> QVBoxLayout;</span><br><span class="line">    vLayout-&gt;<span class="built_in">addLayout</span>(hLayout);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置主窗口的布局</span></span><br><span class="line">    window.<span class="built_in">setLayout</span>(vLayout);</span><br><span class="line">    window.<span class="built_in">resize</span>(<span class="number">400</span>, <span class="number">200</span>);</span><br><span class="line">    window.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<p><img src="https://i.imgur.com/XYZ1234.png" alt="布局管理器示例"></p>
<p><strong>解释：</strong></p>
<ul>
<li><strong>QHBoxLayout</strong>用于水平排列按钮1和按钮2。</li>
<li><strong>QSpacerItem</strong>被添加到水平布局中，起到弹性空间的作用，将按钮3推向布局的右侧。</li>
<li><strong>QVBoxLayout</strong>将水平布局嵌套在垂直布局中，确保界面在垂直方向上的灵活性。</li>
</ul>
<h3 id="1-2-Spacer（间隔控件）"><a href="#1-2-Spacer（间隔控件）" class="headerlink" title="1.2 Spacer（间隔控件）"></a>1.2 Spacer（间隔控件）</h3><p>间隔控件用于在布局中添加弹性空间，帮助控件之间保持适当的间距或将控件推向布局的一侧。Qt提供了两种主要的间隔控件：</p>
<ul>
<li><strong>QSpacerItem</strong>：通用的间隔项，可用于任何布局中。</li>
<li><strong>QSpacerWidget</strong>：基于QWidget的间隔控件，已在Qt 5中弃用，推荐使用QSpacerItem。</li>
</ul>
<h4 id="示例：使用QSpacerItem"><a href="#示例：使用QSpacerItem" class="headerlink" title="示例：使用QSpacerItem"></a>示例：使用QSpacerItem</h4><p>以下示例展示了如何使用<code>QSpacerItem</code>在布局中添加弹性空间，以优化控件的排列。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QHBoxLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QSpacerItem&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建主窗口</span></span><br><span class="line">    QWidget window;</span><br><span class="line">    window.<span class="built_in">setWindowTitle</span>(<span class="string">&quot;间隔控件示例&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建按钮</span></span><br><span class="line">    QPushButton *buttonLeft = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;左侧按钮&quot;</span>);</span><br><span class="line">    QPushButton *buttonRight = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;右侧按钮&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建水平布局管理器</span></span><br><span class="line">    QHBoxLayout *hLayout = <span class="keyword">new</span> QHBoxLayout;</span><br><span class="line">    hLayout-&gt;<span class="built_in">addWidget</span>(buttonLeft);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加间隔控件</span></span><br><span class="line">    QSpacerItem *spacer = <span class="keyword">new</span> <span class="built_in">QSpacerItem</span>(<span class="number">40</span>, <span class="number">20</span>, QSizePolicy::Expanding, QSizePolicy::Minimum);</span><br><span class="line">    hLayout-&gt;<span class="built_in">addItem</span>(spacer);</span><br><span class="line"></span><br><span class="line">    hLayout-&gt;<span class="built_in">addWidget</span>(buttonRight);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置主窗口的布局</span></span><br><span class="line">    window.<span class="built_in">setLayout</span>(hLayout);</span><br><span class="line">    window.<span class="built_in">resize</span>(<span class="number">400</span>, <span class="number">100</span>);</span><br><span class="line">    window.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<p><img src="https://i.imgur.com/ABC5678.png" alt="间隔控件示例"></p>
<p><strong>解释：</strong></p>
<ul>
<li><strong>QSpacerItem</strong>被添加到水平布局中，起到弹性空间的作用，将两个按钮分别推向布局的左右两侧。</li>
<li>使用间隔控件可以确保界面在不同窗口尺寸下保持美观和响应式。</li>
</ul>
<h3 id="1-3-布局管理器的最佳实践"><a href="#1-3-布局管理器的最佳实践" class="headerlink" title="1.3 布局管理器的最佳实践"></a>1.3 布局管理器的最佳实践</h3><ol>
<li><strong>避免在控件之间使用固定大小</strong>：尽量使用布局管理器自动调整控件大小，以适应不同的窗口尺寸。</li>
<li><strong>合理使用嵌套布局</strong>：通过嵌套使用QHBoxLayout和QVBoxLayout，可以设计复杂且灵活的界面。</li>
<li><strong>使用间隔控件优化布局</strong>：适当添加间隔控件，确保控件之间的间距合理，提升界面的美观性。</li>
</ol>
<hr>
<h2 id="2-Buttons-amp-Containers"><a href="#2-Buttons-amp-Containers" class="headerlink" title="2. Buttons &amp; Containers"></a>2. Buttons &amp; Containers</h2><h3 id="2-1-按钮控件（Buttons）"><a href="#2-1-按钮控件（Buttons）" class="headerlink" title="2.1 按钮控件（Buttons）"></a>2.1 按钮控件（Buttons）</h3><p>按钮是用户界面中最常用的控件之一，用于触发各种操作和事件。Qt提供了多种按钮控件，满足不同的需求。</p>
<h4 id="常见按钮控件"><a href="#常见按钮控件" class="headerlink" title="常见按钮控件"></a>常见按钮控件</h4><ul>
<li><strong>QPushButton</strong>：标准按钮，用于执行命令。</li>
<li><strong>QToolButton</strong>：工具按钮，通常用于工具栏中，支持图标显示。</li>
<li><strong>QRadioButton</strong>：单选按钮，用于在多个选项中选择一个。</li>
<li><strong>QCheckBox</strong>：复选框，用于选择或取消选择多个选项。</li>
<li><strong>QCommandLinkButton</strong>：命令链接按钮，带有描述文本，类似于Windows Vista中的链接按钮。</li>
</ul>
<h4 id="示例：使用QPushButton"><a href="#示例：使用QPushButton" class="headerlink" title="示例：使用QPushButton"></a>示例：使用QPushButton</h4><p>以下示例展示了如何创建和使用<code>QPushButton</code>，并响应按钮的点击事件。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QVBoxLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建主窗口</span></span><br><span class="line">    QWidget window;</span><br><span class="line">    window.<span class="built_in">setWindowTitle</span>(<span class="string">&quot;QPushButton 示例&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建按钮</span></span><br><span class="line">    QPushButton *button = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;点击我&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建布局管理器</span></span><br><span class="line">    QVBoxLayout *vLayout = <span class="keyword">new</span> QVBoxLayout;</span><br><span class="line">    vLayout-&gt;<span class="built_in">addWidget</span>(button);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置主窗口的布局</span></span><br><span class="line">    window.<span class="built_in">setLayout</span>(vLayout);</span><br><span class="line">    window.<span class="built_in">resize</span>(<span class="number">200</span>, <span class="number">100</span>);</span><br><span class="line">    window.<span class="built_in">show</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 连接按钮点击信号到槽函数</span></span><br><span class="line">    QObject::<span class="built_in">connect</span>(button, &amp;QPushButton::clicked, [&amp;]()&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;按钮被点击了！&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<p><img src="https://i.imgur.com/DEF91011.png" alt="QPushButton 示例"></p>
<p><strong>解释：</strong></p>
<ul>
<li><strong>QPushButton</strong>用于创建一个可点击的按钮。</li>
<li>通过<code>QObject::connect</code>将按钮的<code>clicked</code>信号连接到一个lambda槽函数，实现点击按钮时的响应操作。</li>
<li>点击按钮时，控制台将输出“按钮被点击了！”的调试信息。</li>
</ul>
<h3 id="2-2-容器控件（Containers）"><a href="#2-2-容器控件（Containers）" class="headerlink" title="2.2 容器控件（Containers）"></a>2.2 容器控件（Containers）</h3><p>容器控件用于组织和管理其他控件，提供分组和结构化界面的能力。常用的容器控件包括：</p>
<ul>
<li><strong>QGroupBox</strong>：分组框，用于在视觉上分组相关的控件。</li>
<li><strong>QFrame</strong>：框架控件，提供多种边框样式。</li>
<li><strong>QScrollArea</strong>：滚动区域控件，允许在有限的空间内显示超出视图范围的内容。</li>
</ul>
<h4 id="示例：使用QGroupBox组织控件"><a href="#示例：使用QGroupBox组织控件" class="headerlink" title="示例：使用QGroupBox组织控件"></a>示例：使用QGroupBox组织控件</h4><p>以下示例展示了如何使用<code>QGroupBox</code>来分组相关的按钮控件。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QGroupBox&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QVBoxLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QHBoxLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建主窗口</span></span><br><span class="line">    QWidget window;</span><br><span class="line">    window.<span class="built_in">setWindowTitle</span>(<span class="string">&quot;按钮与容器控件示例&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建QGroupBox</span></span><br><span class="line">    QGroupBox *groupBox = <span class="keyword">new</span> <span class="built_in">QGroupBox</span>(<span class="string">&quot;操作选项&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建按钮</span></span><br><span class="line">    QPushButton *btnStart = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;开始&quot;</span>);</span><br><span class="line">    QPushButton *btnStop = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;停止&quot;</span>);</span><br><span class="line">    QPushButton *btnPause = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;暂停&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接按钮信号到槽</span></span><br><span class="line">    QObject::<span class="built_in">connect</span>(btnStart, &amp;QPushButton::clicked, []()&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;开始按钮被点击&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    QObject::<span class="built_in">connect</span>(btnStop, &amp;QPushButton::clicked, []()&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;停止按钮被点击&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    QObject::<span class="built_in">connect</span>(btnPause, &amp;QPushButton::clicked, []()&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;暂停按钮被点击&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建布局管理器</span></span><br><span class="line">    QHBoxLayout *hLayout = <span class="keyword">new</span> QHBoxLayout;</span><br><span class="line">    hLayout-&gt;<span class="built_in">addWidget</span>(btnStart);</span><br><span class="line">    hLayout-&gt;<span class="built_in">addWidget</span>(btnStop);</span><br><span class="line">    hLayout-&gt;<span class="built_in">addWidget</span>(btnPause);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置QGroupBox的布局</span></span><br><span class="line">    groupBox-&gt;<span class="built_in">setLayout</span>(hLayout);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建主布局</span></span><br><span class="line">    QVBoxLayout *vLayout = <span class="keyword">new</span> QVBoxLayout;</span><br><span class="line">    vLayout-&gt;<span class="built_in">addWidget</span>(groupBox);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置主窗口的布局</span></span><br><span class="line">    window.<span class="built_in">setLayout</span>(vLayout);</span><br><span class="line">    window.<span class="built_in">resize</span>(<span class="number">300</span>, <span class="number">150</span>);</span><br><span class="line">    window.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<p><img src="https://i.imgur.com/DEF91011.png" alt="按钮与容器控件示例"></p>
<p><strong>解释：</strong></p>
<ul>
<li><strong>QGroupBox</strong>用于视觉上分组“开始”、“停止”和“暂停”按钮。</li>
<li>按钮的点击信号通过<code>QObject::connect</code>连接到lambda槽函数，打印相应的调试信息。</li>
<li><strong>QHBoxLayout</strong>在<code>QGroupBox</code>内部水平排列按钮，确保界面整洁有序。</li>
</ul>
<h3 id="2-3-QPushButton的高级功能"><a href="#2-3-QPushButton的高级功能" class="headerlink" title="2.3 QPushButton的高级功能"></a>2.3 QPushButton的高级功能</h3><p><strong>设置图标和快捷键：</strong></p>
<p>可以为<code>QPushButton</code>设置图标和快捷键，提升用户体验。</p>
<p><strong>示例代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QHBoxLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QIcon&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建主窗口</span></span><br><span class="line">    QWidget window;</span><br><span class="line">    window.<span class="built_in">setWindowTitle</span>(<span class="string">&quot;QPushButton 高级功能示例&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建按钮</span></span><br><span class="line">    QPushButton *btnSave = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;保存&quot;</span>);</span><br><span class="line">    btnSave-&gt;<span class="built_in">setIcon</span>(<span class="built_in">QIcon</span>(<span class="string">&quot;:/icons/save.png&quot;</span>)); <span class="comment">// 设置图标</span></span><br><span class="line">    btnSave-&gt;<span class="built_in">setShortcut</span>(<span class="built_in">QKeySequence</span>(Qt::CTRL + Qt::Key_S)); <span class="comment">// 设置快捷键</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建布局管理器</span></span><br><span class="line">    QHBoxLayout *hLayout = <span class="keyword">new</span> QHBoxLayout;</span><br><span class="line">    hLayout-&gt;<span class="built_in">addWidget</span>(btnSave);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置主窗口的布局</span></span><br><span class="line">    window.<span class="built_in">setLayout</span>(hLayout);</span><br><span class="line">    window.<span class="built_in">resize</span>(<span class="number">200</span>, <span class="number">100</span>);</span><br><span class="line">    window.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接按钮点击信号到槽函数</span></span><br><span class="line">    QObject::<span class="built_in">connect</span>(btnSave, &amp;QPushButton::clicked, [&amp;]()&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;保存按钮被点击&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>使用<code>setIcon</code>方法为按钮设置图标，提升界面的视觉效果。</li>
<li>使用<code>setShortcut</code>方法为按钮设置快捷键，允许用户通过键盘快捷键触发按钮操作。</li>
<li>当用户点击按钮或按下快捷键时，控制台将输出“保存按钮被点击”的调试信息。</li>
</ul>
<h3 id="2-4-QGroupBox的高级应用"><a href="#2-4-QGroupBox的高级应用" class="headerlink" title="2.4 QGroupBox的高级应用"></a>2.4 QGroupBox的高级应用</h3><p><strong>示例：嵌套使用QGroupBox</strong></p>
<p>通过嵌套使用多个<code>QGroupBox</code>，可以创建更复杂的界面布局。</p>
<p><strong>示例代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QGroupBox&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QVBoxLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QHBoxLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建主窗口</span></span><br><span class="line">    QWidget window;</span><br><span class="line">    window.<span class="built_in">setWindowTitle</span>(<span class="string">&quot;嵌套QGroupBox示例&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建第一个QGroupBox</span></span><br><span class="line">    QGroupBox *groupBox1 = <span class="keyword">new</span> <span class="built_in">QGroupBox</span>(<span class="string">&quot;文件操作&quot;</span>);</span><br><span class="line">    QPushButton *btnOpen = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;打开&quot;</span>);</span><br><span class="line">    QPushButton *btnClose = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;关闭&quot;</span>);</span><br><span class="line"></span><br><span class="line">    QHBoxLayout *hLayout1 = <span class="keyword">new</span> QHBoxLayout;</span><br><span class="line">    hLayout1-&gt;<span class="built_in">addWidget</span>(btnOpen);</span><br><span class="line">    hLayout1-&gt;<span class="built_in">addWidget</span>(btnClose);</span><br><span class="line">    groupBox1-&gt;<span class="built_in">setLayout</span>(hLayout1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建第二个QGroupBox</span></span><br><span class="line">    QGroupBox *groupBox2 = <span class="keyword">new</span> <span class="built_in">QGroupBox</span>(<span class="string">&quot;编辑操作&quot;</span>);</span><br><span class="line">    QPushButton *btnCut = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;剪切&quot;</span>);</span><br><span class="line">    QPushButton *btnCopy = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;复制&quot;</span>);</span><br><span class="line">    QPushButton *btnPaste = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;粘贴&quot;</span>);</span><br><span class="line"></span><br><span class="line">    QHBoxLayout *hLayout2 = <span class="keyword">new</span> QHBoxLayout;</span><br><span class="line">    hLayout2-&gt;<span class="built_in">addWidget</span>(btnCut);</span><br><span class="line">    hLayout2-&gt;<span class="built_in">addWidget</span>(btnCopy);</span><br><span class="line">    hLayout2-&gt;<span class="built_in">addWidget</span>(btnPaste);</span><br><span class="line">    groupBox2-&gt;<span class="built_in">setLayout</span>(hLayout2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建主布局</span></span><br><span class="line">    QVBoxLayout *vLayout = <span class="keyword">new</span> QVBoxLayout;</span><br><span class="line">    vLayout-&gt;<span class="built_in">addWidget</span>(groupBox1);</span><br><span class="line">    vLayout-&gt;<span class="built_in">addWidget</span>(groupBox2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置主窗口的布局</span></span><br><span class="line">    window.<span class="built_in">setLayout</span>(vLayout);</span><br><span class="line">    window.<span class="built_in">resize</span>(<span class="number">400</span>, <span class="number">200</span>);</span><br><span class="line">    window.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<p><img src="https://i.imgur.com/DEF91011.png" alt="嵌套QGroupBox示例"></p>
<p><strong>解释：</strong></p>
<ul>
<li>创建了两个<code>QGroupBox</code>，分别用于“文件操作”和“编辑操作”。</li>
<li>每个<code>QGroupBox</code>内部使用<code>QHBoxLayout</code>水平排列相关按钮，增强界面的组织性和可读性。</li>
<li>主布局使用<code>QVBoxLayout</code>垂直排列两个分组框，实现复杂的界面布局。</li>
</ul>
<h3 id="2-5-小结"><a href="#2-5-小结" class="headerlink" title="2.5 小结"></a>2.5 小结</h3><p>布局管理器和容器控件是构建美观且响应式用户界面的重要工具。通过合理使用布局管理器和容器控件，可以确保应用程序在不同屏幕尺寸和分辨率下都能保持良好的用户体验。同时，结合按钮控件的使用，能够创建功能齐全且易于操作的用户界面。</p>
<hr>
<h2 id="3-Item-Views"><a href="#3-Item-Views" class="headerlink" title="3. Item Views"></a>3. Item Views</h2><h3 id="3-1-基于模型的视图控件"><a href="#3-1-基于模型的视图控件" class="headerlink" title="3.1 基于模型的视图控件"></a>3.1 基于模型的视图控件</h3><p>Qt的模型视图架构（Model-View Architecture）提供了一种高效的数据管理和显示方式。基于模型的视图控件将数据存储在模型中，视图负责展示数据，控制器处理用户交互。这种架构促进了数据与视图的分离，提高了代码的可维护性和复用性。</p>
<p>常见的基于模型的视图控件包括：</p>
<ul>
<li><strong>QListView</strong>：列表视图，用于显示线性列表数据。</li>
<li><strong>QTableView</strong>：表格视图，用于显示二维表格数据。</li>
<li><strong>QTreeView</strong>：树形视图，用于显示层次结构数据。</li>
</ul>
<h3 id="3-2-示例：使用QListView展示数据"><a href="#3-2-示例：使用QListView展示数据" class="headerlink" title="3.2 示例：使用QListView展示数据"></a>3.2 示例：使用QListView展示数据</h3><p>以下示例展示了如何使用<code>QListView</code>结合<code>QStringListModel</code>来展示简单的列表数据。</p>
<p><strong>示例代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QListView&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QStringListModel&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建QListView</span></span><br><span class="line">    QListView listView;</span><br><span class="line">    listView.<span class="built_in">setWindowTitle</span>(<span class="string">&quot;QListView 示例&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建QStringListModel</span></span><br><span class="line">    QStringList data;</span><br><span class="line">    data &lt;&lt; <span class="string">&quot;Apple&quot;</span> &lt;&lt; <span class="string">&quot;Banana&quot;</span> &lt;&lt; <span class="string">&quot;Cherry&quot;</span> &lt;&lt; <span class="string">&quot;Date&quot;</span> &lt;&lt; <span class="string">&quot;Elderberry&quot;</span>;</span><br><span class="line">    QStringListModel *model = <span class="keyword">new</span> <span class="built_in">QStringListModel</span>(data, &amp;listView);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置模型到视图</span></span><br><span class="line">    listView.<span class="built_in">setModel</span>(model);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示视图</span></span><br><span class="line">    listView.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<p><img src="https://i.imgur.com/JKL1415.png" alt="QListView 示例"></p>
<p><strong>解释：</strong></p>
<ul>
<li><strong>QListView</strong>作为视图控件，负责展示数据。</li>
<li><strong>QStringListModel</strong>作为模型，存储并管理字符串列表数据。</li>
<li>使用<code>setModel</code>方法将模型关联到视图，视图自动更新显示数据。</li>
</ul>
<h3 id="3-3-示例：使用QTableView展示数据"><a href="#3-3-示例：使用QTableView展示数据" class="headerlink" title="3.3 示例：使用QTableView展示数据"></a>3.3 示例：使用QTableView展示数据</h3><p>以下示例展示了如何使用<code>QTableView</code>结合<code>QStandardItemModel</code>来展示二维表格数据。</p>
<p><strong>示例代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTableView&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QStandardItemModel&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QStandardItem&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建QTableView</span></span><br><span class="line">    QTableView tableView;</span><br><span class="line">    tableView.<span class="built_in">setWindowTitle</span>(<span class="string">&quot;QTableView 示例&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建QStandardItemModel</span></span><br><span class="line">    <span class="function">QStandardItemModel <span class="title">model</span><span class="params">(<span class="number">3</span>, <span class="number">2</span>)</span></span>; <span class="comment">// 3行2列</span></span><br><span class="line">    model.<span class="built_in">setHeaderData</span>(<span class="number">0</span>, Qt::Horizontal, <span class="string">&quot;姓名&quot;</span>);</span><br><span class="line">    model.<span class="built_in">setHeaderData</span>(<span class="number">1</span>, Qt::Horizontal, <span class="string">&quot;年龄&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填充数据</span></span><br><span class="line">    QList&lt;QStandardItem *&gt; row1;</span><br><span class="line">    row1 &lt;&lt; <span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;Alice&quot;</span>) &lt;&lt; <span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;30&quot;</span>);</span><br><span class="line">    QList&lt;QStandardItem *&gt; row2;</span><br><span class="line">    row2 &lt;&lt; <span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;Bob&quot;</span>) &lt;&lt; <span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;25&quot;</span>);</span><br><span class="line">    QList&lt;QStandardItem *&gt; row3;</span><br><span class="line">    row3 &lt;&lt; <span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;Charlie&quot;</span>) &lt;&lt; <span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;35&quot;</span>);</span><br><span class="line"></span><br><span class="line">    model.<span class="built_in">appendRow</span>(row1);</span><br><span class="line">    model.<span class="built_in">appendRow</span>(row2);</span><br><span class="line">    model.<span class="built_in">appendRow</span>(row3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置模型到视图</span></span><br><span class="line">    tableView.<span class="built_in">setModel</span>(&amp;model);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示视图</span></span><br><span class="line">    tableView.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<p><img src="https://i.imgur.com/MNO1617.png" alt="QTableView 示例"></p>
<p><strong>解释：</strong></p>
<ul>
<li><strong>QTableView</strong>作为视图控件，负责展示二维表格数据。</li>
<li><strong>QStandardItemModel</strong>作为模型，存储并管理表格数据，包括行和列。</li>
<li>使用<code>setHeaderData</code>设置表头信息，使用<code>appendRow</code>添加数据行。</li>
<li>视图自动显示模型中的数据。</li>
</ul>
<h3 id="3-4-示例：使用QTreeView展示数据"><a href="#3-4-示例：使用QTreeView展示数据" class="headerlink" title="3.4 示例：使用QTreeView展示数据"></a>3.4 示例：使用QTreeView展示数据</h3><p>以下示例展示了如何使用<code>QTreeView</code>结合<code>QStandardItemModel</code>来展示层次结构数据。</p>
<p><strong>示例代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTreeView&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QStandardItemModel&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QStandardItem&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建QTreeView</span></span><br><span class="line">    QTreeView treeView;</span><br><span class="line">    treeView.<span class="built_in">setWindowTitle</span>(<span class="string">&quot;QTreeView 示例&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建QStandardItemModel</span></span><br><span class="line">    QStandardItemModel model;</span><br><span class="line">    model.<span class="built_in">setHorizontalHeaderLabels</span>(&#123;<span class="string">&quot;名称&quot;</span>, <span class="string">&quot;描述&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建根节点</span></span><br><span class="line">    QStandardItem *rootItem = model.<span class="built_in">invisibleRootItem</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一级节点</span></span><br><span class="line">    QStandardItem *parent1 = <span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;文件&quot;</span>);</span><br><span class="line">    QStandardItem *parent1Desc = <span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;文件操作&quot;</span>);</span><br><span class="line">    rootItem-&gt;<span class="built_in">appendRow</span>(&#123;parent1, parent1Desc&#125;);</span><br><span class="line"></span><br><span class="line">    QStandardItem *parent2 = <span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;编辑&quot;</span>);</span><br><span class="line">    QStandardItem *parent2Desc = <span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;编辑操作&quot;</span>);</span><br><span class="line">    rootItem-&gt;<span class="built_in">appendRow</span>(&#123;parent2, parent2Desc&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建二级节点</span></span><br><span class="line">    QStandardItem *child1 = <span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;新建&quot;</span>);</span><br><span class="line">    QStandardItem *child1Desc = <span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;创建新文件&quot;</span>);</span><br><span class="line">    parent1-&gt;<span class="built_in">appendRow</span>(&#123;child1, child1Desc&#125;);</span><br><span class="line"></span><br><span class="line">    QStandardItem *child2 = <span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;打开&quot;</span>);</span><br><span class="line">    QStandardItem *child2Desc = <span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;打开现有文件&quot;</span>);</span><br><span class="line">    parent1-&gt;<span class="built_in">appendRow</span>(&#123;child2, child2Desc&#125;);</span><br><span class="line"></span><br><span class="line">    QStandardItem *child3 = <span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;复制&quot;</span>);</span><br><span class="line">    QStandardItem *child3Desc = <span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;复制选中内容&quot;</span>);</span><br><span class="line">    parent2-&gt;<span class="built_in">appendRow</span>(&#123;child3, child3Desc&#125;);</span><br><span class="line"></span><br><span class="line">    QStandardItem *child4 = <span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;粘贴&quot;</span>);</span><br><span class="line">    QStandardItem *child4Desc = <span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;粘贴内容&quot;</span>);</span><br><span class="line">    parent2-&gt;<span class="built_in">appendRow</span>(&#123;child4, child4Desc&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置模型到视图</span></span><br><span class="line">    treeView.<span class="built_in">setModel</span>(&amp;model);</span><br><span class="line">    treeView.<span class="built_in">expandAll</span>(); <span class="comment">// 展开所有节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示视图</span></span><br><span class="line">    treeView.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<p><img src="https://i.imgur.com/VWX2223.png" alt="QTreeView 示例"></p>
<p><strong>解释：</strong></p>
<ul>
<li><strong>QTreeView</strong>作为视图控件，负责展示层次结构数据。</li>
<li><strong>QStandardItemModel</strong>作为模型，存储并管理树形数据结构。</li>
<li>通过<code>appendRow</code>方法添加父节点和子节点，构建树形结构。</li>
<li>使用<code>expandAll</code>方法展开所有节点，便于查看数据。</li>
</ul>
<h3 id="3-5-模型视图架构的优势"><a href="#3-5-模型视图架构的优势" class="headerlink" title="3.5 模型视图架构的优势"></a>3.5 模型视图架构的优势</h3><ul>
<li><strong>数据与视图分离</strong>：模型负责数据管理，视图负责数据展示，提高了代码的模块化和可维护性。</li>
<li><strong>灵活的数据展示</strong>：同一个模型可以被多个视图使用，如一个模型可以同时被<code>QListView</code>和<code>QTableView</code>展示。</li>
<li><strong>高效的数据操作</strong>：模型视图架构优化了大规模数据的处理和展示，提升了应用程序的性能。</li>
</ul>
<h3 id="3-6-小结"><a href="#3-6-小结" class="headerlink" title="3.6 小结"></a>3.6 小结</h3><p>基于模型的视图控件是Qt中处理和展示复杂数据的重要工具。通过理解和应用模型视图架构，开发者可以构建高效、灵活且可维护的用户界面，满足不同的数据展示需求。</p>
<hr>
<h2 id="4-Item-Widgets"><a href="#4-Item-Widgets" class="headerlink" title="4. Item Widgets"></a>4. Item Widgets</h2><h3 id="4-1-基于项的视图控件"><a href="#4-1-基于项的视图控件" class="headerlink" title="4.1 基于项的视图控件"></a>4.1 基于项的视图控件</h3><p>除基于模型的视图控件外，Qt还提供了基于项的视图控件，这些控件更加直观和易于使用，适用于简单的数据展示场景。常见的基于项的视图控件包括：</p>
<ul>
<li><strong>QListWidget</strong>：列表项视图，继承自QListView，提供简化的API。</li>
<li><strong>QTreeWidget</strong>：树形项视图，继承自QTreeView，提供简化的API。</li>
<li><strong>QTableWidget</strong>：表格项视图，继承自QTableView，提供简化的API。</li>
</ul>
<h3 id="4-2-示例：使用QListWidget展示数据"><a href="#4-2-示例：使用QListWidget展示数据" class="headerlink" title="4.2 示例：使用QListWidget展示数据"></a>4.2 示例：使用QListWidget展示数据</h3><p>以下示例展示了如何使用<code>QListWidget</code>来展示和管理简单的列表数据。</p>
<p><strong>示例代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QListWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建QListWidget</span></span><br><span class="line">    QListWidget listWidget;</span><br><span class="line">    listWidget.<span class="built_in">setWindowTitle</span>(<span class="string">&quot;QListWidget 示例&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加列表项</span></span><br><span class="line">    listWidget.<span class="built_in">addItem</span>(<span class="string">&quot;Item 1&quot;</span>);</span><br><span class="line">    listWidget.<span class="built_in">addItem</span>(<span class="string">&quot;Item 2&quot;</span>);</span><br><span class="line">    listWidget.<span class="built_in">addItem</span>(<span class="string">&quot;Item 3&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加带有图标的列表项</span></span><br><span class="line">    QListWidgetItem *item4 = <span class="keyword">new</span> <span class="built_in">QListWidgetItem</span>(<span class="built_in">QIcon</span>(<span class="string">&quot;:/icons/icon.png&quot;</span>), <span class="string">&quot;Item 4&quot;</span>);</span><br><span class="line">    listWidget.<span class="built_in">addItem</span>(item4);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接列表项点击信号到槽函数</span></span><br><span class="line">    QObject::<span class="built_in">connect</span>(&amp;listWidget, &amp;QListWidget::itemClicked, [&amp;](QListWidgetItem *item)&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;点击了：&quot;</span> &lt;&lt; item-&gt;<span class="built_in">text</span>();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示列表</span></span><br><span class="line">    listWidget.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<p><img src="https://i.imgur.com/STU2021.png" alt="QListWidget 示例"></p>
<p><strong>解释：</strong></p>
<ul>
<li><strong>QListWidget</strong>提供了一个简单的接口来管理列表项，无需手动创建模型。</li>
<li>使用<code>addItem</code>方法添加文本项或带有图标的项。</li>
<li>通过<code>itemClicked</code>信号连接到槽函数，响应用户的点击操作。</li>
</ul>
<h3 id="4-3-示例：使用QTreeWidget展示数据"><a href="#4-3-示例：使用QTreeWidget展示数据" class="headerlink" title="4.3 示例：使用QTreeWidget展示数据"></a>4.3 示例：使用QTreeWidget展示数据</h3><p>以下示例展示了如何使用<code>QTreeWidget</code>来展示和管理树形数据。</p>
<p><strong>示例代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTreeWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTreeWidgetItem&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建QTreeWidget</span></span><br><span class="line">    QTreeWidget treeWidget;</span><br><span class="line">    treeWidget.<span class="built_in">setWindowTitle</span>(<span class="string">&quot;QTreeWidget 示例&quot;</span>);</span><br><span class="line">    treeWidget.<span class="built_in">setColumnCount</span>(<span class="number">2</span>);</span><br><span class="line">    treeWidget.<span class="built_in">setHeaderLabels</span>(&#123;<span class="string">&quot;名称&quot;</span>, <span class="string">&quot;描述&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建根节点</span></span><br><span class="line">    QTreeWidgetItem *root = <span class="keyword">new</span> <span class="built_in">QTreeWidgetItem</span>(&amp;treeWidget);</span><br><span class="line">    root-&gt;<span class="built_in">setText</span>(<span class="number">0</span>, <span class="string">&quot;文件&quot;</span>);</span><br><span class="line">    root-&gt;<span class="built_in">setText</span>(<span class="number">1</span>, <span class="string">&quot;文件操作&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建子节点</span></span><br><span class="line">    QTreeWidgetItem *child1 = <span class="keyword">new</span> <span class="built_in">QTreeWidgetItem</span>(root);</span><br><span class="line">    child1-&gt;<span class="built_in">setText</span>(<span class="number">0</span>, <span class="string">&quot;新建&quot;</span>);</span><br><span class="line">    child1-&gt;<span class="built_in">setText</span>(<span class="number">1</span>, <span class="string">&quot;创建新文件&quot;</span>);</span><br><span class="line"></span><br><span class="line">    QTreeWidgetItem *child2 = <span class="keyword">new</span> <span class="built_in">QTreeWidgetItem</span>(root);</span><br><span class="line">    child2-&gt;<span class="built_in">setText</span>(<span class="number">0</span>, <span class="string">&quot;打开&quot;</span>);</span><br><span class="line">    child2-&gt;<span class="built_in">setText</span>(<span class="number">1</span>, <span class="string">&quot;打开现有文件&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 展开所有节点</span></span><br><span class="line">    treeWidget.<span class="built_in">expandAll</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接节点点击信号到槽函数</span></span><br><span class="line">    QObject::<span class="built_in">connect</span>(&amp;treeWidget, &amp;QTreeWidget::itemClicked, [&amp;](QTreeWidgetItem *item, <span class="type">int</span> column)&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;点击了：&quot;</span> &lt;&lt; item-&gt;<span class="built_in">text</span>(<span class="number">0</span>) &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; item-&gt;<span class="built_in">text</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示树形视图</span></span><br><span class="line">    treeWidget.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<p><img src="https://i.imgur.com/VWX2223.png" alt="QTreeWidget 示例"></p>
<p><strong>解释：</strong></p>
<ul>
<li><strong>QTreeWidget</strong>提供了一个简化的接口来管理树形数据，无需手动创建模型。</li>
<li>使用<code>QTreeWidgetItem</code>创建根节点和子节点，并设置其文本内容。</li>
<li>通过<code>itemClicked</code>信号连接到槽函数，响应用户的点击操作。</li>
</ul>
<h3 id="4-4-示例：使用QTableWidget展示数据"><a href="#4-4-示例：使用QTableWidget展示数据" class="headerlink" title="4.4 示例：使用QTableWidget展示数据"></a>4.4 示例：使用QTableWidget展示数据</h3><p>以下示例展示了如何使用<code>QTableWidget</code>来展示和管理表格数据。</p>
<p><strong>示例代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTableWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTableWidgetItem&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建QTableWidget</span></span><br><span class="line">    QTableWidget tableWidget;</span><br><span class="line">    tableWidget.<span class="built_in">setWindowTitle</span>(<span class="string">&quot;QTableWidget 示例&quot;</span>);</span><br><span class="line">    tableWidget.<span class="built_in">setRowCount</span>(<span class="number">3</span>);</span><br><span class="line">    tableWidget.<span class="built_in">setColumnCount</span>(<span class="number">2</span>);</span><br><span class="line">    tableWidget.<span class="built_in">setHorizontalHeaderLabels</span>(&#123;<span class="string">&quot;姓名&quot;</span>, <span class="string">&quot;年龄&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填充数据</span></span><br><span class="line">    tableWidget.<span class="built_in">setItem</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">new</span> <span class="built_in">QTableWidgetItem</span>(<span class="string">&quot;Alice&quot;</span>));</span><br><span class="line">    tableWidget.<span class="built_in">setItem</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="keyword">new</span> <span class="built_in">QTableWidgetItem</span>(<span class="string">&quot;30&quot;</span>));</span><br><span class="line"></span><br><span class="line">    tableWidget.<span class="built_in">setItem</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="keyword">new</span> <span class="built_in">QTableWidgetItem</span>(<span class="string">&quot;Bob&quot;</span>));</span><br><span class="line">    tableWidget.<span class="built_in">setItem</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="keyword">new</span> <span class="built_in">QTableWidgetItem</span>(<span class="string">&quot;25&quot;</span>));</span><br><span class="line"></span><br><span class="line">    tableWidget.<span class="built_in">setItem</span>(<span class="number">2</span>, <span class="number">0</span>, <span class="keyword">new</span> <span class="built_in">QTableWidgetItem</span>(<span class="string">&quot;Charlie&quot;</span>));</span><br><span class="line">    tableWidget.<span class="built_in">setItem</span>(<span class="number">2</span>, <span class="number">1</span>, <span class="keyword">new</span> <span class="built_in">QTableWidgetItem</span>(<span class="string">&quot;35&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接单元格点击信号到槽函数</span></span><br><span class="line">    QObject::<span class="built_in">connect</span>(&amp;tableWidget, &amp;QTableWidget::cellClicked, [&amp;](<span class="type">int</span> row, <span class="type">int</span> column)&#123;</span><br><span class="line">        QString name = tableWidget.<span class="built_in">item</span>(row, <span class="number">0</span>)-&gt;<span class="built_in">text</span>();</span><br><span class="line">        QString age = tableWidget.<span class="built_in">item</span>(row, <span class="number">1</span>)-&gt;<span class="built_in">text</span>();</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;点击了：&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; age;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示表格</span></span><br><span class="line">    tableWidget.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<p><img src="https://i.imgur.com/YZA2425.png" alt="QTableWidget 示例"></p>
<p><strong>解释：</strong></p>
<ul>
<li><strong>QTableWidget</strong>提供了一个简化的接口来管理表格数据，无需手动创建模型。</li>
<li>使用<code>setItem</code>方法填充表格单元格数据。</li>
<li>通过<code>cellClicked</code>信号连接到槽函数，响应用户的点击操作。</li>
</ul>
<h3 id="4-5-QTableWidget的高级功能"><a href="#4-5-QTableWidget的高级功能" class="headerlink" title="4.5 QTableWidget的高级功能"></a>4.5 QTableWidget的高级功能</h3><p><strong>设置单元格编辑属性：</strong></p>
<p>可以控制单元格的编辑行为，如只读、可编辑等。</p>
<p><strong>示例代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTableWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTableWidgetItem&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建QTableWidget</span></span><br><span class="line">    QTableWidget tableWidget;</span><br><span class="line">    tableWidget.<span class="built_in">setWindowTitle</span>(<span class="string">&quot;QTableWidget 高级功能示例&quot;</span>);</span><br><span class="line">    tableWidget.<span class="built_in">setRowCount</span>(<span class="number">2</span>);</span><br><span class="line">    tableWidget.<span class="built_in">setColumnCount</span>(<span class="number">2</span>);</span><br><span class="line">    tableWidget.<span class="built_in">setHorizontalHeaderLabels</span>(&#123;<span class="string">&quot;名称&quot;</span>, <span class="string">&quot;描述&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建只读单元格</span></span><br><span class="line">    QTableWidgetItem *item1 = <span class="keyword">new</span> <span class="built_in">QTableWidgetItem</span>(<span class="string">&quot;Item 1&quot;</span>);</span><br><span class="line">    item1-&gt;<span class="built_in">setFlags</span>(item1-&gt;<span class="built_in">flags</span>() &amp; ~Qt::ItemIsEditable); <span class="comment">// 设置为只读</span></span><br><span class="line">    tableWidget.<span class="built_in">setItem</span>(<span class="number">0</span>, <span class="number">0</span>, item1);</span><br><span class="line">    tableWidget.<span class="built_in">setItem</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="keyword">new</span> <span class="built_in">QTableWidgetItem</span>(<span class="string">&quot;Description 1&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建可编辑单元格</span></span><br><span class="line">    QTableWidgetItem *item2 = <span class="keyword">new</span> <span class="built_in">QTableWidgetItem</span>(<span class="string">&quot;Item 2&quot;</span>);</span><br><span class="line">    item2-&gt;<span class="built_in">setFlags</span>(item2-&gt;<span class="built_in">flags</span>() | Qt::ItemIsEditable); <span class="comment">// 设置为可编辑</span></span><br><span class="line">    tableWidget.<span class="built_in">setItem</span>(<span class="number">1</span>, <span class="number">0</span>, item2);</span><br><span class="line">    tableWidget.<span class="built_in">setItem</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="keyword">new</span> <span class="built_in">QTableWidgetItem</span>(<span class="string">&quot;Description 2&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接单元格编辑信号到槽函数</span></span><br><span class="line">    QObject::<span class="built_in">connect</span>(&amp;tableWidget, &amp;QTableWidget::itemChanged, [&amp;](QTableWidgetItem *item)&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;单元格内容更改：&quot;</span> &lt;&lt; item-&gt;<span class="built_in">text</span>();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示表格</span></span><br><span class="line">    tableWidget.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>使用<code>setFlags</code>方法修改单元格的标志，取消<code>Qt::ItemIsEditable</code>标志，将单元格设置为只读。</li>
<li>通过<code>itemChanged</code>信号连接到槽函数，实时响应用户对单元格内容的修改。</li>
</ul>
<h3 id="4-6-小结"><a href="#4-6-小结" class="headerlink" title="4.6 小结"></a>4.6 小结</h3><p>基于项的视图控件如<code>QListWidget</code>、<code>QTreeWidget</code>和<code>QTableWidget</code>提供了简化的数据展示和管理接口，适用于简单或中等复杂度的数据展示场景。它们易于使用，适合快速开发，但在处理大规模数据或需要高度定制化的场景时，基于模型的视图控件更为合适。</p>
<hr>
<h2 id="5-Input-Widgets"><a href="#5-Input-Widgets" class="headerlink" title="5. Input Widgets"></a>5. Input Widgets</h2><h3 id="5-1-输入控件概述"><a href="#5-1-输入控件概述" class="headerlink" title="5.1 输入控件概述"></a>5.1 输入控件概述</h3><p>输入控件用于获取用户的输入信息，是用户与应用程序交互的主要方式。Qt提供了多种输入控件，支持文本输入、数值输入、选择输入等多种形式。</p>
<h3 id="5-2-常用输入控件"><a href="#5-2-常用输入控件" class="headerlink" title="5.2 常用输入控件"></a>5.2 常用输入控件</h3><ul>
<li><strong>QLineEdit</strong>：单行文本输入框，用于接收用户的文本输入。</li>
<li><strong>QTextEdit</strong>：多行文本编辑器，用于接收和显示大量文本。</li>
<li><strong>QSpinBox</strong>：数值输入框，允许用户通过点击按钮或键盘输入整数值。</li>
<li><strong>QDoubleSpinBox</strong>：数值输入框，允许用户输入浮点数值。</li>
<li><strong>QComboBox</strong>：下拉列表框，允许用户从预定义选项中选择一项。</li>
<li><strong>QCheckBox</strong>：复选框，允许用户选择或取消选择某个选项。</li>
<li><strong>QRadioButton</strong>：单选按钮，允许用户在一组互斥的选项中选择一项。</li>
<li><strong>QSlider</strong>：滑块控件，允许用户通过拖动滑块选择一个范围内的数值。</li>
<li><strong>QDateEdit</strong>：日期输入框，允许用户选择日期。</li>
<li><strong>QTimeEdit</strong>：时间输入框，允许用户选择时间。</li>
</ul>
<h3 id="5-3-示例：使用QLineEdit和QPushButton获取用户输入"><a href="#5-3-示例：使用QLineEdit和QPushButton获取用户输入" class="headerlink" title="5.3 示例：使用QLineEdit和QPushButton获取用户输入"></a>5.3 示例：使用QLineEdit和QPushButton获取用户输入</h3><p>以下示例展示了如何使用<code>QLineEdit</code>获取用户的文本输入，并通过<code>QPushButton</code>触发操作。</p>
<p><strong>示例代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLineEdit&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QVBoxLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLabel&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建主窗口</span></span><br><span class="line">    QWidget window;</span><br><span class="line">    window.<span class="built_in">setWindowTitle</span>(<span class="string">&quot;输入控件示例&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建QLineEdit</span></span><br><span class="line">    QLineEdit *lineEdit = <span class="keyword">new</span> QLineEdit;</span><br><span class="line">    lineEdit-&gt;<span class="built_in">setPlaceholderText</span>(<span class="string">&quot;请输入您的姓名&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建QPushButton</span></span><br><span class="line">    QPushButton *btnSubmit = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;提交&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建QLabel显示结果</span></span><br><span class="line">    QLabel *label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;等待输入...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接按钮信号到槽函数</span></span><br><span class="line">    QObject::<span class="built_in">connect</span>(btnSubmit, &amp;QPushButton::clicked, [&amp;]()&#123;</span><br><span class="line">        QString name = lineEdit-&gt;<span class="built_in">text</span>();</span><br><span class="line">        <span class="keyword">if</span>(!name.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">            label-&gt;<span class="built_in">setText</span>(<span class="string">&quot;您好, &quot;</span> + name + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">            <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;用户输入：&quot;</span> &lt;&lt; name;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            label-&gt;<span class="built_in">setText</span>(<span class="string">&quot;请输入您的姓名。&quot;</span>);</span><br><span class="line">            <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;用户未输入姓名。&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建布局管理器</span></span><br><span class="line">    QVBoxLayout *vLayout = <span class="keyword">new</span> QVBoxLayout;</span><br><span class="line">    vLayout-&gt;<span class="built_in">addWidget</span>(lineEdit);</span><br><span class="line">    vLayout-&gt;<span class="built_in">addWidget</span>(btnSubmit);</span><br><span class="line">    vLayout-&gt;<span class="built_in">addWidget</span>(label);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置主窗口的布局</span></span><br><span class="line">    window.<span class="built_in">setLayout</span>(vLayout);</span><br><span class="line">    window.<span class="built_in">resize</span>(<span class="number">300</span>, <span class="number">150</span>);</span><br><span class="line">    window.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<p><img src="https://i.imgur.com/UVW2526.png" alt="输入控件示例"></p>
<p><strong>解释：</strong></p>
<ul>
<li><strong>QLineEdit</strong>用于获取用户的文本输入，设置了占位符提示“请输入您的姓名”。</li>
<li><strong>QPushButton</strong>用于触发提交操作，当按钮被点击时，获取<code>QLineEdit</code>中的文本并更新<code>QLabel</code>显示。</li>
<li>通过<code>QObject::connect</code>将按钮的<code>clicked</code>信号连接到一个lambda槽函数，实现动态响应用户输入。</li>
</ul>
<h3 id="5-4-示例：使用QSpinBox和QSlider输入数值"><a href="#5-4-示例：使用QSpinBox和QSlider输入数值" class="headerlink" title="5.4 示例：使用QSpinBox和QSlider输入数值"></a>5.4 示例：使用QSpinBox和QSlider输入数值</h3><p>以下示例展示了如何使用<code>QSpinBox</code>和<code>QSlider</code>来获取和展示用户的数值输入。</p>
<p><strong>示例代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QSpinBox&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QSlider&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLabel&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QVBoxLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建主窗口</span></span><br><span class="line">    QWidget window;</span><br><span class="line">    window.<span class="built_in">setWindowTitle</span>(<span class="string">&quot;数值输入控件示例&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建QSpinBox</span></span><br><span class="line">    QSpinBox *spinBox = <span class="keyword">new</span> QSpinBox;</span><br><span class="line">    spinBox-&gt;<span class="built_in">setRange</span>(<span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">    spinBox-&gt;<span class="built_in">setValue</span>(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建QSlider</span></span><br><span class="line">    QSlider *slider = <span class="keyword">new</span> <span class="built_in">QSlider</span>(Qt::Horizontal);</span><br><span class="line">    slider-&gt;<span class="built_in">setRange</span>(<span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">    slider-&gt;<span class="built_in">setValue</span>(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建QLabel显示数值</span></span><br><span class="line">    QLabel *label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;当前值: 50&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接SpinBox和Slider的值变化信号到槽</span></span><br><span class="line">    QObject::<span class="built_in">connect</span>(spinBox, QOverload&lt;<span class="type">int</span>&gt;::<span class="built_in">of</span>(&amp;QSpinBox::valueChanged), [&amp;](<span class="type">int</span> value)&#123;</span><br><span class="line">        slider-&gt;<span class="built_in">setValue</span>(value);</span><br><span class="line">        label-&gt;<span class="built_in">setText</span>(<span class="string">&quot;当前值: &quot;</span> + QString::<span class="built_in">number</span>(value));</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;SpinBox值变化:&quot;</span> &lt;&lt; value;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    QObject::<span class="built_in">connect</span>(slider, &amp;QSlider::valueChanged, [&amp;](<span class="type">int</span> value)&#123;</span><br><span class="line">        spinBox-&gt;<span class="built_in">setValue</span>(value);</span><br><span class="line">        label-&gt;<span class="built_in">setText</span>(<span class="string">&quot;当前值: &quot;</span> + QString::<span class="built_in">number</span>(value));</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Slider值变化:&quot;</span> &lt;&lt; value;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建布局管理器</span></span><br><span class="line">    QVBoxLayout *vLayout = <span class="keyword">new</span> QVBoxLayout;</span><br><span class="line">    vLayout-&gt;<span class="built_in">addWidget</span>(spinBox);</span><br><span class="line">    vLayout-&gt;<span class="built_in">addWidget</span>(slider);</span><br><span class="line">    vLayout-&gt;<span class="built_in">addWidget</span>(label);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置主窗口的布局</span></span><br><span class="line">    window.<span class="built_in">setLayout</span>(vLayout);</span><br><span class="line">    window.<span class="built_in">resize</span>(<span class="number">300</span>, <span class="number">200</span>);</span><br><span class="line">    window.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<p><img src="https://i.imgur.com/XYZ2829.png" alt="数值输入控件示例"></p>
<p><strong>解释：</strong></p>
<ul>
<li><strong>QSpinBox</strong>和<strong>QSlider</strong>都用于获取用户的数值输入，范围设置为0到100，初始值为50。</li>
<li>当用户在SpinBox或Slider中改变数值时，通过信号与槽机制同步更新对方的值，并在QLabel中显示当前值。</li>
<li>通过<code>QOverload&lt;int&gt;::of</code>语法解决了信号重载的问题，确保信号与槽的正确连接。</li>
</ul>
<h3 id="5-5-QComboBox的高级用法"><a href="#5-5-QComboBox的高级用法" class="headerlink" title="5.5 QComboBox的高级用法"></a>5.5 QComboBox的高级用法</h3><p><strong>添加可编辑项和自定义绘制：</strong></p>
<p>可以设置<code>QComboBox</code>为可编辑状态，并自定义每个项的显示内容。</p>
<p><strong>示例代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QComboBox&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建QComboBox</span></span><br><span class="line">    QComboBox comboBox;</span><br><span class="line">    comboBox.<span class="built_in">setWindowTitle</span>(<span class="string">&quot;QComboBox 示例&quot;</span>);</span><br><span class="line">    comboBox.<span class="built_in">setEditable</span>(<span class="literal">true</span>); <span class="comment">// 设置为可编辑</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加项</span></span><br><span class="line">    comboBox.<span class="built_in">addItem</span>(<span class="string">&quot;Option 1&quot;</span>);</span><br><span class="line">    comboBox.<span class="built_in">addItem</span>(<span class="string">&quot;Option 2&quot;</span>);</span><br><span class="line">    comboBox.<span class="built_in">addItem</span>(<span class="string">&quot;Option 3&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加带有用户数据的项</span></span><br><span class="line">    comboBox.<span class="built_in">addItem</span>(<span class="string">&quot;Option 4&quot;</span>, <span class="built_in">QVariant</span>(<span class="number">42</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接信号到槽</span></span><br><span class="line">    QObject::<span class="built_in">connect</span>(&amp;comboBox, QOverload&lt;<span class="type">int</span>&gt;::<span class="built_in">of</span>(&amp;QComboBox::currentIndexChanged), [&amp;](<span class="type">int</span> index)&#123;</span><br><span class="line">        QString text = comboBox.<span class="built_in">currentText</span>();</span><br><span class="line">        QVariant data = comboBox.<span class="built_in">itemData</span>(index);</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;当前选中项：&quot;</span> &lt;&lt; text &lt;&lt; <span class="string">&quot;, 数据：&quot;</span> &lt;&lt; data.<span class="built_in">toInt</span>();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示QComboBox</span></span><br><span class="line">    comboBox.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<p><img src="https://i.imgur.com/BCD3031.png" alt="QComboBox 示例"></p>
<p><strong>解释：</strong></p>
<ul>
<li><strong>QComboBox</strong>设置为可编辑，允许用户输入自定义文本。</li>
<li>使用<code>addItem</code>方法添加带有用户数据的项，通过<code>itemData</code>方法获取关联的数据。</li>
<li>通过<code>currentIndexChanged</code>信号连接到槽函数，实时响应用户的选择变化。</li>
</ul>
<h3 id="5-6-小结"><a href="#5-6-小结" class="headerlink" title="5.6 小结"></a>5.6 小结</h3><p>输入控件是用户与应用程序交互的桥梁，Qt提供了丰富的输入控件来满足不同的输入需求。通过合理选择和配置输入控件，可以提升用户体验，确保应用程序的易用性和功能性。</p>
<hr>
<h2 id="6-Display-Widgets"><a href="#6-Display-Widgets" class="headerlink" title="6. Display Widgets"></a>6. Display Widgets</h2><h3 id="6-1-显示控件概述"><a href="#6-1-显示控件概述" class="headerlink" title="6.1 显示控件概述"></a>6.1 显示控件概述</h3><p>显示控件用于展示信息和数据，是用户界面中不可或缺的一部分。Qt提供了多种显示控件，支持文本显示、图像显示、进度显示等多种形式。</p>
<h3 id="6-2-常用显示控件"><a href="#6-2-常用显示控件" class="headerlink" title="6.2 常用显示控件"></a>6.2 常用显示控件</h3><ul>
<li><strong>QLabel</strong>：标签控件，用于显示文本或图像。</li>
<li><strong>QTextBrowser</strong>：文本浏览器，用于显示富文本内容，支持超链接。</li>
<li><strong>QProgressBar</strong>：进度条控件，用于显示任务的完成进度。</li>
<li><strong>QLCDNumber</strong>：LCD数字显示控件，用于显示数字信息。</li>
<li><strong>QDial</strong>：旋钮控件，类似于音量调节器。</li>
<li><strong>QToolTip</strong>：提示工具，用于显示悬停提示信息。</li>
</ul>
<h3 id="6-3-示例：使用QLabel显示文本和图像"><a href="#6-3-示例：使用QLabel显示文本和图像" class="headerlink" title="6.3 示例：使用QLabel显示文本和图像"></a>6.3 示例：使用QLabel显示文本和图像</h3><p>以下示例展示了如何使用<code>QLabel</code>来显示文本和图像。</p>
<p><strong>示例代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLabel&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPixmap&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QVBoxLayout&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建主窗口</span></span><br><span class="line">    QWidget window;</span><br><span class="line">    window.<span class="built_in">setWindowTitle</span>(<span class="string">&quot;QLabel 示例&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建QLabel用于显示文本</span></span><br><span class="line">    QLabel *textLabel = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;欢迎使用Qt！&quot;</span>);</span><br><span class="line">    textLabel-&gt;<span class="built_in">setAlignment</span>(Qt::AlignCenter);</span><br><span class="line">    textLabel-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;QLabel &#123; font-size: 24px; color: blue; &#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建QLabel用于显示图像</span></span><br><span class="line">    QLabel *imageLabel = <span class="keyword">new</span> QLabel;</span><br><span class="line">    <span class="function">QPixmap <span class="title">pixmap</span><span class="params">(<span class="string">&quot;:/images/logo.png&quot;</span>)</span></span>; <span class="comment">// 确保资源文件中有此图像</span></span><br><span class="line">    imageLabel-&gt;<span class="built_in">setPixmap</span>(pixmap.<span class="built_in">scaled</span>(<span class="number">200</span>, <span class="number">200</span>, Qt::KeepAspectRatio));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建布局管理器</span></span><br><span class="line">    QVBoxLayout *vLayout = <span class="keyword">new</span> QVBoxLayout;</span><br><span class="line">    vLayout-&gt;<span class="built_in">addWidget</span>(textLabel);</span><br><span class="line">    vLayout-&gt;<span class="built_in">addWidget</span>(imageLabel);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置主窗口的布局</span></span><br><span class="line">    window.<span class="built_in">setLayout</span>(vLayout);</span><br><span class="line">    window.<span class="built_in">resize</span>(<span class="number">300</span>, <span class="number">400</span>);</span><br><span class="line">    window.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<p><img src="https://i.imgur.com/EFG3242.png" alt="QLabel 示例"></p>
<p><strong>解释：</strong></p>
<ul>
<li><strong>QLabel</strong>用于显示居中的文本，设置了自定义的字体大小和颜色。</li>
<li><strong>QLabel</strong>还可以用于显示图像，通过设置QPixmap实现。</li>
<li>使用<code>scaled</code>方法调整图像大小，保持纵横比不变。</li>
</ul>
<h3 id="6-4-示例：使用QProgressBar显示任务进度"><a href="#6-4-示例：使用QProgressBar显示任务进度" class="headerlink" title="6.4 示例：使用QProgressBar显示任务进度"></a>6.4 示例：使用QProgressBar显示任务进度</h3><p>以下示例展示了如何使用<code>QProgressBar</code>来显示任务的完成进度，并通过按钮控制进度条的更新。</p>
<p><strong>示例代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QProgressBar&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QVBoxLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTimer&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建主窗口</span></span><br><span class="line">    QWidget window;</span><br><span class="line">    window.<span class="built_in">setWindowTitle</span>(<span class="string">&quot;QProgressBar 示例&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建QProgressBar</span></span><br><span class="line">    QProgressBar *progressBar = <span class="keyword">new</span> QProgressBar;</span><br><span class="line">    progressBar-&gt;<span class="built_in">setRange</span>(<span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">    progressBar-&gt;<span class="built_in">setValue</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建QPushButton</span></span><br><span class="line">    QPushButton *btnStart = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;开始任务&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建布局管理器</span></span><br><span class="line">    QVBoxLayout *vLayout = <span class="keyword">new</span> QVBoxLayout;</span><br><span class="line">    vLayout-&gt;<span class="built_in">addWidget</span>(progressBar);</span><br><span class="line">    vLayout-&gt;<span class="built_in">addWidget</span>(btnStart);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置主窗口的布局</span></span><br><span class="line">    window.<span class="built_in">setLayout</span>(vLayout);</span><br><span class="line">    window.<span class="built_in">resize</span>(<span class="number">300</span>, <span class="number">150</span>);</span><br><span class="line">    window.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建计时器</span></span><br><span class="line">    QTimer timer;</span><br><span class="line">    timer.<span class="built_in">setInterval</span>(<span class="number">100</span>); <span class="comment">// 每100毫秒更新一次</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> progress = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接按钮信号到槽函数</span></span><br><span class="line">    QObject::<span class="built_in">connect</span>(btnStart, &amp;QPushButton::clicked, [&amp;]()&#123;</span><br><span class="line">        progress = <span class="number">0</span>;</span><br><span class="line">        progressBar-&gt;<span class="built_in">setValue</span>(progress);</span><br><span class="line">        timer.<span class="built_in">start</span>();</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;任务开始&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接计时器信号到槽函数</span></span><br><span class="line">    QObject::<span class="built_in">connect</span>(&amp;timer, &amp;QTimer::timeout, [&amp;]()&#123;</span><br><span class="line">        progress += <span class="number">1</span>;</span><br><span class="line">        progressBar-&gt;<span class="built_in">setValue</span>(progress);</span><br><span class="line">        <span class="keyword">if</span>(progress &gt;= <span class="number">100</span>) &#123;</span><br><span class="line">            timer.<span class="built_in">stop</span>();</span><br><span class="line">            <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;任务完成&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<p><img src="https://i.imgur.com/HJK3434.png" alt="QProgressBar 示例"></p>
<p><strong>解释：</strong></p>
<ul>
<li><strong>QProgressBar</strong>设置了范围从0到100，初始值为0。</li>
<li><strong>QPushButton</strong>用于启动任务，当按钮被点击时，进度条开始自动更新。</li>
<li><strong>QTimer</strong>用于模拟任务进度的逐步完成，通过<code>timeout</code>信号更新进度条的值。</li>
<li>当进度达到100时，停止计时器并打印任务完成的信息。</li>
</ul>
<h3 id="6-5-示例：使用QLCDNumber显示动态数字"><a href="#6-5-示例：使用QLCDNumber显示动态数字" class="headerlink" title="6.5 示例：使用QLCDNumber显示动态数字"></a>6.5 示例：使用QLCDNumber显示动态数字</h3><p>以下示例展示了如何使用<code>QLCDNumber</code>动态显示数字，并通过<code>QTimer</code>更新显示内容。</p>
<p><strong>示例代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLCDNumber&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QVBoxLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTimer&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建主窗口</span></span><br><span class="line">    QWidget window;</span><br><span class="line">    window.<span class="built_in">setWindowTitle</span>(<span class="string">&quot;QLCDNumber 示例&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建QLCDNumber</span></span><br><span class="line">    QLCDNumber *lcd = <span class="keyword">new</span> QLCDNumber;</span><br><span class="line">    lcd-&gt;<span class="built_in">setDigitCount</span>(<span class="number">5</span>);</span><br><span class="line">    lcd-&gt;<span class="built_in">display</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建布局管理器</span></span><br><span class="line">    QVBoxLayout *vLayout = <span class="keyword">new</span> QVBoxLayout;</span><br><span class="line">    vLayout-&gt;<span class="built_in">addWidget</span>(lcd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置主窗口的布局</span></span><br><span class="line">    window.<span class="built_in">setLayout</span>(vLayout);</span><br><span class="line">    window.<span class="built_in">resize</span>(<span class="number">200</span>, <span class="number">100</span>);</span><br><span class="line">    window.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建计时器</span></span><br><span class="line">    QTimer timer;</span><br><span class="line">    timer.<span class="built_in">setInterval</span>(<span class="number">1000</span>); <span class="comment">// 每秒更新一次</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接计时器信号到槽函数</span></span><br><span class="line">    QObject::<span class="built_in">connect</span>(&amp;timer, &amp;QTimer::timeout, [&amp;]()&#123;</span><br><span class="line">        count++;</span><br><span class="line">        lcd-&gt;<span class="built_in">display</span>(count);</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;当前计数:&quot;</span> &lt;&lt; count;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    timer.<span class="built_in">start</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<p><img src="https://i.imgur.com/IJK4545.png" alt="QLCDNumber 示例"></p>
<p><strong>解释：</strong></p>
<ul>
<li><strong>QLCDNumber</strong>设置了5位数字显示，初始值为0。</li>
<li><strong>QTimer</strong>每秒触发一次，通过<code>timeout</code>信号更新显示的数字，实现动态计数效果。</li>
<li>通过<code>lcd-&gt;display(count)</code>方法更新显示内容，实时反映计数变化。</li>
</ul>
<h3 id="6-6-QProgressBar与QLCDNumber的结合使用"><a href="#6-6-QProgressBar与QLCDNumber的结合使用" class="headerlink" title="6.6 QProgressBar与QLCDNumber的结合使用"></a>6.6 QProgressBar与QLCDNumber的结合使用</h3><p>可以将<code>QProgressBar</code>和<code>QLCDNumber</code>结合使用，实时显示任务的进度和完成度。</p>
<p><strong>示例代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QProgressBar&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLCDNumber&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QVBoxLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTimer&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建主窗口</span></span><br><span class="line">    QWidget window;</span><br><span class="line">    window.<span class="built_in">setWindowTitle</span>(<span class="string">&quot;进度与数字显示示例&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建QProgressBar</span></span><br><span class="line">    QProgressBar *progressBar = <span class="keyword">new</span> QProgressBar;</span><br><span class="line">    progressBar-&gt;<span class="built_in">setRange</span>(<span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">    progressBar-&gt;<span class="built_in">setValue</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建QLCDNumber</span></span><br><span class="line">    QLCDNumber *lcd = <span class="keyword">new</span> QLCDNumber;</span><br><span class="line">    lcd-&gt;<span class="built_in">setDigitCount</span>(<span class="number">3</span>);</span><br><span class="line">    lcd-&gt;<span class="built_in">display</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建QPushButton</span></span><br><span class="line">    QPushButton *btnStart = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;开始任务&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建布局管理器</span></span><br><span class="line">    QVBoxLayout *vLayout = <span class="keyword">new</span> QVBoxLayout;</span><br><span class="line">    vLayout-&gt;<span class="built_in">addWidget</span>(progressBar);</span><br><span class="line">    vLayout-&gt;<span class="built_in">addWidget</span>(lcd);</span><br><span class="line">    vLayout-&gt;<span class="built_in">addWidget</span>(btnStart);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置主窗口的布局</span></span><br><span class="line">    window.<span class="built_in">setLayout</span>(vLayout);</span><br><span class="line">    window.<span class="built_in">resize</span>(<span class="number">300</span>, <span class="number">200</span>);</span><br><span class="line">    window.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建计时器</span></span><br><span class="line">    QTimer timer;</span><br><span class="line">    timer.<span class="built_in">setInterval</span>(<span class="number">100</span>); <span class="comment">// 每100毫秒更新一次</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> progress = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接按钮信号到槽函数</span></span><br><span class="line">    QObject::<span class="built_in">connect</span>(btnStart, &amp;QPushButton::clicked, [&amp;]()&#123;</span><br><span class="line">        progress = <span class="number">0</span>;</span><br><span class="line">        progressBar-&gt;<span class="built_in">setValue</span>(progress);</span><br><span class="line">        lcd-&gt;<span class="built_in">display</span>(progress);</span><br><span class="line">        timer.<span class="built_in">start</span>();</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;任务开始&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接计时器信号到槽函数</span></span><br><span class="line">    QObject::<span class="built_in">connect</span>(&amp;timer, &amp;QTimer::timeout, [&amp;]()&#123;</span><br><span class="line">        progress += <span class="number">1</span>;</span><br><span class="line">        progressBar-&gt;<span class="built_in">setValue</span>(progress);</span><br><span class="line">        lcd-&gt;<span class="built_in">display</span>(progress);</span><br><span class="line">        <span class="keyword">if</span>(progress &gt;= <span class="number">100</span>) &#123;</span><br><span class="line">            timer.<span class="built_in">stop</span>();</span><br><span class="line">            <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;任务完成&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<p><img src="https://i.imgur.com/JKL5656.png" alt="进度与数字显示示例"></p>
<p><strong>解释：</strong></p>
<ul>
<li><strong>QProgressBar</strong>和<strong>QLCDNumber</strong>分别显示任务的进度和当前进度值。</li>
<li>当用户点击“开始任务”按钮时，计时器开始，每100毫秒更新一次进度条和数字显示。</li>
<li>当进度达到100时，停止计时器并打印任务完成的信息。</li>
</ul>
<h3 id="6-7-小结"><a href="#6-7-小结" class="headerlink" title="6.7 小结"></a>6.7 小结</h3><p>显示控件在用户界面中用于展示各种信息和数据。通过合理使用<code>QLabel</code>、<code>QProgressBar</code>、<code>QLCDNumber</code>等显示控件，可以有效地传达应用程序的状态和反馈，提升用户体验。同时，结合布局管理器和其他控件，能够创建功能丰富且美观的用户界面。</p>
<hr>
<h2 id="7-常用算法及正则表达式"><a href="#7-常用算法及正则表达式" class="headerlink" title="7. 常用算法及正则表达式"></a>7. 常用算法及正则表达式</h2><h3 id="7-1-Qt中提供的常用算法"><a href="#7-1-Qt中提供的常用算法" class="headerlink" title="7.1 Qt中提供的常用算法"></a>7.1 Qt中提供的常用算法</h3><p>Qt提供了一系列与标准C++库类似的算法，主要集中在<code>QtAlgorithms</code>模块。这些算法包括排序、查找、遍历等，帮助开发者高效地处理数据。</p>
<h3 id="7-2-示例：使用Qt算法进行排序和查找"><a href="#7-2-示例：使用Qt算法进行排序和查找" class="headerlink" title="7.2 示例：使用Qt算法进行排序和查找"></a>7.2 示例：使用Qt算法进行排序和查找</h3><p><strong>示例代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QVector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    QVector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;排序前:&quot;</span> &lt;&lt; numbers;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用std::sort进行升序排序</span></span><br><span class="line">    std::<span class="built_in">sort</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;排序后:&quot;</span> &lt;&lt; numbers;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用std::binary_search查找元素</span></span><br><span class="line">    <span class="type">bool</span> found = std::<span class="built_in">binary_search</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;是否找到5:&quot;</span> &lt;&lt; found;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">排序前: QVector(5, 2, 9, 1, 5, 6)</span><br><span class="line">排序后: QVector(1, 2, 5, 5, 6, 9)</span><br><span class="line">是否找到5: true</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>使用<code>std::sort</code>对<code>QVector</code>中的整数进行升序排序。</li>
<li>使用<code>std::binary_search</code>在排序后的<code>QVector</code>中查找特定元素。</li>
</ul>
<h3 id="7-3-Qt中的正则表达式支持"><a href="#7-3-Qt中的正则表达式支持" class="headerlink" title="7.3 Qt中的正则表达式支持"></a>7.3 Qt中的正则表达式支持</h3><p>Qt提供了<code>QRegularExpression</code>类，支持使用正则表达式进行复杂的文本匹配和处理功能。</p>
<h3 id="7-4-示例：使用QRegularExpression进行模式匹配"><a href="#7-4-示例：使用QRegularExpression进行模式匹配" class="headerlink" title="7.4 示例：使用QRegularExpression进行模式匹配"></a>7.4 示例：使用QRegularExpression进行模式匹配</h3><p><strong>示例代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QString&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QRegularExpression&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    QString text = <span class="string">&quot;Contact us at support@example.com or sales@example.org.&quot;</span>;</span><br><span class="line">    <span class="function">QRegularExpression <span class="title">emailRegex</span><span class="params">(<span class="string">R&quot;((\w+@\w+\.\w+))&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    QRegularExpressionMatchIterator i = emailRegex.<span class="built_in">globalMatch</span>(text);</span><br><span class="line">    <span class="keyword">while</span> (i.<span class="built_in">hasNext</span>()) &#123;</span><br><span class="line">        QRegularExpressionMatch match = i.<span class="built_in">next</span>();</span><br><span class="line">        QString email = match.<span class="built_in">captured</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;找到邮箱:&quot;</span> &lt;&lt; email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">找到邮箱: &quot;support@example.com&quot;</span><br><span class="line">找到邮箱: &quot;sales@example.org&quot;</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>使用<code>QRegularExpression</code>定义一个匹配邮箱地址的正则表达式。</li>
<li>使用<code>globalMatch</code>方法获取所有匹配项，并通过迭代器遍历匹配结果。</li>
</ul>
<h3 id="7-5-示例：使用QString-replace与QRegularExpression进行复杂替换"><a href="#7-5-示例：使用QString-replace与QRegularExpression进行复杂替换" class="headerlink" title="7.5 示例：使用QString::replace与QRegularExpression进行复杂替换"></a>7.5 示例：使用QString::replace与QRegularExpression进行复杂替换</h3><p><strong>示例代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QString&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QRegularExpression&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    QString text = <span class="string">&quot;The quick brown fox jumps over the lazy dog.&quot;</span>;</span><br><span class="line">    <span class="function">QRegularExpression <span class="title">regex</span><span class="params">(<span class="string">R&quot;(quick\s+brown\s+fox)&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    QString replacedText = text.<span class="built_in">replace</span>(regex, <span class="string">&quot;swift red fox&quot;</span>);</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;替换后:&quot;</span> &lt;&lt; replacedText;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">替换后: &quot;The swift red fox jumps over the lazy dog.&quot;</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>使用正则表达式匹配“quick brown fox”模式。</li>
<li>使用<code>replace</code>方法将匹配的部分替换为“swift red fox”。</li>
</ul>
<h3 id="7-6-示例：使用QString-split与QRegularExpression进行复杂分割"><a href="#7-6-示例：使用QString-split与QRegularExpression进行复杂分割" class="headerlink" title="7.6 示例：使用QString::split与QRegularExpression进行复杂分割"></a>7.6 示例：使用QString::split与QRegularExpression进行复杂分割</h3><p><strong>示例代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QString&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QRegularExpression&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QStringList&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    QString data = <span class="string">&quot;apple, banana; cherry|date&quot;</span>;</span><br><span class="line">    <span class="function">QRegularExpression <span class="title">regex</span><span class="params">(<span class="string">R&quot;([,;|])&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    QStringList fruits = data.<span class="built_in">split</span>(regex);</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;水果列表:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> QString&amp; fruit : fruits) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; fruit.<span class="built_in">trimmed</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">水果列表:</span><br><span class="line">&quot;apple&quot;</span><br><span class="line">&quot;banana&quot;</span><br><span class="line">&quot;cherry&quot;</span><br><span class="line">&quot;date&quot;</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>使用正则表达式匹配逗号、分号和竖线作为分隔符。</li>
<li>使用<code>split</code>函数按匹配的分隔符分割字符串，并使用<code>trimmed()</code>去除多余的空格。</li>
</ul>
<h3 id="7-7-小结"><a href="#7-7-小结" class="headerlink" title="7.7 小结"></a>7.7 小结</h3><p>Qt中的常用算法和正则表达式支持为数据处理和文本匹配提供了强大的工具。通过合理使用这些功能，开发者可以实现高效且复杂的数据操作和文本处理逻辑，提升应用程序的功能性和用户体验。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文详细介绍了Qt开发中常用的控件类别，包括布局管理器与间隔控件、按钮与容器控件、基于模型的视图控件、基于项的视图控件、输入控件以及显示控件。同时，探讨了Qt中常用的算法和正则表达式支持，展示了如何在实际项目中应用这些功能。</p>
<h3 id="主要内容回顾："><a href="#主要内容回顾：" class="headerlink" title="主要内容回顾："></a>主要内容回顾：</h3><ol>
<li><p><strong>Layouts &amp; Spacers</strong>：</p>
<ul>
<li>讲解了不同类型的布局管理器（QHBoxLayout、QVBoxLayout、QGridLayout、QFormLayout）及其应用。</li>
<li>介绍了QSpacerItem的使用，帮助优化控件间的间距和布局。</li>
</ul>
</li>
<li><p><strong>Buttons &amp; Containers</strong>：</p>
<ul>
<li>介绍了各种按钮控件（QPushButton、QToolButton、QRadioButton、QCheckBox、QCommandLinkButton）的使用方法和应用场景。</li>
<li>探讨了容器控件（QGroupBox、QFrame、QScrollArea）的功能和使用技巧。</li>
</ul>
</li>
<li><p><strong>Item Views</strong>：</p>
<ul>
<li>说明了基于模型的视图控件（QListView、QTableView、QTreeView）的使用方法及其在数据展示中的优势。</li>
<li>通过示例展示了如何结合模型类（QStringListModel、QStandardItemModel）使用视图控件。</li>
</ul>
</li>
<li><p><strong>Item Widgets</strong>：</p>
<ul>
<li>介绍了基于项的视图控件（QListWidget、QTreeWidget、QTableWidget）的简化接口和使用方法。</li>
<li>通过示例展示了如何快速创建和管理项视图控件。</li>
</ul>
</li>
<li><p><strong>Input Widgets</strong>：</p>
<ul>
<li>讲解了常用的输入控件（QLineEdit、QTextEdit、QSpinBox、QDoubleSpinBox、QComboBox、QCheckBox、QRadioButton、QSlider、QDateEdit、QTimeEdit）的功能和使用场景。</li>
<li>通过示例展示了如何获取和处理用户输入。</li>
</ul>
</li>
<li><p><strong>Display Widgets</strong>：</p>
<ul>
<li>介绍了常用的显示控件（QLabel、QTextBrowser、QProgressBar、QLCDNumber、QDial、QToolTip）的使用方法和应用场景。</li>
<li>通过示例展示了如何动态更新和展示信息。</li>
</ul>
</li>
<li><p><strong>常用算法及正则表达式</strong>：</p>
<ul>
<li>探讨了Qt提供的常用算法函数，如排序、查找和遍历。</li>
<li>介绍了Qt中强大的正则表达式支持，通过QRegularExpression实现复杂的文本匹配和处理。</li>
</ul>
</li>
</ol>
<h3 id="下一步学习建议："><a href="#下一步学习建议：" class="headerlink" title="下一步学习建议："></a>下一步学习建议：</h3><p>掌握了Qt开发常用控件的使用方法后，建议继续深入学习以下高级内容，以全面提升Qt C++编程能力：</p>
<ul>
<li><p><strong>类型特性检测：<code>type_traits</code>库的应用</strong>：</p>
<ul>
<li>学习如何使用<code>std::is_integral</code>、<code>std::is_rvalue_reference</code>、<code>std::is_arithmetic</code>、<code>std::is_volatile</code>、<code>std::is_class</code>等进行类型判断，辅助模板元编程。</li>
</ul>
</li>
<li><p><strong>变量模板与内联变量（C++14）</strong>：</p>
<ul>
<li>探索C++14中的变量模板和<code>inline</code>变量的概念，了解它们在实际编程中的应用。</li>
</ul>
</li>
<li><p><strong>多线程编程的高级工具</strong>：</p>
<ul>
<li>深入了解线程局部存储、锁的优化策略、线程池等高级多线程编程工具，提升并发编程的能力。</li>
</ul>
</li>
<li><p><strong>模板编程的高级技巧</strong>：</p>
<ul>
<li>掌握模板元编程、SFINAE（替换失败不是错误）等高级模板编程技术，提升代码的泛化和复用能力。</li>
</ul>
</li>
<li><p><strong>Qt框架的核心概念与高级功能</strong>：</p>
<ul>
<li>深入学习Qt的信号与槽机制、事件处理、模型-视图架构、Qt Quick等高级功能，构建更复杂和功能丰富的应用程序。</li>
</ul>
</li>
<li><p><strong>数据库集成与操作</strong>：</p>
<ul>
<li>学习Qt的数据库模块，了解如何集成和操作不同类型的数据库，进行数据持久化管理。</li>
</ul>
</li>
<li><p><strong>网络编程</strong>：</p>
<ul>
<li>探索Qt的网络模块，掌握TCP&#x2F;IP通信、HTTP请求处理等网络编程技能。</li>
</ul>
</li>
<li><p><strong>图形用户界面设计</strong>：</p>
<ul>
<li>学习Qt Designer的高级使用技巧，设计复杂的用户界面，并结合动画和样式表提升界面体验。</li>
</ul>
</li>
<li><p><strong>资源管理与多语言支持</strong>：</p>
<ul>
<li>掌握Qt的资源系统，管理应用程序资源，了解如何实现多语言支持，提升应用的国际化能力。</li>
</ul>
</li>
</ul>
<p>通过持续学习和实践，结合本文所介绍的基础知识，您将能够更加高效地利用Qt框架进行C++开发，构建出功能丰富、性能优异且用户友好的应用程序。</p>
<hr>
<p><em>感谢您的阅读与支持！如果您对本文内容有任何疑问或建议，欢迎在评论区留言与我们交流。请继续关注我们的系列文章，深入了解Qt C++开发的更多高级特性和实战技巧。</em></p>
]]></content>
  </entry>
  <entry>
    <title>从QTableView看模型-视图-代理（Model-View-Delegate）架构</title>
    <url>/2024/12/26/%E4%BB%8EQTableView%E7%9C%8B%E6%A8%A1%E5%9E%8B-%E8%A7%86%E5%9B%BE-%E4%BB%A3%E7%90%86%EF%BC%88Model-View-Delegate%EF%BC%89%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><span id="more"></span>

<h2 id="从QTableView看模型-视图-代理（Model-View-Delegate）架构"><a href="#从QTableView看模型-视图-代理（Model-View-Delegate）架构" class="headerlink" title="从QTableView看模型-视图-代理（Model-View-Delegate）架构"></a>从QTableView看模型-视图-代理（Model-View-Delegate）架构</h2><p><code>QTableView</code> 是 Qt 框架中的一个用于显示和操作表格数据的视图类。它基于模型-视图（Model-View）架构，允许开发者将数据从模型中分离出来并展示为表格。<code>QTableView</code> 不直接存储数据，而是通过模型接口与数据源进行交互，这使得它特别适合处理复杂和动态的数据集。</p>
<h3 id="1-主要功能"><a href="#1-主要功能" class="headerlink" title="1. 主要功能"></a>1. <strong>主要功能</strong></h3><ul>
<li><strong>显示二维数据</strong>：<code>QTableView</code> 用于显示由行和列组成的二维数据表。</li>
<li><strong>支持可视化排序和过滤</strong>：通过与模型和代理（如 <code>QSortFilterProxyModel</code>）结合使用，<code>QTableView</code> 可以方便地实现数据的排序和过滤。</li>
<li><strong>灵活的数据展示</strong>：通过自定义模型或代理模型，可以以多种方式展示数据，包括自定义单元格样式、不同的数据类型（文本、图片、复选框等）。</li>
<li><strong>可编辑的表格</strong>：<code>QTableView</code> 支持用户在视图中直接编辑单元格数据，并将修改的值更新到模型中。</li>
</ul>
<h3 id="2-模型-视图架构"><a href="#2-模型-视图架构" class="headerlink" title="2. 模型-视图架构"></a>2. <strong>模型-视图架构</strong></h3><p><code>QTableView</code> 是基于 Qt 的模型-视图-代理（Model-View-Delegate）设计模式的一部分。它不直接保存数据，而是依赖于一个数据模型（如 <code>QStandardItemModel</code> 或自定义的模型类）来提供数据。</p>
<ul>
<li><strong>数据模型（Model）</strong>：模型管理数据并通过接口提供数据给视图。常见的模型类包括 <code>QStandardItemModel</code>、<code>QSqlTableModel</code> 和 <code>QAbstractTableModel</code>。</li>
<li><strong>视图（View）</strong>：<code>QTableView</code> 是视图部分，负责显示模型中的数据并允许用户与之交互。</li>
<li><strong>代理（Delegate）</strong>：通过代理，可以自定义单元格的呈现方式，例如如何显示或编辑特定单元格的数据。</li>
</ul>
<h3 id="3-QTableView-使用示例"><a href="#3-QTableView-使用示例" class="headerlink" title="3. QTableView 使用示例"></a>3. <strong>QTableView 使用示例</strong></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTableView&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QStandardItemModel&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建模型并设置数据</span></span><br><span class="line">    <span class="function">QStandardItemModel <span class="title">model</span><span class="params">(<span class="number">4</span>, <span class="number">2</span>)</span></span>; <span class="comment">// 4行2列</span></span><br><span class="line">    model.<span class="built_in">setHorizontalHeaderLabels</span>(&#123;<span class="string">&quot;Name&quot;</span>, <span class="string">&quot;Age&quot;</span>&#125;);</span><br><span class="line">    model.<span class="built_in">setItem</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;Alice&quot;</span>));</span><br><span class="line">    model.<span class="built_in">setItem</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;30&quot;</span>));</span><br><span class="line">    model.<span class="built_in">setItem</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;Bob&quot;</span>));</span><br><span class="line">    model.<span class="built_in">setItem</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;25&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建表视图</span></span><br><span class="line">    QTableView tableView;</span><br><span class="line">    tableView.<span class="built_in">setModel</span>(&amp;model); <span class="comment">// 连接视图和模型</span></span><br><span class="line">    tableView.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个简单的例子中，我们创建了一个 <code>QStandardItemModel</code> 来存储表格数据，然后将模型设置为 <code>QTableView</code> 的数据源，<code>QTableView</code> 随后显示数据。</p>
<h3 id="4-自定义功能"><a href="#4-自定义功能" class="headerlink" title="4. 自定义功能"></a>4. <strong>自定义功能</strong></h3><ul>
<li><strong>自定义外观</strong>：可以通过重写 <code>QStyledItemDelegate</code> 来自定义每个单元格的外观和编辑器。</li>
<li><strong>单元格交互</strong>：可以设置 <code>QTableView</code> 的选择模式（例如单选、多选）、编辑策略（例如双击编辑）等。</li>
<li><strong>与数据库结合</strong>：使用 <code>QSqlTableModel</code> 等模型，可以直接将数据库表与 <code>QTableView</code> 绑定，实现数据库数据的展示与操作。</li>
</ul>
<h3 id="5-与-QTableWidget-的区别"><a href="#5-与-QTableWidget-的区别" class="headerlink" title="5. 与 QTableWidget 的区别"></a>5. <strong>与 QTableWidget 的区别</strong></h3><ul>
<li>**<code>QTableView</code>**：基于模型-视图架构，更加灵活，适合处理动态或复杂的数据源。数据逻辑完全交给模型来处理。</li>
<li>**<code>QTableWidget</code>**：是一种简单的表格部件，直接在内部管理数据，适用于较小且不复杂的数据集。</li>
</ul>
<p>模型-视图-代理（Model-View-Delegate）是 Qt 中的一种设计模式，用于处理用户界面与数据的分离，特别适合展示复杂的、动态的数据。它主要包括三个部分：模型（Model）、视图（View）和代理（Delegate）。这种模式在 <code>QTableView</code>、<code>QListView</code>、<code>QTreeView</code> 等部件中得到了广泛应用。</p>
<h2 id="模型-视图-代理是什么"><a href="#模型-视图-代理是什么" class="headerlink" title="模型-视图-代理是什么"></a>模型-视图-代理是什么</h2><h3 id="1-模型-视图-代理的概念"><a href="#1-模型-视图-代理的概念" class="headerlink" title="1. 模型-视图-代理的概念"></a>1. <strong>模型-视图-代理的概念</strong></h3><h4 id="模型-Model"><a href="#模型-Model" class="headerlink" title="模型 (Model)"></a><strong>模型 (Model)</strong></h4><p>模型负责管理和提供数据。它独立于视图，存储数据并通过提供接口允许视图访问这些数据。模型不仅负责提供数据，还负责管理数据的状态，例如添加、删除或修改数据。</p>
<p>在 Qt 中，模型一般从 <code>QAbstractItemModel</code> 类派生，常见的模型类有：</p>
<ul>
<li><code>QStandardItemModel</code>：一个简单的、通用的数据模型，适合二维数据。</li>
<li><code>QSqlTableModel</code>：用于操作 SQL 数据库表的数据模型。</li>
<li><code>QAbstractListModel</code>、<code>QAbstractTableModel</code>：这些是自定义模型的基类，允许开发者根据需求定制模型。</li>
</ul>
<h4 id="视图-View"><a href="#视图-View" class="headerlink" title="视图 (View)"></a><strong>视图 (View)</strong></h4><p>视图负责显示模型中的数据。它不直接操作数据，而是通过调用模型提供的接口来显示数据。视图的任务是将模型中的数据可视化，允许用户与数据进行交互（如选择、排序、编辑等）。</p>
<p>常见的视图类包括：</p>
<ul>
<li><code>QTableView</code>：用于显示表格形式的数据。</li>
<li><code>QListView</code>：用于显示列表形式的数据。</li>
<li><code>QTreeView</code>：用于显示树形结构的数据。</li>
</ul>
<h4 id="代理-Delegate"><a href="#代理-Delegate" class="headerlink" title="代理 (Delegate)"></a><strong>代理 (Delegate)</strong></h4><p>代理负责处理数据的展示和编辑。默认情况下，视图会使用标准的显示和编辑方法（例如文本显示、文本编辑），但通过代理，开发者可以自定义数据的呈现方式。例如，可以使用代理自定义单元格的绘制方式，或者为单元格提供自定义的编辑控件（如下拉菜单、复选框等）。</p>
<p><code>QStyledItemDelegate</code> 是 Qt 中的默认代理类，可以通过继承和重写它来自定义外观和编辑行为。</p>
<h3 id="2-模型-视图-代理的工作原理"><a href="#2-模型-视图-代理的工作原理" class="headerlink" title="2. 模型-视图-代理的工作原理"></a>2. <strong>模型-视图-代理的工作原理</strong></h3><p>在这个架构中，视图和模型是完全分离的。视图通过模型的接口来访问数据，并使用代理来决定如何显示和编辑这些数据。视图不需要知道数据的具体细节，所有的数据操作都由模型负责。代理则作为视图和数据之间的一个中间层，提供了灵活的自定义能力。</p>
<p>简要流程如下：</p>
<ol>
<li><strong>视图请求数据</strong>：当视图需要显示某个单元格时，它会向模型请求数据。模型通过 <code>data()</code> 函数返回该单元格的数据。</li>
<li><strong>视图显示数据</strong>：视图将数据传递给代理，代理决定如何绘制和显示该数据（例如，文本、颜色、格式等）。</li>
<li><strong>用户交互</strong>：用户在视图中与数据交互（如点击、编辑），视图将这些操作反馈给代理，代理负责处理如何展示编辑器或如何保存编辑结果到模型中。</li>
<li><strong>模型更新数据</strong>：当数据发生变化时，模型通过信号（如 <code>dataChanged()</code>）通知视图更新显示。</li>
</ol>
<h3 id="3-模型-视图-代理模式的优势"><a href="#3-模型-视图-代理模式的优势" class="headerlink" title="3. 模型-视图-代理模式的优势"></a>3. <strong>模型-视图-代理模式的优势</strong></h3><ul>
<li><strong>分离关注点</strong>：视图和模型分离使得数据和用户界面的逻辑分开，模型专注于数据的管理，而视图专注于数据的显示。这样代码更容易维护和扩展。</li>
<li><strong>灵活性</strong>：通过代理可以灵活自定义数据的呈现和编辑方式，而不需要修改视图或模型。</li>
<li><strong>数据共享</strong>：多个视图可以共享同一个模型，这意味着不同的视图可以显示相同的数据，不需要为每个视图复制数据。</li>
<li><strong>支持大数据量处理</strong>：因为模型和视图分离，视图只在需要时访问模型中的数据，所以在处理大量数据时性能更好。</li>
</ul>
<h3 id="4-模型-视图-代理的示例"><a href="#4-模型-视图-代理的示例" class="headerlink" title="4. 模型-视图-代理的示例"></a>4. <strong>模型-视图-代理的示例</strong></h3><p>下面是一个简单的示例，展示如何使用模型、视图和代理来构建一个简单的表格界面，并使用代理来自定义单元格的编辑行为。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTableView&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QStandardItemModel&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QStyledItemDelegate&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QSpinBox&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义代理：用于在单元格中显示 QSpinBox 编辑器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpinBoxDelegate</span> : <span class="keyword">public</span> QStyledItemDelegate &#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SpinBoxDelegate</span>(QObject *parent = <span class="literal">nullptr</span>) : <span class="built_in">QStyledItemDelegate</span>(parent) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建自定义编辑器</span></span><br><span class="line">    <span class="function">QWidget *<span class="title">createEditor</span><span class="params">(QWidget *parent, <span class="type">const</span> QStyleOptionViewItem &amp;option, <span class="type">const</span> QModelIndex &amp;index)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        QSpinBox *editor = <span class="keyword">new</span> <span class="built_in">QSpinBox</span>(parent);</span><br><span class="line">        editor-&gt;<span class="built_in">setMinimum</span>(<span class="number">0</span>);</span><br><span class="line">        editor-&gt;<span class="built_in">setMaximum</span>(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">return</span> editor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置编辑器的初始值</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setEditorData</span><span class="params">(QWidget *editor, <span class="type">const</span> QModelIndex &amp;index)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> value = index.<span class="built_in">model</span>()-&gt;<span class="built_in">data</span>(index, Qt::EditRole).<span class="built_in">toInt</span>();</span><br><span class="line">        QSpinBox *spinBox = <span class="built_in">static_cast</span>&lt;QSpinBox*&gt;(editor);</span><br><span class="line">        spinBox-&gt;<span class="built_in">setValue</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将编辑器中的数据保存到模型中</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setModelData</span><span class="params">(QWidget *editor, QAbstractItemModel *model, <span class="type">const</span> QModelIndex &amp;index)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        QSpinBox *spinBox = <span class="built_in">static_cast</span>&lt;QSpinBox*&gt;(editor);</span><br><span class="line">        model-&gt;<span class="built_in">setData</span>(index, spinBox-&gt;<span class="built_in">value</span>(), Qt::EditRole);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建模型</span></span><br><span class="line">    <span class="function">QStandardItemModel <span class="title">model</span><span class="params">(<span class="number">4</span>, <span class="number">2</span>)</span></span>; <span class="comment">// 4行2列</span></span><br><span class="line">    model.<span class="built_in">setHorizontalHeaderLabels</span>(&#123;<span class="string">&quot;Name&quot;</span>, <span class="string">&quot;Age&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入数据</span></span><br><span class="line">    model.<span class="built_in">setItem</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;Alice&quot;</span>));</span><br><span class="line">    model.<span class="built_in">setItem</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;30&quot;</span>));</span><br><span class="line">    model.<span class="built_in">setItem</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;Bob&quot;</span>));</span><br><span class="line">    model.<span class="built_in">setItem</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;25&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建表格视图</span></span><br><span class="line">    QTableView tableView;</span><br><span class="line">    tableView.<span class="built_in">setModel</span>(&amp;model);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用自定义代理</span></span><br><span class="line">    SpinBoxDelegate delegate;</span><br><span class="line">    tableView.<span class="built_in">setItemDelegateForColumn</span>(<span class="number">1</span>, &amp;delegate); <span class="comment">// 只在第二列使用自定义代理</span></span><br><span class="line"></span><br><span class="line">    tableView.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. <strong>总结</strong></h3><p>模型-视图-代理架构的主要特点是分离数据和展示逻辑，使得开发更加模块化、灵活且易于维护。通过模型管理数据，通过视图展示数据，并且可以通过代理来自定义数据的呈现和交互方式。这种设计模式在处理复杂的数据展示、编辑需求时非常强大，尤其适用于需要处理大规模或动态变化的数据集的场景。</p>
]]></content>
  </entry>
  <entry>
    <title>详解Qt中的委托</title>
    <url>/2024/12/26/%E8%AF%A6%E8%A7%A3Qt%E4%B8%AD%E7%9A%84%E5%A7%94%E6%89%98/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在 Qt 框架中，<strong>委托（Delegate）</strong> 是模型-视图（Model-View）架构中的核心组件，负责管理和控制数据在视图中的显示和编辑方式。委托允许开发者自定义数据的呈现和编辑控件，从而实现灵活且丰富的用户界面。本文将深入探讨 Qt 中的委托，结合具体的代码示例，详细说明其工作原理、使用方法以及如何创建自定义委托。</p>
<span id="more"></span>

<h2 id="Qt-的模型-视图架构简介"><a href="#Qt-的模型-视图架构简介" class="headerlink" title="Qt 的模型-视图架构简介"></a>Qt 的模型-视图架构简介</h2><p>Qt 的模型-视图架构将数据（模型）与用户界面（视图）分离，允许开发者以更模块化和可维护的方式构建应用程序。架构中的主要组件包括：</p>
<ul>
<li><strong>模型（Model）</strong>：负责管理和存储数据，如 <code>QStandardItemModel</code>、<code>QAbstractTableModel</code> 等。</li>
<li><strong>视图（View）</strong>：负责呈现数据，如 <code>QListView</code>、<code>QTableView</code>、<code>QTreeView</code> 等。</li>
<li><strong>委托（Delegate）</strong>：负责管理数据在视图中的显示和编辑方式。</li>
</ul>
<p>![img](..&#x2F;..&#x2F;..&#x2F;Downloads&#x2F;技术博客 2&#x2F;assets&#x2F;modelview-overview.png)</p>
<h2 id="委托的基本概念与职责"><a href="#委托的基本概念与职责" class="headerlink" title="委托的基本概念与职责"></a>委托的基本概念与职责</h2><p>委托主要有两个核心职责：</p>
<ol>
<li><strong>绘制（Rendering）</strong>：决定如何在视图中绘制每一个数据项，包括文本、图标、背景等。</li>
<li><strong>编辑（Editing）</strong>：提供合适的编辑控件，允许用户修改数据，并将修改后的数据保存回模型。</li>
</ol>
<p>通过委托，开发者可以自定义数据的展示形式和编辑方式，实现复杂的用户界面需求。</p>
<h3 id="委托的主要方法"><a href="#委托的主要方法" class="headerlink" title="委托的主要方法"></a>委托的主要方法</h3><ul>
<li><code>paint(QPainter *painter, const QStyleOptionViewItem &amp;option, const QModelIndex &amp;index) const</code>：负责绘制数据项。</li>
<li><code>createEditor(QWidget *parent, const QStyleOptionViewItem &amp;option, const QModelIndex &amp;index) const</code>：创建用于编辑的控件。</li>
<li><code>setEditorData(QWidget *editor, const QModelIndex &amp;index) const</code>：将模型数据设置到编辑控件中。</li>
<li><code>setModelData(QWidget *editor, QAbstractItemModel *model, const QModelIndex &amp;index) const</code>：将编辑控件中的数据保存回模型。</li>
<li><code>updateEditorGeometry(QWidget *editor, const QStyleOptionViewItem &amp;option, const QModelIndex &amp;index) const</code>：更新编辑控件的几何位置。</li>
</ul>
<h2 id="Qt-提供的默认委托"><a href="#Qt-提供的默认委托" class="headerlink" title="Qt 提供的默认委托"></a>Qt 提供的默认委托</h2><p>Qt 提供了几个默认的委托类，满足大多数常见的需求：</p>
<h3 id="QStyledItemDelegate"><a href="#QStyledItemDelegate" class="headerlink" title="QStyledItemDelegate"></a>QStyledItemDelegate</h3><p><code>QStyledItemDelegate</code> 是 Qt 提供的默认委托类，支持现代样式和样式表。它基于 <code>QItemDelegate</code>，并增加了对样式的更好支持。大多数情况下，使用 <code>QStyledItemDelegate</code> 已经足够。</p>
<h3 id="QItemDelegate"><a href="#QItemDelegate" class="headerlink" title="QItemDelegate"></a>QItemDelegate</h3><p><code>QItemDelegate</code> 是较早的委托类，功能类似于 <code>QStyledItemDelegate</code>，但不支持某些现代样式和特性。一般推荐使用 <code>QStyledItemDelegate</code>，除非有特定需求。</p>
<h2 id="自定义委托的创建与使用"><a href="#自定义委托的创建与使用" class="headerlink" title="自定义委托的创建与使用"></a>自定义委托的创建与使用</h2><p>在某些情况下，默认的委托无法满足特定的需求，例如需要在视图中显示自定义控件或特定的绘制效果。这时，可以通过继承 <code>QStyledItemDelegate</code> 或 <code>QItemDelegate</code> 来创建自定义委托。</p>
<h3 id="示例一：自定义进度条委托"><a href="#示例一：自定义进度条委托" class="headerlink" title="示例一：自定义进度条委托"></a>示例一：自定义进度条委托</h3><p>假设我们需要在 <code>QTableView</code> 的某一列中显示一个进度条，表示某个任务的完成度。以下是创建和使用自定义进度条委托的步骤：</p>
<h4 id="1-创建自定义委托类"><a href="#1-创建自定义委托类" class="headerlink" title="1. 创建自定义委托类"></a>1. 创建自定义委托类</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ProgressBarDelegate.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PROGRESSBARDELEGATE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROGRESSBARDELEGATE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QStyledItemDelegate&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProgressBarDelegate</span> : <span class="keyword">public</span> QStyledItemDelegate &#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">ProgressBarDelegate</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写绘制方法</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">paint</span><span class="params">(QPainter *painter, <span class="type">const</span> QStyleOptionViewItem &amp;option,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">const</span> QModelIndex &amp;index)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写编辑控件创建方法（如果需要编辑）</span></span><br><span class="line">    <span class="function">QWidget *<span class="title">createEditor</span><span class="params">(QWidget *parent, <span class="type">const</span> QStyleOptionViewItem &amp;option,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> QModelIndex &amp;index)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写设置编辑控件数据方法</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setEditorData</span><span class="params">(QWidget *editor, <span class="type">const</span> QModelIndex &amp;index)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写保存编辑控件数据方法</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setModelData</span><span class="params">(QWidget *editor, QAbstractItemModel *model,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="type">const</span> QModelIndex &amp;index)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// PROGRESSBARDELEGATE_H</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ProgressBarDelegate.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ProgressBarDelegate.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPainter&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QProgressBar&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QStyleOptionProgressBar&gt;</span></span></span><br><span class="line"></span><br><span class="line">ProgressBarDelegate::<span class="built_in">ProgressBarDelegate</span>(QObject *parent)</span><br><span class="line">    : <span class="built_in">QStyledItemDelegate</span>(parent) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ProgressBarDelegate::paint</span><span class="params">(QPainter *painter, <span class="type">const</span> QStyleOptionViewItem &amp;option,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="type">const</span> QModelIndex &amp;index)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取进度值</span></span><br><span class="line">    <span class="type">int</span> progress = index.<span class="built_in">data</span>(Qt::DisplayRole).<span class="built_in">toInt</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置进度条选项</span></span><br><span class="line">    QStyleOptionProgressBar progressBarOption;</span><br><span class="line">    progressBarOption.rect = option.rect;</span><br><span class="line">    progressBarOption.minimum = <span class="number">0</span>;</span><br><span class="line">    progressBarOption.maximum = <span class="number">100</span>;</span><br><span class="line">    progressBarOption.progress = progress;</span><br><span class="line">    progressBarOption.text = QString::<span class="built_in">number</span>(progress) + <span class="string">&quot;%&quot;</span>;</span><br><span class="line">    progressBarOption.textVisible = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用应用程序的样式绘制进度条</span></span><br><span class="line">    QApplication::<span class="built_in">style</span>()-&gt;<span class="built_in">drawControl</span>(QStyle::CE_ProgressBar, &amp;progressBarOption, painter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">QWidget *<span class="title">ProgressBarDelegate::createEditor</span><span class="params">(QWidget *parent, <span class="type">const</span> QStyleOptionViewItem &amp;option,</span></span></span><br><span class="line"><span class="params"><span class="function">                                          <span class="type">const</span> QModelIndex &amp;index)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 QSlider 作为编辑控件</span></span><br><span class="line">    QSlider *editor = <span class="keyword">new</span> <span class="built_in">QSlider</span>(parent);</span><br><span class="line">    editor-&gt;<span class="built_in">setOrientation</span>(Qt::Horizontal);</span><br><span class="line">    editor-&gt;<span class="built_in">setMinimum</span>(<span class="number">0</span>);</span><br><span class="line">    editor-&gt;<span class="built_in">setMaximum</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">return</span> editor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ProgressBarDelegate::setEditorData</span><span class="params">(QWidget *editor, <span class="type">const</span> QModelIndex &amp;index)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> value = index.<span class="built_in">data</span>(Qt::DisplayRole).<span class="built_in">toInt</span>();</span><br><span class="line">    QSlider *slider = <span class="built_in">qobject_cast</span>&lt;QSlider*&gt;(editor);</span><br><span class="line">    <span class="keyword">if</span> (slider) &#123;</span><br><span class="line">        slider-&gt;<span class="built_in">setValue</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ProgressBarDelegate::setModelData</span><span class="params">(QWidget *editor, QAbstractItemModel *model,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      <span class="type">const</span> QModelIndex &amp;index)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    QSlider *slider = <span class="built_in">qobject_cast</span>&lt;QSlider*&gt;(editor);</span><br><span class="line">    <span class="keyword">if</span> (slider) &#123;</span><br><span class="line">        <span class="type">int</span> value = slider-&gt;<span class="built_in">value</span>();</span><br><span class="line">        model-&gt;<span class="built_in">setData</span>(index, value, Qt::EditRole);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-在视图中应用自定义委托"><a href="#2-在视图中应用自定义委托" class="headerlink" title="2. 在视图中应用自定义委托"></a>2. 在视图中应用自定义委托</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTableView&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QStandardItemModel&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ProgressBarDelegate.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建模型</span></span><br><span class="line">    <span class="function">QStandardItemModel <span class="title">model</span><span class="params">(<span class="number">5</span>, <span class="number">2</span>)</span></span>; <span class="comment">// 5 行 2 列</span></span><br><span class="line">    model.<span class="built_in">setHorizontalHeaderLabels</span>(<span class="built_in">QStringList</span>() &lt;&lt; <span class="string">&quot;任务&quot;</span> &lt;&lt; <span class="string">&quot;进度&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填充模型数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> row = <span class="number">0</span>; row &lt; <span class="number">5</span>; ++row) &#123;</span><br><span class="line">        QStandardItem *taskItem = <span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="built_in">QString</span>(<span class="string">&quot;任务 %1&quot;</span>).<span class="built_in">arg</span>(row + <span class="number">1</span>));</span><br><span class="line">        QStandardItem *progressItem = <span class="keyword">new</span> <span class="built_in">QStandardItem</span>(QString::<span class="built_in">number</span>((row + <span class="number">1</span>) * <span class="number">20</span>));</span><br><span class="line">        progressItem-&gt;<span class="built_in">setData</span>((row + <span class="number">1</span>) * <span class="number">20</span>, Qt::DisplayRole);</span><br><span class="line">        model.<span class="built_in">setItem</span>(row, <span class="number">0</span>, taskItem);</span><br><span class="line">        model.<span class="built_in">setItem</span>(row, <span class="number">1</span>, progressItem);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建视图</span></span><br><span class="line">    QTableView tableView;</span><br><span class="line">    tableView.<span class="built_in">setModel</span>(&amp;model);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 应用自定义委托到第二列（进度列）</span></span><br><span class="line">    ProgressBarDelegate *delegate = <span class="keyword">new</span> <span class="built_in">ProgressBarDelegate</span>(&amp;tableView);</span><br><span class="line">    tableView.<span class="built_in">setItemDelegateForColumn</span>(<span class="number">1</span>, delegate);</span><br><span class="line"></span><br><span class="line">    tableView.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-运行效果"><a href="#3-运行效果" class="headerlink" title="3. 运行效果"></a>3. 运行效果</h4><p>运行上述代码后，<code>QTableView</code> 的第二列将显示进度条，表示每个任务的完成度。用户可以点击进度条区域进行编辑，使用滑块 (<code>QSlider</code>) 来调整进度值。</p>
<h3 id="示例二：带有下拉菜单的委托"><a href="#示例二：带有下拉菜单的委托" class="headerlink" title="示例二：带有下拉菜单的委托"></a>示例二：带有下拉菜单的委托</h3><p>假设我们需要在视图中为某一列提供一个下拉菜单，允许用户从预定义的选项中选择一个值。</p>
<h4 id="1-创建自定义委托类-1"><a href="#1-创建自定义委托类-1" class="headerlink" title="1. 创建自定义委托类"></a>1. 创建自定义委托类</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ComboBoxDelegate.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> COMBOBOXDELEGATE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COMBOBOXDELEGATE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QStyledItemDelegate&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ComboBoxDelegate</span> : <span class="keyword">public</span> QStyledItemDelegate &#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">ComboBoxDelegate</span><span class="params">(<span class="type">const</span> QStringList &amp;items, QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写编辑控件创建方法</span></span><br><span class="line">    <span class="function">QWidget *<span class="title">createEditor</span><span class="params">(QWidget *parent, <span class="type">const</span> QStyleOptionViewItem &amp;option,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> QModelIndex &amp;index)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写设置编辑控件数据方法</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setEditorData</span><span class="params">(QWidget *editor, <span class="type">const</span> QModelIndex &amp;index)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写保存编辑控件数据方法</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setModelData</span><span class="params">(QWidget *editor, QAbstractItemModel *model,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="type">const</span> QModelIndex &amp;index)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QStringList m_items;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// COMBOBOXDELEGATE_H</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ComboBoxDelegate.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ComboBoxDelegate.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QComboBox&gt;</span></span></span><br><span class="line"></span><br><span class="line">ComboBoxDelegate::<span class="built_in">ComboBoxDelegate</span>(<span class="type">const</span> QStringList &amp;items, QObject *parent)</span><br><span class="line">    : <span class="built_in">QStyledItemDelegate</span>(parent), <span class="built_in">m_items</span>(items) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">QWidget *<span class="title">ComboBoxDelegate::createEditor</span><span class="params">(QWidget *parent, <span class="type">const</span> QStyleOptionViewItem &amp;option,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="type">const</span> QModelIndex &amp;index)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    QComboBox *comboBox = <span class="keyword">new</span> <span class="built_in">QComboBox</span>(parent);</span><br><span class="line">    comboBox-&gt;<span class="built_in">addItems</span>(m_items);</span><br><span class="line">    <span class="keyword">return</span> comboBox;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ComboBoxDelegate::setEditorData</span><span class="params">(QWidget *editor, <span class="type">const</span> QModelIndex &amp;index)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    QString currentText = index.<span class="built_in">data</span>(Qt::DisplayRole).<span class="built_in">toString</span>();</span><br><span class="line">    QComboBox *comboBox = <span class="built_in">qobject_cast</span>&lt;QComboBox*&gt;(editor);</span><br><span class="line">    <span class="keyword">if</span> (comboBox) &#123;</span><br><span class="line">        <span class="type">int</span> idx = comboBox-&gt;<span class="built_in">findText</span>(currentText);</span><br><span class="line">        <span class="keyword">if</span> (idx &gt;= <span class="number">0</span>)</span><br><span class="line">            comboBox-&gt;<span class="built_in">setCurrentIndex</span>(idx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ComboBoxDelegate::setModelData</span><span class="params">(QWidget *editor, QAbstractItemModel *model,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="type">const</span> QModelIndex &amp;index)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    QComboBox *comboBox = <span class="built_in">qobject_cast</span>&lt;QComboBox*&gt;(editor);</span><br><span class="line">    <span class="keyword">if</span> (comboBox) &#123;</span><br><span class="line">        QString selected = comboBox-&gt;<span class="built_in">currentText</span>();</span><br><span class="line">        model-&gt;<span class="built_in">setData</span>(index, selected, Qt::EditRole);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-在视图中应用自定义委托-1"><a href="#2-在视图中应用自定义委托-1" class="headerlink" title="2. 在视图中应用自定义委托"></a>2. 在视图中应用自定义委托</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.cpp (续)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ComboBoxDelegate.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 之前的代码</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建模型</span></span><br><span class="line">    <span class="function">QStandardItemModel <span class="title">model</span><span class="params">(<span class="number">5</span>, <span class="number">2</span>)</span></span>; <span class="comment">// 5 行 2 列</span></span><br><span class="line">    model.<span class="built_in">setHorizontalHeaderLabels</span>(<span class="built_in">QStringList</span>() &lt;&lt; <span class="string">&quot;任务&quot;</span> &lt;&lt; <span class="string">&quot;状态&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填充模型数据</span></span><br><span class="line">    QStringList statuses = &#123;<span class="string">&quot;未开始&quot;</span>, <span class="string">&quot;进行中&quot;</span>, <span class="string">&quot;已完成&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> row = <span class="number">0</span>; row &lt; <span class="number">5</span>; ++row) &#123;</span><br><span class="line">        QStandardItem *taskItem = <span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="built_in">QString</span>(<span class="string">&quot;任务 %1&quot;</span>).<span class="built_in">arg</span>(row + <span class="number">1</span>));</span><br><span class="line">        QStandardItem *statusItem = <span class="keyword">new</span> <span class="built_in">QStandardItem</span>(statuses.<span class="built_in">at</span>(row % statuses.<span class="built_in">size</span>()));</span><br><span class="line">        model.<span class="built_in">setItem</span>(row, <span class="number">0</span>, taskItem);</span><br><span class="line">        model.<span class="built_in">setItem</span>(row, <span class="number">1</span>, statusItem);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建视图</span></span><br><span class="line">    QTableView tableView;</span><br><span class="line">    tableView.<span class="built_in">setModel</span>(&amp;model);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 应用自定义委托到第二列（状态列）</span></span><br><span class="line">    ComboBoxDelegate *comboDelegate = <span class="keyword">new</span> <span class="built_in">ComboBoxDelegate</span>(statuses, &amp;tableView);</span><br><span class="line">    tableView.<span class="built_in">setItemDelegateForColumn</span>(<span class="number">1</span>, comboDelegate);</span><br><span class="line"></span><br><span class="line">    tableView.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-运行效果-1"><a href="#3-运行效果-1" class="headerlink" title="3. 运行效果"></a>3. 运行效果</h4><p>运行上述代码后，<code>QTableView</code> 的第二列将显示任务的状态。用户可以点击任意单元格，弹出下拉菜单，选择“未开始”、“进行中”或“已完成”来修改任务状态。</p>
<h3 id="示例三：复选框委托"><a href="#示例三：复选框委托" class="headerlink" title="示例三：复选框委托"></a>示例三：复选框委托</h3><p>有时需要在视图中显示复选框，允许用户选择或取消选择某项。</p>
<h4 id="1-创建自定义委托类-2"><a href="#1-创建自定义委托类-2" class="headerlink" title="1. 创建自定义委托类"></a>1. 创建自定义委托类</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CheckBoxDelegate.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CHECKBOXDELEGATE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHECKBOXDELEGATE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QStyledItemDelegate&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CheckBoxDelegate</span> : <span class="keyword">public</span> QStyledItemDelegate &#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">CheckBoxDelegate</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写绘制方法</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">paint</span><span class="params">(QPainter *painter, <span class="type">const</span> QStyleOptionViewItem &amp;option,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">const</span> QModelIndex &amp;index)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写编辑控件创建方法</span></span><br><span class="line">    <span class="function">QWidget *<span class="title">createEditor</span><span class="params">(QWidget *parent, <span class="type">const</span> QStyleOptionViewItem &amp;option,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> QModelIndex &amp;index)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写设置编辑控件数据方法</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setEditorData</span><span class="params">(QWidget *editor, <span class="type">const</span> QModelIndex &amp;index)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写保存编辑控件数据方法</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setModelData</span><span class="params">(QWidget *editor, QAbstractItemModel *model,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="type">const</span> QModelIndex &amp;index)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写更新编辑控件几何位置方法</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">updateEditorGeometry</span><span class="params">(QWidget *editor, <span class="type">const</span> QStyleOptionViewItem &amp;option,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">const</span> QModelIndex &amp;index)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// CHECKBOXDELEGATE_H</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CheckBoxDelegate.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CheckBoxDelegate.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPainter&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QCheckBox&gt;</span></span></span><br><span class="line"></span><br><span class="line">CheckBoxDelegate::<span class="built_in">CheckBoxDelegate</span>(QObject *parent)</span><br><span class="line">    : <span class="built_in">QStyledItemDelegate</span>(parent) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CheckBoxDelegate::paint</span><span class="params">(QPainter *painter, <span class="type">const</span> QStyleOptionViewItem &amp;option,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">const</span> QModelIndex &amp;index)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> checked = index.<span class="built_in">data</span>(Qt::CheckStateRole).<span class="built_in">toBool</span>();</span><br><span class="line"></span><br><span class="line">    QStyleOptionButton checkboxOption;</span><br><span class="line">    checkboxOption.state |= QStyle::State_Enabled;</span><br><span class="line">    <span class="keyword">if</span> (checked)</span><br><span class="line">        checkboxOption.state |= QStyle::State_On;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        checkboxOption.state |= QStyle::State_Off;</span><br><span class="line">    checkboxOption.rect = option.rect.<span class="built_in">adjusted</span>(<span class="number">4</span>, <span class="number">4</span>, <span class="number">-4</span>, <span class="number">-4</span>);</span><br><span class="line"></span><br><span class="line">    QApplication::<span class="built_in">style</span>()-&gt;<span class="built_in">drawControl</span>(QStyle::CE_CheckBox, &amp;checkboxOption, painter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">QWidget *<span class="title">CheckBoxDelegate::createEditor</span><span class="params">(QWidget *parent, <span class="type">const</span> QStyleOptionViewItem &amp;option,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       <span class="type">const</span> QModelIndex &amp;index)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 不需要编辑控件，因为复选框直接点击即可</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CheckBoxDelegate::setEditorData</span><span class="params">(QWidget *editor, <span class="type">const</span> QModelIndex &amp;index)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 无需实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CheckBoxDelegate::setModelData</span><span class="params">(QWidget *editor, QAbstractItemModel *model,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="type">const</span> QModelIndex &amp;index)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 无需实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CheckBoxDelegate::updateEditorGeometry</span><span class="params">(QWidget *editor, <span class="type">const</span> QStyleOptionViewItem &amp;option,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           <span class="type">const</span> QModelIndex &amp;index)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 无需实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-在视图中应用自定义委托-2"><a href="#2-在视图中应用自定义委托-2" class="headerlink" title="2. 在视图中应用自定义委托"></a>2. 在视图中应用自定义委托</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.cpp (续)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CheckBoxDelegate.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 之前的代码</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建模型</span></span><br><span class="line">    <span class="function">QStandardItemModel <span class="title">model</span><span class="params">(<span class="number">5</span>, <span class="number">2</span>)</span></span>; <span class="comment">// 5 行 2 列</span></span><br><span class="line">    model.<span class="built_in">setHorizontalHeaderLabels</span>(<span class="built_in">QStringList</span>() &lt;&lt; <span class="string">&quot;任务&quot;</span> &lt;&lt; <span class="string">&quot;完成&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填充模型数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> row = <span class="number">0</span>; row &lt; <span class="number">5</span>; ++row) &#123;</span><br><span class="line">        QStandardItem *taskItem = <span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="built_in">QString</span>(<span class="string">&quot;任务 %1&quot;</span>).<span class="built_in">arg</span>(row + <span class="number">1</span>));</span><br><span class="line">        QStandardItem *doneItem = <span class="keyword">new</span> <span class="built_in">QStandardItem</span>();</span><br><span class="line">        doneItem-&gt;<span class="built_in">setCheckable</span>(<span class="literal">true</span>);</span><br><span class="line">        doneItem-&gt;<span class="built_in">setCheckState</span>((row % <span class="number">2</span> == <span class="number">0</span>) ? Qt::Checked : Qt::Unchecked);</span><br><span class="line">        model.<span class="built_in">setItem</span>(row, <span class="number">0</span>, taskItem);</span><br><span class="line">        model.<span class="built_in">setItem</span>(row, <span class="number">1</span>, doneItem);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建视图</span></span><br><span class="line">    QTableView tableView;</span><br><span class="line">    tableView.<span class="built_in">setModel</span>(&amp;model);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 应用自定义复选框委托到第二列（完成列）</span></span><br><span class="line">    CheckBoxDelegate *checkBoxDelegate = <span class="keyword">new</span> <span class="built_in">CheckBoxDelegate</span>(&amp;tableView);</span><br><span class="line">    tableView.<span class="built_in">setItemDelegateForColumn</span>(<span class="number">1</span>, checkBoxDelegate);</span><br><span class="line"></span><br><span class="line">    tableView.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-运行效果-2"><a href="#3-运行效果-2" class="headerlink" title="3. 运行效果"></a>3. 运行效果</h4><p>运行上述代码后，<code>QTableView</code> 的第二列将显示复选框，表示任务是否完成。用户可以直接点击复选框来切换状态。</p>
<h2 id="委托的高级用法"><a href="#委托的高级用法" class="headerlink" title="委托的高级用法"></a>委托的高级用法</h2><h3 id="多委托应用"><a href="#多委托应用" class="headerlink" title="多委托应用"></a>多委托应用</h3><p>在一个视图中，可以为不同的列或特定的单元格应用不同的委托，以满足不同的数据展示和编辑需求。</p>
<h4 id="示例：混合使用进度条和下拉菜单委托"><a href="#示例：混合使用进度条和下拉菜单委托" class="headerlink" title="示例：混合使用进度条和下拉菜单委托"></a>示例：混合使用进度条和下拉菜单委托</h4><p>假设一个 <code>QTableView</code> 包含任务名称、进度和状态三列，我们希望：</p>
<ul>
<li>第二列显示进度条。</li>
<li>第三列显示下拉菜单。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.cpp (续)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ProgressBarDelegate.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ComboBoxDelegate.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 之前的代码</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建模型</span></span><br><span class="line">    <span class="function">QStandardItemModel <span class="title">model</span><span class="params">(<span class="number">5</span>, <span class="number">3</span>)</span></span>; <span class="comment">// 5 行 3 列</span></span><br><span class="line">    model.<span class="built_in">setHorizontalHeaderLabels</span>(<span class="built_in">QStringList</span>() &lt;&lt; <span class="string">&quot;任务&quot;</span> &lt;&lt; <span class="string">&quot;进度&quot;</span> &lt;&lt; <span class="string">&quot;状态&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填充模型数据</span></span><br><span class="line">    QStringList statuses = &#123;<span class="string">&quot;未开始&quot;</span>, <span class="string">&quot;进行中&quot;</span>, <span class="string">&quot;已完成&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> row = <span class="number">0</span>; row &lt; <span class="number">5</span>; ++row) &#123;</span><br><span class="line">        QStandardItem *taskItem = <span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="built_in">QString</span>(<span class="string">&quot;任务 %1&quot;</span>).<span class="built_in">arg</span>(row + <span class="number">1</span>));</span><br><span class="line">        QStandardItem *progressItem = <span class="keyword">new</span> <span class="built_in">QStandardItem</span>(QString::<span class="built_in">number</span>((row + <span class="number">1</span>) * <span class="number">20</span>));</span><br><span class="line">        progressItem-&gt;<span class="built_in">setData</span>((row + <span class="number">1</span>) * <span class="number">20</span>, Qt::DisplayRole);</span><br><span class="line">        QStandardItem *statusItem = <span class="keyword">new</span> <span class="built_in">QStandardItem</span>(statuses.<span class="built_in">at</span>(row % statuses.<span class="built_in">size</span>()));</span><br><span class="line">        model.<span class="built_in">setItem</span>(row, <span class="number">0</span>, taskItem);</span><br><span class="line">        model.<span class="built_in">setItem</span>(row, <span class="number">1</span>, progressItem);</span><br><span class="line">        model.<span class="built_in">setItem</span>(row, <span class="number">2</span>, statusItem);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建视图</span></span><br><span class="line">    QTableView tableView;</span><br><span class="line">    tableView.<span class="built_in">setModel</span>(&amp;model);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 应用自定义委托到第二列（进度列）</span></span><br><span class="line">    ProgressBarDelegate *progressDelegate = <span class="keyword">new</span> <span class="built_in">ProgressBarDelegate</span>(&amp;tableView);</span><br><span class="line">    tableView.<span class="built_in">setItemDelegateForColumn</span>(<span class="number">1</span>, progressDelegate);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 应用自定义委托到第三列（状态列）</span></span><br><span class="line">    ComboBoxDelegate *comboDelegate = <span class="keyword">new</span> <span class="built_in">ComboBoxDelegate</span>(statuses, &amp;tableView);</span><br><span class="line">    tableView.<span class="built_in">setItemDelegateForColumn</span>(<span class="number">2</span>, comboDelegate);</span><br><span class="line"></span><br><span class="line">    tableView.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="委托与数据验证"><a href="#委托与数据验证" class="headerlink" title="委托与数据验证"></a>委托与数据验证</h3><p>在编辑数据时，委托不仅负责提供编辑控件，还可以进行数据验证。例如，在编辑数字时，可以限制输入范围或格式。</p>
<h4 id="示例：带有输入验证的委托"><a href="#示例：带有输入验证的委托" class="headerlink" title="示例：带有输入验证的委托"></a>示例：带有输入验证的委托</h4><p>假设我们需要编辑进度值时，确保输入的值在 0 到 100 之间。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ProgressBarDelegate.cpp (修改)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ProgressBarDelegate.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QSpinBox&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 之前的代码</span></span><br><span class="line"></span><br><span class="line"><span class="function">QWidget *<span class="title">ProgressBarDelegate::createEditor</span><span class="params">(QWidget *parent, <span class="type">const</span> QStyleOptionViewItem &amp;option,</span></span></span><br><span class="line"><span class="params"><span class="function">                                          <span class="type">const</span> QModelIndex &amp;index)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 QSpinBox 作为编辑控件</span></span><br><span class="line">    QSpinBox *editor = <span class="keyword">new</span> <span class="built_in">QSpinBox</span>(parent);</span><br><span class="line">    editor-&gt;<span class="built_in">setMinimum</span>(<span class="number">0</span>);</span><br><span class="line">    editor-&gt;<span class="built_in">setMaximum</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">return</span> editor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过使用 <code>QSpinBox</code>，用户只能输入 0 到 100 之间的整数，避免了无效输入。</p>
<h2 id="委托的性能优化"><a href="#委托的性能优化" class="headerlink" title="委托的性能优化"></a>委托的性能优化</h2><p>当视图中包含大量数据项时，委托的性能可能成为瓶颈。以下是一些优化建议：</p>
<ol>
<li><strong>避免复杂的绘制操作</strong>：在 <code>paint</code> 方法中尽量使用简单的绘制操作，避免耗时的计算或复杂的图形处理。</li>
<li><strong>缓存重复计算的值</strong>：如果某些计算可以复用，考虑将其缓存起来，减少重复计算。</li>
<li><strong>最小化委托的数量</strong>：尽量复用同一个委托实例，避免为每个单元格创建独立的委托。</li>
<li><strong>使用高效的数据结构</strong>：确保模型的数据结构高效，减少数据访问的时间。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>委托是 Qt 模型-视图架构中强大的组件，允许开发者高度定制数据在视图中的展示和编辑方式。通过继承 <code>QStyledItemDelegate</code>，可以轻松创建自定义委托，实现进度条、下拉菜单、复选框等多种复杂的界面元素。合理使用委托不仅可以提升用户体验，还能增强应用程序的灵活性和可维护性。在实际开发中，结合具体需求，灵活应用委托将极大地丰富 Qt 应用的界面表现力。</p>
]]></content>
  </entry>
</search>
