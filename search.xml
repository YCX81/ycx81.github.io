<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2023.07.25随笔</title>
    <url>/2023/07/25/2023-07-25%E9%9A%8F%E7%AC%94/</url>
    <content><![CDATA[<p><img src="/../images/IMG_0095.jpeg" alt="IMG_0095"><br>0x00 前言</p>
<p>今天总算是把博客搭建好了，其中遇到一堆奇怪的问题和各种各样的bug。。。(图为7.21大雨前的三公山)</p>
<span id="more"></span>

<p>最近面试的项目还不知道从何下手，每次准备去做的时候又想开摆，真是折磨啊，我发现我到现在写日记还是在纯记流水账哈哈哈哈哈哈</p>
]]></content>
      <categories>
        <category>随笔</category>
        <category>日记</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>2023.07.26随笔</title>
    <url>/2023/07/26/2023-07-26%E9%9A%8F%E7%AC%94/</url>
    <content><![CDATA[<p><img src="/../images/IMG_0155.jpeg" alt="IMG_0155"></p>
<p>0x00 前言</p>
<p>每天感觉浑身无力，做事没有干劲，犹如一具行尸走肉，这个榴莲披萨薄脆还挺好吃。</p>
<span id="more"></span>
]]></content>
      <categories>
        <category>随笔</category>
        <category>日记</category>
      </categories>
      <tags>
        <tag>吃</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis简易手册</title>
    <url>/2023/08/23/Redis%E7%AE%80%E6%98%93%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<p><img src="/../images/download.png" alt="download"></p>
<p>0x00 前言</p>
<p>近期在B站看到一个1小时教学Redis，全程没有废话，粗略过了一遍，并对其主要知识点进行总结。</p>
<p>【【GeekHour】一小时Redis教程-哔哩哔哩】 <a href="https://b23.tv/MzEWwWh">https://b23.tv/MzEWwWh</a></p>
<span id="more"></span>

<p>以下是一些常用的Redis命令，使用Markdown语法进行总结：</p>
<h3 id="连接与配置"><a href="#连接与配置" class="headerlink" title="连接与配置"></a>连接与配置</h3><ul>
<li>连接到Redis服务器：<code>redis-cli</code></li>
<li>显示Redis服务器信息：<code>INFO</code></li>
<li>查看配置文件的路径：<code>CONFIG GET dir</code></li>
<li>修改配置项：<code>CONFIG SET &lt;config-name&gt; &lt;value&gt;</code></li>
<li>查看Redis版本：<code>redis-server -v</code></li>
</ul>
<h3 id="键操作"><a href="#键操作" class="headerlink" title="键操作"></a>键操作</h3><ul>
<li>设置键值对：<code>SET &lt;key&gt; &lt;value&gt;</code></li>
<li>获取键对应的值：<code>GET &lt;key&gt;</code></li>
<li>删除键值对：<code>DEL &lt;key&gt;</code></li>
<li>检查键是否存在：<code>EXISTS &lt;key&gt;</code></li>
<li>设置键的过期时间（秒）：<code>EXPIRE &lt;key&gt; &lt;seconds&gt;</code></li>
<li>移除键的过期时间：<code>PERSIST &lt;key&gt;</code></li>
<li>查看键的剩余过期时间（秒）：<code>TTL &lt;key&gt;</code></li>
</ul>
<h3 id="列表操作"><a href="#列表操作" class="headerlink" title="列表操作"></a>列表操作</h3><ul>
<li>向列表头部添加元素：<code>LPUSH &lt;key&gt; &lt;value&gt;</code></li>
<li>向列表尾部添加元素：<code>RPUSH &lt;key&gt; &lt;value&gt;</code></li>
<li>获取列表长度：<code>LLEN &lt;key&gt;</code></li>
<li>获取列表指定范围的元素：<code>LRANGE &lt;key&gt; &lt;start&gt; &lt;end&gt;</code></li>
<li>弹出并返回列表头部元素：<code>LPOP &lt;key&gt;</code></li>
<li>弹出并返回列表尾部元素：<code>RPOP &lt;key&gt;</code></li>
</ul>
<h3 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a>集合操作</h3><ul>
<li>向集合添加一个元素：<code>SADD &lt;key&gt; &lt;member&gt;</code></li>
<li>获取集合的所有成员：<code>SMEMBERS &lt;key&gt;</code></li>
<li>检查元素是否是集合的成员：<code>SISMEMBER &lt;key&gt; &lt;member&gt;</code></li>
<li>移除集合中的一个元素：<code>SREM &lt;key&gt; &lt;member&gt;</code></li>
<li>计算集合的交集、并集或差集：<code>SINTER</code>, <code>SUNION</code>, <code>SDIFF</code></li>
</ul>
<h3 id="哈希操作"><a href="#哈希操作" class="headerlink" title="哈希操作"></a>哈希操作</h3><ul>
<li>设置哈希字段值：<code>HSET &lt;key&gt; &lt;field&gt; &lt;value&gt;</code></li>
<li>获取哈希字段值：<code>HGET &lt;key&gt; &lt;field&gt;</code></li>
<li>获取哈希所有字段和值：<code>HGETALL &lt;key&gt;</code></li>
<li>删除哈希字段：<code>HDEL &lt;key&gt; &lt;field&gt;</code></li>
<li>查看哈希字段数量：<code>HLEN &lt;key&gt;</code></li>
</ul>
<h3 id="有序集合操作"><a href="#有序集合操作" class="headerlink" title="有序集合操作"></a>有序集合操作</h3><ul>
<li>向有序集合添加成员及分数：<code>ZADD &lt;key&gt; &lt;score&gt; &lt;member&gt;</code></li>
<li>获取有序集合的成员列表：<code>ZRANGE &lt;key&gt; &lt;start&gt; &lt;end&gt;</code></li>
<li>根据分数范围获取有序集合的成员：<code>ZRANGEBYSCORE &lt;key&gt; &lt;min&gt; &lt;max&gt;</code></li>
<li>获取有序集合的成员数量：<code>ZCARD &lt;key&gt;</code></li>
<li>移除有序集合中的成员：<code>ZREM &lt;key&gt; &lt;member&gt;</code></li>
</ul>
<h3 id="发布与订阅"><a href="#发布与订阅" class="headerlink" title="发布与订阅"></a>发布与订阅</h3><ul>
<li>订阅频道：<code>SUBSCRIBE &lt;channel&gt;</code></li>
<li>取消订阅频道：<code>UNSUBSCRIBE &lt;channel&gt;</code></li>
<li>发布消息到频道：<code>PUBLISH &lt;channel&gt; &lt;message&gt;</code></li>
</ul>
<h3 id="排序和排名"><a href="#排序和排名" class="headerlink" title="排序和排名"></a>排序和排名</h3><ul>
<li>按分数升序排列有序集合的成员：<code>ZREVRANGE &lt;key&gt; &lt;start&gt; &lt;end&gt;</code></li>
<li>获取有序集合中成员的排名：<code>ZRANK &lt;key&gt; &lt;member&gt;</code></li>
<li>获取有序集合中成员的分数：<code>ZSCORE &lt;key&gt; &lt;member&gt;</code></li>
</ul>
<h3 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h3><ul>
<li>使用通配符查找键名：<code>KEYS &lt;pattern&gt;</code></li>
<li>批量删除符合条件的键：<code>DEL &lt;pattern&gt;</code></li>
<li>列出匹配的键名：<code>SCAN &lt;cursor&gt; MATCH &lt;pattern&gt; COUNT &lt;count&gt;</code></li>
</ul>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><ul>
<li>开启事务：<code>MULTI</code></li>
<li>执行事务：<code>EXEC</code></li>
<li>取消事务：<code>DISCARD</code></li>
</ul>
<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><ul>
<li>使用管道执行多个命令：可以通过一次网络往返执行多个命令以提高性能，使用<code>PIPELINE</code></li>
</ul>
<h3 id="信息统计"><a href="#信息统计" class="headerlink" title="信息统计"></a>信息统计</h3><ul>
<li>查看内存使用情况：<code>MEMORY STATS</code></li>
<li>查看服务器状态：<code>INFO SERVER</code></li>
<li>查看客户端列表：<code>CLIENT LIST</code></li>
</ul>
<h3 id="备份和恢复"><a href="#备份和恢复" class="headerlink" title="备份和恢复"></a>备份和恢复</h3><ul>
<li>创建数据快照：<code>SAVE</code></li>
<li>在后台创建数据快照：<code>BGSAVE</code></li>
<li>恢复数据：将快照文件复制到Redis数据目录并重启服务器</li>
</ul>
<h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><ul>
<li>设置访问密码：<code>CONFIG SET requirepass &lt;password&gt;</code></li>
<li>验证密码：<code>AUTH &lt;password&gt;</code></li>
</ul>
<h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><ul>
<li>创建Redis集群：使用Redis Cluster</li>
<li>查看集群节点信息：<code>CLUSTER NODES</code></li>
<li>手动切换主节点：<code>CLUSTER FAILOVER</code></li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li>发送一个即时命令到服务器以查看性能统计信息：<code>INFO COMMANDSTATS</code></li>
<li>监视键的变化：<code>MONITOR</code></li>
<li>配置Redis服务器以接受远程连接：修改<code>redis.conf</code>文件中的<code>bind</code>选项</li>
</ul>
<h3 id="在C-中使用Redis"><a href="#在C-中使用Redis" class="headerlink" title="在C++中使用Redis"></a>在C++中使用Redis</h3><p>在C++中使用Redis通常需要使用Redis C++客户端库，其中最常用的是hiredis和cpp_redis。以下是在C++中使用Redis的基本步骤以及一些常见操作：</p>
<p><strong>步骤1：安装Redis C++客户端库</strong></p>
<p>首先安装Redis C++客户端库，最常见的选择是hiredis和cpp_redis。您可以使用包管理器（如apt、brew、vcpkg）来安装这些库，或者从官方GitHub存储库手动构建它们。</p>
<p><strong>步骤2：包含头文件</strong></p>
<p>在您的C++代码中，包含适当的Redis客户端库头文件。例如使用cpp_redis则需要包含以下头文件：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cpp_redis/cpp_redis&gt;</span></span></span><br></pre></td></tr></table></figure>

<p><strong>步骤3：建立与Redis的连接</strong></p>
<p>在代码中，使用客户端库提供的函数来建立与Redis服务器的连接。这通常涉及创建一个客户端对象并配置连接参数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cpp_redis::client client;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置连接参数</span></span><br><span class="line">client.<span class="built_in">connect</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">6379</span>);</span><br></pre></td></tr></table></figure>

<p><strong>步骤4：执行Redis命令</strong></p>
<p>使用客户端库提供的函数执行Redis命令。以下是一些常见的示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置键值对</span></span><br><span class="line">client.<span class="built_in">set</span>(<span class="string">&quot;my_key&quot;</span>, <span class="string">&quot;my_value&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取键的值</span></span><br><span class="line">client.<span class="built_in">get</span>(<span class="string">&quot;my_key&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行哈希操作</span></span><br><span class="line">client.<span class="built_in">hset</span>(<span class="string">&quot;my_hash&quot;</span>, <span class="string">&quot;field1&quot;</span>, <span class="string">&quot;value1&quot;</span>);</span><br><span class="line">client.<span class="built_in">hget</span>(<span class="string">&quot;my_hash&quot;</span>, <span class="string">&quot;field1&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>步骤5：提交命令和处理响应</strong></p>
<p>提交Redis命令并处理响应。可以使用回调函数或阻塞方式等不同的方法来处理响应：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 提交命令</span></span><br><span class="line">client.<span class="built_in">sync_commit</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理响应（回调方式）</span></span><br><span class="line">client.<span class="built_in">get</span>(<span class="string">&quot;my_key&quot;</span>, [](cpp_redis::reply&amp; reply) &#123;</span><br><span class="line">    <span class="keyword">if</span> (reply.<span class="built_in">is_string</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; reply.<span class="built_in">as_string</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理响应（阻塞方式）</span></span><br><span class="line">cpp_redis::reply reply = client.<span class="built_in">sync_commit</span>();</span><br><span class="line"><span class="keyword">if</span> (reply.<span class="built_in">is_string</span>()) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; reply.<span class="built_in">as_string</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤6：关闭连接</strong></p>
<p>在使用完Redis之后，确保关闭与Redis服务器的连接以释放资源：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">client.<span class="built_in">disconnect</span>();</span><br></pre></td></tr></table></figure>

<p>要了解更多详细信息和示例，请查阅Redis C++客户端库的文档。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>知识手册</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo常用命令</title>
    <url>/2023/01/23/hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p><img src="/../images/download-2776003.png" alt="download-2776003"></p>
<h1 id="Hexo-常用命令手册"><a href="#Hexo-常用命令手册" class="headerlink" title="Hexo 常用命令手册"></a>Hexo 常用命令手册</h1><p>本功能手册提供了Hexo静态网站生成器的常用命令列表，以及它们的功能和用法说明。</p>
<span id="more"></span>

<h2 id="1-hexo-init-lt-folder-gt"><a href="#1-hexo-init-lt-folder-gt" class="headerlink" title="1. hexo init &lt;folder&gt;"></a>1. hexo init &lt;folder&gt;</h2><p><strong>功能：</strong> 初始化新的Hexo站点。</p>
<p><strong>用法：</strong> 初始化Hexo站点时，需指定一个文件夹名称作为参数。此命令会在指定文件夹内生成站点文件结构和配置。</p>
<h2 id="2-hexo-new-lt-title-gt"><a href="#2-hexo-new-lt-title-gt" class="headerlink" title="2. hexo new &lt;title&gt;"></a>2. hexo new &lt;title&gt;</h2><p><strong>功能：</strong> 创建新的博客文章。</p>
<p><strong>用法：</strong> 使用此命令创建博客文章，需提供文章标题作为参数。Hexo会自动生成对应的Markdown文件，供编写文章内容。</p>
<h2 id="3-hexo-generate-或-hexo-g"><a href="#3-hexo-generate-或-hexo-g" class="headerlink" title="3. hexo generate 或 hexo g"></a>3. hexo generate 或 hexo g</h2><p><strong>功能：</strong> 生成静态网站文件。</p>
<p><strong>用法：</strong> 使用此命令将source文件夹中的Markdown文件转化成HTML，生成静态页面。生成的文件存储在public文件夹中。</p>
<h2 id="4-hexo-server-或-hexo-s"><a href="#4-hexo-server-或-hexo-s" class="headerlink" title="4. hexo server 或 hexo s"></a>4. hexo server 或 hexo s</h2><p><strong>功能：</strong> 启动本地服务器，以便本地预览博客。</p>
<p><strong>用法：</strong> 默认情况下，此命令在本地启动服务器，可通过浏览器访问<a href="http://localhost:4000查看生成的网站。">http://localhost:4000查看生成的网站。</a></p>
<h2 id="5-hexo-deploy"><a href="#5-hexo-deploy" class="headerlink" title="5. hexo deploy"></a>5. hexo deploy</h2><p><strong>功能：</strong> 部署生成的静态网站到托管平台。</p>
<p><strong>用法：</strong> 在Hexo配置文件中设置部署信息，使用此命令将网站内容上传至托管平台，如GitHub Pages或自定义服务器。</p>
<h2 id="6-hexo-clean"><a href="#6-hexo-clean" class="headerlink" title="6. hexo clean"></a>6. hexo clean</h2><p><strong>功能：</strong> 清除Hexo生成的临时文件和缓存。</p>
<p><strong>用法：</strong> 通常用于解决问题或重新生成整个网站。清理后，可再次运行<code>hexo generate</code>重新生成网站。</p>
<h2 id="7-hexo-new-page-lt-name-gt"><a href="#7-hexo-new-page-lt-name-gt" class="headerlink" title="7. hexo new page &lt;name&gt;"></a>7. hexo new page &lt;name&gt;</h2><p><strong>功能：</strong> 创建新的页面。</p>
<p><strong>用法：</strong> 类似于创建文章，但页面通常用于静态内容，如“关于”或“联系”页面。它们存储在<code>source/_pages</code>目录中。</p>
<h2 id="8-hexo-list"><a href="#8-hexo-list" class="headerlink" title="8. hexo list"></a>8. hexo list</h2><p><strong>功能：</strong> 列出所有已创建的文章和页面。</p>
<p><strong>用法：</strong> 可查看当前站点的所有内容。</p>
<h2 id="9-hexo-publish-lt-title-gt"><a href="#9-hexo-publish-lt-title-gt" class="headerlink" title="9. hexo publish &lt;title&gt;"></a>9. hexo publish &lt;title&gt;</h2><p><strong>功能：</strong> 发布一篇草稿。</p>
<p><strong>用法：</strong> 提供文章标题作为参数，Hexo将草稿文件从<code>source/_drafts</code>移动到<code>source/_posts</code>目录，发布文章。</p>
<h2 id="10-hexo-draft-lt-title-gt"><a href="#10-hexo-draft-lt-title-gt" class="headerlink" title="10. hexo draft &lt;title&gt;"></a>10. hexo draft &lt;title&gt;</h2><p><strong>功能：</strong> 创建新的草稿文章。</p>
<p><strong>用法：</strong> 草稿是未发布的文章，存储在<code>source/_drafts</code>目录中，以后可使用<code>hexo publish</code>命令发布。</p>
<h2 id="11-hexo-new-draft-lt-title-gt"><a href="#11-hexo-new-draft-lt-title-gt" class="headerlink" title="11. hexo new draft &lt;title&gt;"></a>11. hexo new draft &lt;title&gt;</h2><p><strong>功能：</strong> 创建并同时发布一篇草稿文章。</p>
<p><strong>用法：</strong> 与上述命令不同，此命令创建文章后将其移动到<code>source/_posts</code>目录，即发布状态。</p>
<h2 id="12-hexo-server-d-或-hexo-s-d"><a href="#12-hexo-server-d-或-hexo-s-d" class="headerlink" title="12. hexo server -d 或 hexo s -d"></a>12. hexo server -d 或 hexo s -d</h2><p><strong>功能：</strong> 启动本地服务器并监听文件变化。</p>
<p><strong>用法：</strong> 编辑博客内容时，Hexo检测文件更改，并自动重新生成网站，可实时预览修改。</p>
<h2 id="13-hexo-generate-–watch-或-hexo-g-–watch"><a href="#13-hexo-generate-–watch-或-hexo-g-–watch" class="headerlink" title="13. hexo generate –watch 或 hexo g –watch"></a>13. hexo generate –watch 或 hexo g –watch</h2><p><strong>功能：</strong> 生成静态网站并监听文件变化。</p>
<p><strong>用法：</strong> 类似于上一个命令，但只生成网站，不启动服务器。适用于生成后手动刷新预览的情况。</p>
<p>这些是Hexo静态网站生成器的常用命令，用于创建、管理和部署静态博客网站。根据需求，可进一步探索Hexo文档以获取关于配置和高级命令的信息。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>知识手册</tag>
      </tags>
  </entry>
  <entry>
    <title>简易网盘项目00</title>
    <url>/2023/07/27/%E7%AE%80%E6%98%93%E7%BD%91%E7%9B%98%E9%A1%B9%E7%9B%AE00/</url>
    <content><![CDATA[<p><img src="/../images/v2-770576ab3a108d44200a78910080cc5e_1440w.jpg" alt="v2-770576ab3a108d44200a78910080cc5e_1440w"></p>
<p>0x00 前言</p>
<p>此项目准备用于应付近期的面试，作为一种简易的Web Server项目，可能需要4-5期迭代开发。本项目将尽可能还原市面上主流的网盘所具有的功能。</p>
<span id="more"></span>

<h2 id="0x01-第一期开发总纲"><a href="#0x01-第一期开发总纲" class="headerlink" title="0x01 第一期开发总纲"></a>0x01 第一期开发总纲</h2><p>第一期主要需要实现的功能有服务器端实现命令解析，可能涉及的命令包括：</p>
<ol>
<li>cd							    进入服务器对应目录</li>
<li>ls				  			   列出当前路径下的所有文件</li>
<li>pwd					   	  显示当前所处路径</li>
<li>puts filename		     上传本地文件到服务器</li>
<li>get filename				下载服务器文件到本地</li>
<li>rm filename			   删除服务器上的某文件</li>
<li>mkdir dirname		   创建文件夹</li>
<li>非法命令            			不响应</li>
</ol>
<h2 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h2><h2 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h2><h2 id="0x04"><a href="#0x04" class="headerlink" title="0x04"></a>0x04</h2>]]></content>
  </entry>
  <entry>
    <title>为什么是127.0.0.1</title>
    <url>/2022/10/12/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF127-0-0-1/</url>
    <content><![CDATA[<p>0x00 前言</p>
<p>刚学习网络时，总看到书上配置的ip地址总是127.0.0.1，遂查找网络进行扫盲。</p>
<span id="more"></span>

<p>IP地址 127.0.0.1 是一个特殊的地址，通常被称为”本地主机”或”回环地址”（Loopback Address）。这个地址是为了在计算机上进行自我测试和本地通信而设计的，具有以下重要特点：</p>
<ol>
<li><p><strong>只在本地使用</strong>：IP地址 127.0.0.1 只能在同一台计算机内部使用，不能被用于跨计算机的网络通信。这是因为它被用于回送到计算机本身的网络数据。</p>
</li>
<li><p><strong>自我测试</strong>：开发人员可以在本地主机上测试网络应用程序，而无需连接到外部网络或依赖外部服务器。这有助于确保应用程序在没有网络连接的情况下也能正常工作。</p>
</li>
<li><p><strong>无需网络硬件</strong>：使用回环地址，您可以在没有网络连接的情况下测试应用程序，因为数据不会离开计算机。</p>
</li>
<li><p><strong>简单的配置</strong>：回环地址不需要任何特殊配置或硬件支持。它通常在任何支持TCP&#x2F;IP协议的计算机上都可用。</p>
</li>
<li><p><strong>标准化</strong>：回环地址 127.0.0.1 是一个标准化的IPv4回环地址。IPv6的回环地址是 “::1”。</p>
</li>
<li><p><strong>用途广泛</strong>：回环地址在本地开发、测试网络应用程序、诊断网络问题等方面被广泛使用。它也在系统中的某些本地服务中使用，以便这些服务可以在不涉及网络的情况下与其他应用程序通信。</p>
</li>
</ol>
<p>总之，IP地址 127.0.0.1 是为了在计算机上进行本地测试和通信而设计的，它允许应用程序在不需要外部网络连接的情况下进行自我测试和开发。它在开发和调试网络应用程序时非常有用。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>C++面试题总结</title>
    <url>/2023/05/08/C-%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93%EF%BC%88%E4%B9%B1%E5%BA%8F%E7%89%88%EF%BC%89/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>平时积累的面试题，还没归纳整理，先弄个乱序版，后面有时间再重新按知识点排序一下</p>
<span id="more"></span>

<h3 id="什么是C语言？它有哪些主要特点？"><a href="#什么是C语言？它有哪些主要特点？" class="headerlink" title="什么是C语言？它有哪些主要特点？"></a>什么是C语言？它有哪些主要特点？</h3><p><strong>回答：</strong> C语言是一种通用的、过程化的编程语言。它的主要特点包括：</p>
<ul>
<li><strong>简洁性：</strong> C语言的语法相对简单，易于学习和理解。</li>
<li><strong>可移植性：</strong> C代码可以在不同的计算机平台上编译和运行，只需进行少量修改。</li>
<li><strong>高性能：</strong> C语言代码通常具有很高的执行速度，因为它接近底层硬件。</li>
<li><strong>强大的标准库：</strong> C标准库提供了许多常用的函数，用于文件操作、内存管理、输入&#x2F;输出等。</li>
<li><strong>指针支持：</strong> C语言支持指针，允许直接访问内存地址，因此具有更高的灵活性。</li>
</ul>
<h3 id="什么是C-语言？它与C语言有什么不同？"><a href="#什么是C-语言？它与C语言有什么不同？" class="headerlink" title="什么是C++语言？它与C语言有什么不同？"></a>什么是C++语言？它与C语言有什么不同？</h3><p><strong>回答：</strong> C++是一种多范式编程语言，它是C语言的扩展，包括了面向对象编程（OOP）的特性。与C语言相比，C++的主要不同之处包括：</p>
<ul>
<li><strong>面向对象编程：</strong> C++支持类和对象，允许使用封装、继承和多态等OOP特性。</li>
<li><strong>标准模板库（STL）：</strong> C++提供了STL，包括容器、算法和迭代器等，使代码更易于编写和维护。</li>
<li><strong>异常处理：</strong> C++支持异常处理，可以捕获和处理运行时错误。</li>
<li><strong>函数重载：</strong> C++允许定义多个同名函数，但参数类型或数量不同，称为函数重载。</li>
<li><strong>命名空间：</strong> C++引入了命名空间概念，用于组织和管理代码。</li>
</ul>
<h3 id="什么是指针？如何使用指针？"><a href="#什么是指针？如何使用指针？" class="headerlink" title="什么是指针？如何使用指针？"></a>什么是指针？如何使用指针？</h3><p><strong>回答：</strong> 指针是一种用于存储变量地址的数据类型。指针通常用于以下操作：</p>
<ul>
<li><p><strong>声明指针：</strong> 使用<code>*</code>运算符声明指针变量，例如：<code>int *ptr;</code>声明一个指向整数的指针。</p>
</li>
<li><p><strong>初始化指针：</strong> 将指针指向特定变量的地址，例如：<code>ptr = &amp;myVar;</code>将指针<code>ptr</code>指向<code>myVar</code>的地址。</p>
</li>
<li><p><strong>访问变量：</strong> 使用指针间接访问变量的值，例如：<code>int x = *ptr;</code>将指针<code>ptr</code>指向的值赋给<code>x</code>。</p>
</li>
<li><p><strong>指针算术：</strong> 指针支持算术运算，例如：<code>ptr++</code>将指针向后移动一个位置。</p>
</li>
<li><p><strong>空指针：</strong> 使用<code>nullptr</code>（C++11及以上）或<code>NULL</code>（旧标准）表示空指针，即不指向任何变量的指针。</p>
</li>
</ul>
<p>指针是C&#x2F;C++中强大但需要谨慎使用的特性，因为它们可以直接操作内存。</p>
<h3 id="什么是动态内存分配？如何在C-x2F-C-中执行动态内存分配和释放？"><a href="#什么是动态内存分配？如何在C-x2F-C-中执行动态内存分配和释放？" class="headerlink" title="什么是动态内存分配？如何在C&#x2F;C++中执行动态内存分配和释放？"></a>什么是动态内存分配？如何在C&#x2F;C++中执行动态内存分配和释放？</h3><p><strong>回答：</strong> 动态内存分配是在程序运行时分配内存，以存储数据结构，而不是在编译时分配。在C&#x2F;C++中，可以使用以下函数执行动态内存分配和释放：</p>
<ul>
<li><p><strong>C中的动态内存分配：</strong></p>
<ul>
<li><code>malloc(size_t size)</code>：分配指定大小的内存块，并返回指向首字节的指针。</li>
<li><code>calloc(size_t num, size_t size)</code>：分配指定数量和大小的内存块，初始化为零。</li>
<li><code>realloc(void* ptr, size_t new_size)</code>：重新分配已分配内存的大小。</li>
<li><code>free(void* ptr)</code>：释放先前分配的内存。</li>
</ul>
</li>
<li><p><strong>C++中的动态内存分配：</strong></p>
<ul>
<li><code>new type</code>：分配指定类型的内存，返回指向该类型的指针。</li>
<li><code>new type[n]</code>：分配数组类型的内存。</li>
<li><code>delete ptr</code>：释放由<code>new</code>分配的内存。</li>
<li><code>delete[] ptr</code>：释放由<code>new[]</code>分配的内存。</li>
</ul>
</li>
</ul>
<p>必须谨慎使用动态内存分配，以避免内存泄漏和悬挂指针。</p>
<h3 id="什么是类和对象？如何在C-中定义类和创建对象？"><a href="#什么是类和对象？如何在C-中定义类和创建对象？" class="headerlink" title="什么是类和对象？如何在C++中定义类和创建对象？"></a>什么是类和对象？如何在C++中定义类和创建对象？</h3><p><strong>回答：</strong> 类是C++中面向对象编程的基本概念，它是一种用户自定义的数据类型，用于封装数据和操作。对象是类的实例，它是具体的数据结构，可以执行类中定义的操作。</p>
<p>在C++中定义类和创建对象的步骤如下：</p>
<p>定义类：使用<code>class</code>关键字定义类，声明类的数据成员和成员函数。例如：</p>
   <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> myVar;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>创建对象：在程序中使用类名创建对象，例如：</p>
   <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">MyClass obj;</span><br></pre></td></tr></table></figure>

<p>访问对象成员：使用点运算符(<code>.</code>)访问对象的数据成员和成员函数，例如：</p>
   <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">obj.myVar = <span class="number">42</span>;</span><br><span class="line">obj.<span class="built_in">myFunction</span>();</span><br></pre></td></tr></table></figure>

<p>类和对象允许将相关数据和操作封装在一起，提高了代码的可维护性和可重用性。</p>
<h3 id="什么是构造函数和析构函数？它们有什么作用？"><a href="#什么是构造函数和析构函数？它们有什么作用？" class="headerlink" title="什么是构造函数和析构函数？它们有什么作用？"></a>什么是构造函数和析构函数？它们有什么作用？</h3><p><strong>回答：</strong> 构造函数和析构函数是C++类的特殊成员函数，用于对象的初始化和清理。</p>
<ul>
<li><p><strong>构造函数（Constructor）：</strong> 构造函数在对象创建时自动调用，用于初始化对象的数据成员。构造函数的名称与类名相同，没有返回类型。</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() &#123;</span><br><span class="line">        <span class="comment">// 构造函数的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>析构函数（Destructor）：</strong> 析构函数在对象销毁时自动调用，用于清理资源。析构函数的名称与类名相同，前面加上<code>~</code>。</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123;</span><br><span class="line">        <span class="comment">// 析构函数的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>构造函数确保对象在使用前处于一种有效状态，而析构函数可用于释放对象使用的资源，如内存或打开的文件。</p>
<h3 id="什么是继承？如何在C-中实现继承？"><a href="#什么是继承？如何在C-中实现继承？" class="headerlink" title="什么是继承？如何在C++中实现继承？"></a>什么是继承？如何在C++中实现继承？</h3><p><strong>回答：</strong> 继承是面向对象编程中的一个重要概念，它允许创建一个新类（子类或派生类），以重用现有类（基类或父类）的属性和方法。在C++中，可以使用以下方式实现继承：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ParentClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> parentVar;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">parentFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 父类的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChildClass</span> : <span class="keyword">public</span> ParentClass &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> childVar;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">childFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 子类的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>ChildClass</code>继承了<code>ParentClass</code>，子类拥有父类的数据成员和方法。</p>
</li>
<li><p><code>public</code>关键字表示继承的访问权限，<code>public</code>表示子类可以访问父类的公有成员。</p>
</li>
</ul>
<p>继承允许代码重用、扩展现有类的功能，以及创建层次化的类结构。</p>
<h3 id="什么是多态性（Polymorphism）？如何在C-中实现多态性？"><a href="#什么是多态性（Polymorphism）？如何在C-中实现多态性？" class="headerlink" title="什么是多态性（Polymorphism）？如何在C++中实现多态性？"></a>什么是多态性（Polymorphism）？如何在C++中实现多态性？</h3><p><strong>回答：</strong> 多态性是面向对象编程的一个特性，它允许不同对象对相同的方法产生不同的行为。在C++中，多态性可以通过函数重载和虚函数实现。</p>
<ul>
<li><p><strong>函数重载：</strong> 函数重载允许在同一个类中定义多个同名函数，但参数类型或数量不同。编译器根据调用时的参数类型来选择正确的函数。</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyMath</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">add</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>虚函数和运行时多态性：</strong> 虚函数是基类中声明为<code>virtual</code>的成员函数。子类可以重写（覆盖）基类的虚函数，并在运行时调用相应的子类版本。</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 基类的虚函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 子类的虚函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>多态性允许以通用的方式操作对象，而不必关心其具体类型。这提高了代码的灵活性和可扩展性。</p>
<h3 id="什么是模板（Template）？如何在C-中使用模板？"><a href="#什么是模板（Template）？如何在C-中使用模板？" class="headerlink" title="什么是模板（Template）？如何在C++中使用模板？"></a>什么是模板（Template）？如何在C++中使用模板？</h3><p><strong>回答：</strong> 模板是C++中一种通用编程工具，允许编写通用代码，适用于不同的数据类型。C++中有两种主要类型的模板：</p>
<ul>
<li><p><strong>函数模板：</strong> 允许编写通用函数，可以适用于不同类型的参数。</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>类模板：</strong> 允许编写通用类，可以适用于不同类型的成员。</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyContainer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T value;</span><br><span class="line">    <span class="built_in">MyContainer</span>(T val) : <span class="built_in">value</span>(val) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>模板通过参数化类型来实现通用性，使得代码更具通用性和可重用性。</p>
<h3 id="什么是RAII（资源获取即初始化）？它在C-中有什么作用？"><a href="#什么是RAII（资源获取即初始化）？它在C-中有什么作用？" class="headerlink" title="什么是RAII（资源获取即初始化）？它在C++中有什么作用？"></a>什么是RAII（资源获取即初始化）？它在C++中有什么作用？</h3><p><strong>回答：</strong> RAII是一种C++编程惯例，它强调资源管理与对象生命周期的绑定。RAII的核心思想是，资源的获取应该在对象构造期间进行，而释放应该在对象析构期间进行。这可以确保资源在任何情况下都会得到正确释放，以避免资源泄漏。</p>
<p>RAII最常见的用法之一是使用析构函数来释放动态分配的内存。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyResource</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyResource</span>() &#123;</span><br><span class="line">        <span class="comment">// 获取资源的操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">MyResource</span>() &#123;</span><br><span class="line">        <span class="comment">// 释放资源的操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用RAII，可以确保在对象离开作用域时资源被正确释放，即使发生异常或提前退出函数也可以。这种技术还可用于管理文件句柄、互斥锁等资源。</p>
<h3 id="什么是指针和引用的区别？在什么情况下应该使用哪个？"><a href="#什么是指针和引用的区别？在什么情况下应该使用哪个？" class="headerlink" title="什么是指针和引用的区别？在什么情况下应该使用哪个？"></a>什么是指针和引用的区别？在什么情况下应该使用哪个？</h3><p><strong>回答：</strong> 指针和引用都用于处理变量的间接访问，但它们有一些重要的区别：</p>
<ul>
<li><p><strong>指针（Pointer）：</strong></p>
<ul>
<li>指针是一个变量，其值是另一个变量的地址。</li>
<li>指针可以重新分配给不同的变量，因此它是可变的。</li>
<li>指针需要显式解引用才能访问存储在地址中的值。</li>
<li>指针可以为空（null）。</li>
<li>指针通常用于动态内存分配、数据结构和在函数中传递参数时。</li>
</ul>
</li>
<li><p><strong>引用（Reference）：</strong></p>
<ul>
<li>引用是一个别名，它引用了另一个变量。</li>
<li>引用在创建后不能重新绑定到其他变量，因此它是不可变的。</li>
<li>引用不需要显式解引用，因为它本身就是所引用变量的别名。</li>
<li>引用不能为空，它必须引用一个已存在的变量。</li>
<li>引用通常用于函数参数、返回值和避免复制大对象的开销。</li>
</ul>
</li>
</ul>
<p>在选择使用指针还是引用时，应考虑以下因素：</p>
<ul>
<li>如果需要能够重新分配引用或者引用为空，应使用指针。</li>
<li>如果不需要重新分配引用，并且要避免复制大对象的开销，应使用引用。</li>
<li>对于函数参数，如果不需要修改传递的值，通常使用引用或者常量引用（<code>const</code>引用）更安全，因为它们不会改变原始值。</li>
</ul>
<h3 id="什么是头文件（Header-File）？为什么在C-x2F-C-中使用头文件？"><a href="#什么是头文件（Header-File）？为什么在C-x2F-C-中使用头文件？" class="headerlink" title="什么是头文件（Header File）？为什么在C&#x2F;C++中使用头文件？"></a>什么是头文件（Header File）？为什么在C&#x2F;C++中使用头文件？</h3><p><strong>回答：</strong> 头文件是包含C&#x2F;C++程序中声明和定义的信息的文件，通常具有<code>.h</code>（C）或<code>.hpp</code>（C++）的扩展名。头文件的主要作用是：</p>
<ul>
<li><p><strong>分离接口和实现：</strong> 头文件包含函数和类的声明，但通常不包含实际的函数或类的实现。这有助于分离接口定义（头文件）和实现（源文件），以便于代码组织和维护。</p>
</li>
<li><p><strong>重复使用代码：</strong> 头文件允许在多个源文件中共享相同的函数和类声明，以便重复使用代码。</p>
</li>
<li><p><strong>编译优化：</strong> 使用头文件可以提供编译器优化的机会，因为它可以在编译不同源文件之前查看头文件的内容。</p>
</li>
<li><p><strong>编译检查：</strong> 头文件中的声明允许编译器进行类型检查，以捕获潜在的错误。</p>
</li>
</ul>
<p>通常，头文件包含函数原型、类声明、宏定义、常量和全局变量的声明。源文件（<code>.c</code>或<code>.cpp</code>）包含函数和类的实现。</p>
<h3 id="什么是内联函数（Inline-Function）？如何定义内联函数？"><a href="#什么是内联函数（Inline-Function）？如何定义内联函数？" class="headerlink" title="什么是内联函数（Inline Function）？如何定义内联函数？"></a>什么是内联函数（Inline Function）？如何定义内联函数？</h3><p><strong>回答：</strong> 内联函数是C&#x2F;C++中的一种编译器指示，用于请求将函数的代码嵌入到函数调用的地方，而不是通过函数调用的方式执行它。内联函数通常用于小型函数，以提高执行效率，因为函数调用会涉及额外的开销。</p>
<p>在C++中，可以通过在函数声明前加上<code>inline</code>关键字来定义内联函数，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内联函数的优点包括：</p>
<ul>
<li>减少了函数调用的开销，因为代码直接嵌入到调用处。</li>
<li>可以提高程序的性能，特别是对于频繁调用的小型函数。</li>
<li>有助于减小可执行文件的大小。</li>
</ul>
<p>然而，内联函数的使用应谨慎，因为过多的内联函数可能会导致可执行文件变得庞大。编译器通常会根据函数的大小和复杂性来决定是否将其内联。</p>
<h3 id="什么是多线程？如何在C-x2F-C-中创建和管理多线程？"><a href="#什么是多线程？如何在C-x2F-C-中创建和管理多线程？" class="headerlink" title="什么是多线程？如何在C&#x2F;C++中创建和管理多线程？"></a>什么是多线程？如何在C&#x2F;C++中创建和管理多线程？</h3><p><strong>回答：</strong> 多线程是一种并发编程技术，允许程序同时执行多个线程，每个线程都有自己的执行流和局部状态。多线程可以提高程序的性能和响应性，特别是在多核处理器上。</p>
<p>在C&#x2F;C++中，可以使用以下库来创建和管理多线程：</p>
<ul>
<li><p><strong>C语言中的线程（pthread）：</strong> 使用POSIX线程库可以在C中创建多线程。示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">thread_function</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="comment">// 线程函数的代码</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> thread;</span><br><span class="line">    pthread_create(&amp;thread, <span class="literal">NULL</span>, thread_function, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(thread, <span class="literal">NULL</span>); <span class="comment">// 等待线程结束</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>C++标准库中的线程：</strong> C++11引入了<code>std::thread</code>，允许在C++中创建多线程。示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 线程函数的代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">thread1</span><span class="params">(thread_function)</span></span>;</span><br><span class="line">    thread1.<span class="built_in">join</span>(); <span class="comment">// 等待线程结束</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>多线程编程需要谨慎处理共享资源的同步和互斥问题，以避免竞态条件和死锁等问题。</p>
<h3 id="什么是异常处理？在C-中如何处理异常？"><a href="#什么是异常处理？在C-中如何处理异常？" class="headerlink" title="什么是异常处理？在C++中如何处理异常？"></a>什么是异常处理？在C++中如何处理异常？</h3><p><strong>回答：</strong> 异常处理</p>
<p>是一种在程序运行时检测和响应错误的机制，以避免程序崩溃或产生不可预测的行为。在C++中，异常处理使用<code>try</code>、<code>catch</code>和<code>throw</code>关键字来实现。</p>
<ul>
<li><code>try</code>块用于包装可能抛出异常的代码块。</li>
<li><code>catch</code>块用于捕获和处理异常。可以有多个<code>catch</code>块，每个块可以处理不同类型的异常。</li>
<li><code>throw</code>语句用于抛出异常，可以抛出任何类型的异常。</li>
</ul>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Divide by zero&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">int</span> result = <span class="built_in">divide</span>(<span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>异常处理允许程序在遇到错误时进行安全退出或执行恢复操作。在设计函数时，应该考虑可能抛出的异常类型，并提供适当的异常处理机制。</p>
<h3 id="什么是析构函数（Destructor）？为什么它重要？"><a href="#什么是析构函数（Destructor）？为什么它重要？" class="headerlink" title="什么是析构函数（Destructor）？为什么它重要？"></a>什么是析构函数（Destructor）？为什么它重要？</h3><p><strong>回答：</strong> 析构函数是C++类的特殊成员函数，用于对象的清理和资源释放。析构函数的名称与类名相同，前面加上<code>~</code>符号。</p>
<p>析构函数在以下情况下重要：</p>
<ul>
<li><p><strong>资源释放：</strong> 析构函数用于释放对象在其生命周期中分配的资源，如内存、文件句柄、数据库连接等。这有助于避免资源泄漏。</p>
</li>
<li><p><strong>对象生命周期控制：</strong> 析构函数确定了对象在销毁时应采取的行动，例如关闭文件或释放锁定。</p>
</li>
<li><p><strong>异常处理：</strong> 析构函数可以用于处理对象生命周期中的异常情况，确保资源在异常时得到释放。</p>
</li>
<li><p><strong>子类析构函数：</strong> 在继承中，基类的析构函数通常是虚的，以确保在销毁子类对象时正确调用基类析构函数，从而实现多态的析构。</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() &#123;</span><br><span class="line">        <span class="comment">// 构造函数的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123;</span><br><span class="line">        <span class="comment">// 析构函数的代码，用于释放资源</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>确保在需要时正确实现析构函数，以避免资源泄漏和不稳定的程序行为。</p>
<h3 id="什么是预处理器（Preprocessor）？它在C-x2F-C-中有什么作用？"><a href="#什么是预处理器（Preprocessor）？它在C-x2F-C-中有什么作用？" class="headerlink" title="什么是预处理器（Preprocessor）？它在C&#x2F;C++中有什么作用？"></a>什么是预处理器（Preprocessor）？它在C&#x2F;C++中有什么作用？</h3><p><strong>回答：</strong> 预处理器是C&#x2F;C++编译过程中的一个独立阶段，用于在实际编译之前处理源代码。预处理器的主要作用包括：</p>
<ul>
<li><p><strong>宏替换：</strong> 预处理器可以替换源代码中的宏定义，例如使用<code>#define</code>定义的宏常量或宏函数。</p>
</li>
<li><p><strong>文件包含：</strong> 预处理器使用<code>#include</code>指令将其他文件的内容插入源文件中，允许代码的模块化组织。</p>
</li>
<li><p><strong>条件编译：</strong> 预处理器使用条件编译指令，如<code>#ifdef</code>和<code>#ifndef</code>，可以根据条件选择性地包含或排除代码块。</p>
</li>
<li><p><strong>注释删除：</strong> 预处理器删除源代码中的注释，以减小编译后的可执行文件的大小。</p>
</li>
<li><p><strong>其他：</strong> 预处理器还支持其他功能，如条件编译、宏展开等。</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_VALUE 100 <span class="comment">// 宏定义</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  <span class="comment">// 文件包含</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">    <span class="comment">// 调试代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> value = MAX_VALUE; <span class="comment">// 宏替换</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>预处理器通过生成经过处理的源代码，然后将其传递给编译器进行编译，起到了代码预处理和条件编译的作用。</p>
<h3 id="什么是静态链接（Static-Linking）和动态链接（Dynamic-Linking）？它们有什么区别？"><a href="#什么是静态链接（Static-Linking）和动态链接（Dynamic-Linking）？它们有什么区别？" class="headerlink" title="什么是静态链接（Static Linking）和动态链接（Dynamic Linking）？它们有什么区别？"></a>什么是静态链接（Static Linking）和动态链接（Dynamic Linking）？它们有什么区别？</h3><p><strong>回答：</strong> 静态链接和动态链接是用于将程序模块（如库和函数）与应用程序代码组合在一起的两种不同方法。</p>
<ul>
<li><p><strong>静态链接：</strong></p>
<ul>
<li>在静态链接中，编译器将所有需要的库和函数的代码复制到最终的可执行文件中。</li>
<li>可执行文件独立于外部库，无需依赖外部库的存在。</li>
<li>可执行文件较大，因为它包含了所有必要的代码。</li>
<li>静态链接的程序在运行时不需要外部库文件，因此更易于分发和部署。</li>
</ul>
</li>
<li><p><strong>动态链接：</strong></p>
<ul>
<li>在动态链接中，应用程序在运行时加载所需的库和函数。</li>
<li>可执行文件较小，因为它只包含链接到库的引用。</li>
<li>库文件（如DLL或共享对象）必须在运行时存在，否则程序将无法执行。</li>
<li>动态链接减小了可执行文件的大小，并允许库的更新和共享。</li>
</ul>
</li>
</ul>
<p>区别：</p>
<ul>
<li><strong>可执行文件大小：</strong> 静态链接生成较大的可执行文件，而动态链接生成较小的可执行文件。</li>
<li><strong>部署和更新：</strong> 静态链接程序更容易部署，因为它不需要外部库文件，但更新时需要重新编译。动态链接程序更容易更新，但需要确保所需的库文件可用。</li>
<li><strong>性能：</strong> 通常情况下，静态链接的性能</li>
</ul>
<p>略高于动态链接，因为所有代码都包含在可执行文件中，无需运行时加载。</p>
<p>选择静态链接或动态链接取决于项目的需求和目标。一些操作系统和开发环境支持同时使用两者，以实现最佳的灵活性和性能。</p>
<h3 id="什么是多继承（Multiple-Inheritance）？在C-中如何实现多继承？"><a href="#什么是多继承（Multiple-Inheritance）？在C-中如何实现多继承？" class="headerlink" title="什么是多继承（Multiple Inheritance）？在C++中如何实现多继承？"></a>什么是多继承（Multiple Inheritance）？在C++中如何实现多继承？</h3><p><strong>回答：</strong> 多继承是C++中一种面向对象编程的特性，允许一个类继承多个基类的特性和行为。在C++中，可以通过以下方式实现多继承：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BaseClass1</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// BaseClass1 的成员函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaseClass2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// BaseClass2 的成员函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DerivedClass</span> : <span class="keyword">public</span> BaseClass1, <span class="keyword">public</span> BaseClass2 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// DerivedClass 的成员函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>DerivedClass</code>从<code>BaseClass1</code>和<code>BaseClass2</code>继承了成员函数<code>func1</code>和<code>func2</code>。</li>
<li>多继承允许一个类拥有多个父类，但需要注意解决潜在的二义性问题。例如，如果两个基类都有相同名称的成员函数，需要使用作用域解析符号来指定调用哪个版本。</li>
</ul>
<p>多继承可以提供更丰富的代码复用和组织，但也可能导致复杂性增加，因为需要处理潜在的二义性和命名冲突。</p>
<h3 id="什么是智能指针（Smart-Pointer）？它们在C-中的作用是什么？"><a href="#什么是智能指针（Smart-Pointer）？它们在C-中的作用是什么？" class="headerlink" title="什么是智能指针（Smart Pointer）？它们在C++中的作用是什么？"></a>什么是智能指针（Smart Pointer）？它们在C++中的作用是什么？</h3><p><strong>回答：</strong> 智能指针是C++中的一种数据类型，用于管理动态分配的内存，以防止内存泄漏和悬挂指针等问题。C++标准库提供了两种主要类型的智能指针：<code>std::shared_ptr</code>和<code>std::unique_ptr</code>。</p>
<ul>
<li><p><strong><code>std::shared_ptr</code>：</strong></p>
<ul>
<li>允许多个智能指针共享同一块内存。</li>
<li>使用引用计数来跟踪共享对象的引用数，当引用计数为零时，自动释放内存。</li>
<li>适用于多个指针需要访问相同对象的情况。</li>
</ul>
</li>
<li><p><strong><code>std::unique_ptr</code>：</strong></p>
<ul>
<li>限制只有一个智能指针可以拥有和管理特定内存块。</li>
<li>适用于单一所有权的情况，可以确保内存的独占性。</li>
<li>移动语义允许将所有权从一个<code>unique_ptr</code>转移给另一个。</li>
</ul>
</li>
</ul>
<p>智能指针的作用包括：</p>
<ul>
<li><p><strong>自动内存管理：</strong> 智能指针负责在对象不再需要时释放内存，从而避免内存泄漏。</p>
</li>
<li><p><strong>资源管理：</strong> 除了内存，智能指针还可以用于管理其他资源，如文件句柄和数据库连接。</p>
</li>
<li><p><strong>避免悬挂指针：</strong> 智能指针的生命周期与所管理的对象相关联，当对象不再存在时，智能指针会自动置为<code>nullptr</code>，避免悬挂指针的问题。</p>
</li>
</ul>
<p>使用智能指针可以提高代码的可维护性和安全性，减少手动内存管理的错误。</p>
<h3 id="什么是虚函数（Virtual-Function）？它在C-中有什么作用？"><a href="#什么是虚函数（Virtual-Function）？它在C-中有什么作用？" class="headerlink" title="什么是虚函数（Virtual Function）？它在C++中有什么作用？"></a>什么是虚函数（Virtual Function）？它在C++中有什么作用？</h3><p><strong>回答：</strong> 虚函数是C++中一种用于实现多态性（polymorphism）的重要特性。虚函数允许子类（派生类）重写（覆盖）基类（父类）中的同名函数，从而在运行时实现动态绑定。以下是虚函数的关键概念和作用：</p>
<ul>
<li><strong>虚函数声明：</strong> 在基类中，可以通过在函数声明前面添加<code>virtual</code>关键字来声明虚函数。子类可以选择性地重写这些虚函数。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">myFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 基类虚函数的实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>函数覆盖：</strong> 子类可以覆盖基类的虚函数，提供自己的实现。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 子类覆盖的虚函数实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>动态绑定：</strong> 当通过基类指针或引用调用虚函数时，实际执行的是派生类的版本。这个机制称为动态绑定，它使多态性成为可能。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Base* ptr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">ptr-&gt;<span class="built_in">myFunction</span>(); <span class="comment">// 调用Derived类的实现</span></span><br></pre></td></tr></table></figure>

<p>虚函数的作用在于实现了多态性，允许通过基类接口操作派生类对象，同时保持了运行时的灵活性和可扩展性。</p>
<h3 id="什么是模板元编程（Template-Metaprogramming）？在C-中如何使用模板元编程？"><a href="#什么是模板元编程（Template-Metaprogramming）？在C-中如何使用模板元编程？" class="headerlink" title="什么是模板元编程（Template Metaprogramming）？在C++中如何使用模板元编程？"></a>什么是模板元编程（Template Metaprogramming）？在C++中如何使用模板元编程？</h3><p><strong>回答：</strong> 模板元编程是一种使用C++模板系统来进行编程的技术，它允许在编译时执行计算和生成代码。模板元编程的核心思想是利用模板特化、递归和编译期常量等功能来进行元编程，生成通用、高性能的代码。</p>
<p>模板元编程的应用包括：</p>
<ul>
<li><strong>泛型编程：</strong> 通过模板编写通用的数据结构和算法，可以在编译时根据不同类型生成高效的代码。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>编译时计算：</strong> 模板元编程可以在编译时执行计算，生成常量表达式的结果。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = N * Factorial&lt;N - <span class="number">1</span>&gt;::value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span>&lt;<span class="number">0</span>&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>元编程技巧：</strong> 模板元编程还可以用于元编程技巧，如类型萃取、类型转换等。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TypeTrait</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">bool</span> is_integer = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TypeTrait</span>&lt;<span class="type">int</span>&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">bool</span> is_integer = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>模板元编程的主要优势在于它在编译时执行，因此可以产生高性能的代码，并在类型安全和泛型性方面提供了强大的工具。但它也可能导致复杂的代码和编译错误，因此需要谨慎使用。</p>
<h3 id="什么是移动语义（Move-Semantics）？它在C-中有什么作用？"><a href="#什么是移动语义（Move-Semantics）？它在C-中有什么作用？" class="headerlink" title="什么是移动语义（Move Semantics）？它在C++中有什么作用？"></a>什么是移动语义（Move Semantics）？它在C++中有什么作用？</h3><p><strong>回答：</strong> 移动语义是C++11引入的一个特性，旨在提高程序性能，特别是在处理大型数据结构时。移动语义允许将资源的所有权从一个对象转移到另一个对象，而无需复制数据。这主要通过移动构造函数和移动赋值运算符来实现。</p>
<p>移动语义的关键概念包括：</p>
<ul>
<li><strong>移动构造函数（Move Constructor）：</strong> 移动构造函数允许从一个临时对象或右值引用（通常是即将销毁的对象）中“窃取”资源，而不是复制资源。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyString</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyString</span>(MyString&amp;&amp; other) &#123;</span><br><span class="line">        <span class="comment">// 移动构造函数，窃取资源</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>移动赋值运算符（Move Assignment Operator）：</strong> 移动赋值运算符允许将资源从一个对象转移到另一个对象，以替代传统的复制赋值。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">MyString&amp; <span class="keyword">operator</span>=(MyString&amp;&amp; other) &#123;</span><br><span class="line">    <span class="comment">// 移动赋值运算符，窃取资源</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>移动语义的主要作用在于：</p>
<ul>
<li><p>提高性能：避免不必要的数据复制，特别是在处理大型数据结构时可以显著提高性能。</p>
</li>
<li><p>支持移动语义的标准库容器和算法：标准库容器（如<code>std::vector</code>）和算法（如<code>std::sort</code>）都已经更新，以支持移动语义，允许更高效地管理和操作对象。</p>
</li>
<li><p>支持移动语义的用户定义类型：用户可以为自己的类型定义移动构造函数和移动赋值运算符，以充分利用移动语义。</p>
</li>
</ul>
<p>移动语义是C++中的重要特性，可用于提高性能和资源管理的效率。</p>
<h3 id="什么是RAII（资源获取即初始化）？它在C-中有什么作用？-1"><a href="#什么是RAII（资源获取即初始化）？它在C-中有什么作用？-1" class="headerlink" title="什么是RAII（资源获取即初始化）？它在C++中有什么作用？"></a>什么是RAII（资源获取即初始化）？它在C++中有什么作用？</h3><p><strong>回答：</strong> RAII（Resource Acquisition Is Initialization）是C++中一种编程惯例，强调在对象的构造期间获取资源，并在对象的析构期间释放资源。RAII的核心思想是利用栈上对象的生命周期来管理资源，以确保资源在任何情况下都会得到正确释放，</p>
<p>避免资源泄漏。</p>
<p>RAII的应用包括：</p>
<ul>
<li><strong>内存管理：</strong> 使用智能指针（如<code>std::shared_ptr</code>和<code>std::unique_ptr</code>）来管理动态分配的内存，确保在对象生命周期结束时自动释放内存。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; ptr = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>); <span class="comment">// 获取内存资源</span></span><br><span class="line">    <span class="comment">// 在此作用域结束时，资源会自动释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>文件和资源管理：</strong> 使用RAII对象管理文件句柄、数据库连接、锁等资源，以确保在离开作用域时资源会被正确释放。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="function">std::ofstream <span class="title">file</span><span class="params">(<span class="string">&quot;example.txt&quot;</span>)</span></span>; <span class="comment">// 打开文件</span></span><br><span class="line">    <span class="comment">// 在此作用域结束时，文件会自动关闭</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>异常安全性：</strong> RAII可以确保在发生异常时资源会被正确释放，从而保证程序的异常安全性。</li>
</ul>
<p>RAII是C++中许多标准库和用户定义类型的设计原则，它简化了资源管理和提高了程序的可维护性和可靠性。</p>
<h3 id="什么是STL（Standard-Template-Library）？它包括哪些常见组件？"><a href="#什么是STL（Standard-Template-Library）？它包括哪些常见组件？" class="headerlink" title="什么是STL（Standard Template Library）？它包括哪些常见组件？"></a>什么是STL（Standard Template Library）？它包括哪些常见组件？</h3><p><strong>回答：</strong> STL（Standard Template Library）是C++标准库的一部分，它提供了一组通用的模板类和函数，用于实现常见的数据结构和算法。STL的目标是提供高性能、可重用的组件，以便开发人员可以更容易地编写高效且可维护的C++代码。</p>
<p>STL包括以下常见组件：</p>
<ul>
<li><p><strong>容器（Containers）：</strong> 容器是用于存储和组织数据的数据结构，STL提供了多种容器，包括<code>vector</code>、<code>list</code>、<code>map</code>、<code>set</code>等。每种容器都有特定的用途和性能特性。</p>
</li>
<li><p><strong>算法（Algorithms）：</strong> STL提供了一组强大的算法，用于在容器上执行各种操作，如排序、查找、遍历等。这些算法可以与不同类型的容器一起使用，提供了通用的接口。</p>
</li>
<li><p><strong>迭代器（Iterators）：</strong> 迭代器用于遍历容器中的元素，STL定义了多种类型的迭代器，包括输入迭代器、输出迭代器、正向迭代器、双向迭代器和随机访问迭代器。</p>
</li>
<li><p><strong>函数对象（Function Objects）：</strong> 函数对象是可调用对象，它们可以像函数一样被调用，并且可以在STL算法中使用。STL提供了一些内置的函数对象，也允许用户定义自己的函数对象。</p>
</li>
<li><p><strong>适配器（Adapters）：</strong> 适配器用于修改或扩展容器和迭代器的行为，如<code>stack</code>、<code>queue</code>、<code>priority_queue</code>等。</p>
</li>
</ul>
<p>STL的设计原则包括通用性、高性能和可复用性，使其成为C++编程中不可或缺的一部分，可以大大简化数据结构和算法的实现。</p>
<h3 id="什么是多态性（Polymorphism）？在C-中如何实现多态性？"><a href="#什么是多态性（Polymorphism）？在C-中如何实现多态性？" class="headerlink" title="什么是多态性（Polymorphism）？在C++中如何实现多态性？"></a>什么是多态性（Polymorphism）？在C++中如何实现多态性？</h3><p><strong>回答：</strong> 多态性是面向对象编程的核心概念之一，它允许不同类的对象对相同的消息作出不同的响应。多态性有两种主要形式：编译时多态性和运行时多态性。</p>
<p>在C++中，运行时多态性通常通过虚函数和基类指针&#x2F;引用实现。以下是多态性的关键概念和实现方式：</p>
<ul>
<li><strong>虚函数（Virtual Function）：</strong> 虚函数是在基类中声明的函数，可以在派生类中被重写（覆盖）。通过在函数声明前面加上<code>virtual</code>关键字来定义虚函数。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">myFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 基类虚函数的实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>函数重写（Function Overriding）：</strong> 派生类可以重写基类中的虚函数，提供自己的实现。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 派生类覆盖的虚函数实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>基类指针和引用：</strong> 基类指针或引用可以指向派生类对象，并在运行时调用派生类的虚函数。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Base* ptr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">ptr-&gt;<span class="built_in">myFunction</span>(); <span class="comment">// 调用Derived类的实现</span></span><br></pre></td></tr></table></figure>

<p>多态性的优点包括代码的灵活性和可扩展性，因为可以根据需要轻松添加新的派生类，而无需修改现有代码。多态性还支持面向接口编程，允许根据对象的行为而不是具体类型进行编程。</p>
<h3 id="什么是单例模式（Singleton-Pattern）？在C-中如何实现单例模式？"><a href="#什么是单例模式（Singleton-Pattern）？在C-中如何实现单例模式？" class="headerlink" title="什么是单例模式（Singleton Pattern）？在C++中如何实现单例模式？"></a>什么是单例模式（Singleton Pattern）？在C++中如何实现单例模式？</h3><p><strong>回答：</strong> 单例模式是一种设计模式，它确保类只有一个实例，并提供一种全局访问该实例的方式。单例模式通常用于那些需要在整个应用程序中共享一个资源或状态的情况。在C++中，可以通过以下方式实现单例模式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 获取单例实例的静态方法</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton&amp; <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> Singleton instance; <span class="comment">// 在首次调用时创建单例</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻止拷贝构造和赋值操作</span></span><br><span class="line">    <span class="built_in">Singleton</span>(Singleton <span class="type">const</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span>=(Singleton <span class="type">const</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">someFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 单例的成员函数实现</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 私有构造函数，防止外部创建实例</span></span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;</span><br><span class="line">        <span class="comment">// 初始化单例</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上述代码中，<code>Singleton</code>类的构造函数是私有的，只能在类的内部访问，从而防止外部代码创建多个实例。<code>getInstance</code>方法返回单例的引用，首次调用时创建实例。</p>
<p>此外，通过删除拷贝构造函数和赋值操作符，可以防止通过复制创建多个实例。</p>
<p>单例模式确保只有一个实例，因此可以全局共享状态和资源，但也要小心全局状态可能导致的问题。</p>
<h3 id="什么是模板（Template）？在C-中如何使用模板？"><a href="#什么是模板（Template）？在C-中如何使用模板？" class="headerlink" title="什么是模板（Template）？在C++中如何使用模板？"></a>什么是模板（Template）？在C++中如何使用模板？</h3><p><strong>回答：</strong> 模板是C++中的一种机制，允许编写通用代码，不受特定数据类型的限制。模板使得可以编写具有类型参数的函数和类，这些类型参数可以在使用模板时进行替换。</p>
<p>在C++中，有两种主要类型的模板：</p>
<ul>
<li><strong>函数模板（Function Template）：</strong> 函数模板允许编写可以处理不同类型的函数，通过将类型参数作为函数参数进行通用化。例如，以下是一个通用的<code>max</code>函数模板：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">max</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>类模板（Class Template）：</strong> 类模板允许编写可以处理不同类型的类，通过将类型参数作为类成员或成员函数参数进行通用化。例如，以下是一个通用的堆栈（<code>Stack</code>）类模板：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 类模板成员和成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T item)</span></span>;</span><br><span class="line">    <span class="function">T <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用模板时，可以提供具体的类型参数，从而生成特定类型的代码实例。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">max</span>(a, b); <span class="comment">// 使用函数模板</span></span><br><span class="line">    Stack&lt;<span class="type">double</span>&gt; doubleStack; <span class="comment">// 使用类模板</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模板使得可以编写高度</p>
<p>通用和可重用的代码，适用于各种数据类型。它在STL（标准模板库）中广泛应用，用于实现通用数据结构和算法。</p>
<h3 id="什么是析构函数（Destructor）？为什么它重要？-1"><a href="#什么是析构函数（Destructor）？为什么它重要？-1" class="headerlink" title="什么是析构函数（Destructor）？为什么它重要？"></a>什么是析构函数（Destructor）？为什么它重要？</h3><p><strong>回答：</strong> 析构函数是C++中的一个特殊成员函数，用于对象的清理和资源释放。析构函数的名称与类名相同，前面加上<code>~</code>符号。析构函数在以下情况下重要：</p>
<ul>
<li><p><strong>资源释放：</strong> 析构函数用于释放对象在其生命周期中分配的资源，如内存、文件句柄、数据库连接等。这有助于避免资源泄漏。</p>
</li>
<li><p><strong>对象生命周期控制：</strong> 析构函数确定了对象在销毁时应采取的行动，例如关闭文件或释放锁定。</p>
</li>
<li><p><strong>异常处理：</strong> 析构函数可以用于处理对象生命周期中的异常情况，确保资源在异常时得到释放。</p>
</li>
<li><p><strong>子类析构函数：</strong> 在继承中，基类的析构函数通常是虚的，以确保在销毁子类对象时正确调用基类析构函数，从而实现多态的析构。</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() &#123;</span><br><span class="line">        <span class="comment">// 构造函数的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123;</span><br><span class="line">        <span class="comment">// 析构函数的代码，用于释放资源</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>确保在需要时正确实现析构函数，以避免资源泄漏和不稳定的程序行为。</p>
<h3 id="什么是预处理器（Preprocessor）？它在C-x2F-C-中有什么作用？-1"><a href="#什么是预处理器（Preprocessor）？它在C-x2F-C-中有什么作用？-1" class="headerlink" title="什么是预处理器（Preprocessor）？它在C&#x2F;C++中有什么作用？"></a>什么是预处理器（Preprocessor）？它在C&#x2F;C++中有什么作用？</h3><p><strong>回答：</strong> 预处理器是C和C++编译过程中的一个独立阶段，用于在实际编译之前处理源代码。预处理器的主要作用包括：</p>
<ul>
<li><p><strong>宏替换：</strong> 预处理器可以替换源代码中的宏定义，例如使用<code>#define</code>定义的宏常量或宏函数。</p>
</li>
<li><p><strong>文件包含：</strong> 预处理器使用<code>#include</code>指令将其他文件的内容插入源文件中，允许代码的模块化组织。</p>
</li>
<li><p><strong>条件编译：</strong> 预处理器使用条件编译指令，如<code>#ifdef</code>和<code>#ifndef</code>，可以根据条件选择性地包含或排除代码块。</p>
</li>
<li><p><strong>注释删除：</strong> 预处理器删除源代码中的注释，以减小编译后的可执行文件的大小。</p>
</li>
<li><p><strong>宏展开：</strong> 预处理器展开宏，将宏调用替换为宏定义的实际内容。</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_VALUE 100 <span class="comment">// 宏定义</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  <span class="comment">// 文件包含</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">    <span class="comment">// 调试代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> value = MAX_VALUE; <span class="comment">// 宏替换</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>预处理器通过生成经过处理的源代码，然后将其传递给编译器进行编译，起到了代码预处理和条件编译的作用。</p>
<h3 id="什么是静态多态性（Static-Polymorphism）和动态多态性（Dynamic-Polymorphism）？它们之间有什么区别？"><a href="#什么是静态多态性（Static-Polymorphism）和动态多态性（Dynamic-Polymorphism）？它们之间有什么区别？" class="headerlink" title="什么是静态多态性（Static Polymorphism）和动态多态性（Dynamic Polymorphism）？它们之间有什么区别？"></a>什么是静态多态性（Static Polymorphism）和动态多态性（Dynamic Polymorphism）？它们之间有什么区别？</h3><p><strong>回答：</strong> </p>
<ul>
<li><strong>静态多态性（Static Polymorphism）：</strong> 静态多态性也称为编译时多态性，是在编译时确定函数调用的方式。它通常与函数重载（Function Overloading）相关，其中编译器根据函数名称、参数类型和个数来选择正确的函数版本。静态多态性的优点在于效率高，因为函数调用在编译时就已经解析，不需要额外的运行时开销。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Printing integer: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">double</span> y)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Printing double: &quot;</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">42</span>;</span><br><span class="line">    <span class="type">double</span> b = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(a); <span class="comment">// 编译时确定调用 print(int)</span></span><br><span class="line">    <span class="built_in">print</span>(b); <span class="comment">// 编译时确定调用 print(double)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>动态多态性（Dynamic Polymorphism）：</strong> 动态多态性也称为运行时多态性，是在运行时根据对象的实际类型来确定函数调用的方式。它通常与虚函数（Virtual Function）和继承相关。通过虚函数，基类指针或引用可以调用派生类的函数，而具体的函数实现是在运行时根据对象的类型来选择的。动态多态性的优点在于它支持多态行为，允许基类接口处理派生类对象。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a shape&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a circle&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Shape* shapePtr = <span class="keyword">new</span> <span class="built_in">Circle</span>();</span><br><span class="line">    shapePtr-&gt;<span class="built_in">draw</span>(); <span class="comment">// 运行时确定调用 Circle 的 draw 函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> shapePtr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>区别：</p>
<ul>
<li>静态多态性在编译时确定函数调用，效率高，但不支持多态行为。</li>
<li>动态多态性在运行时确定函数调用，支持多态行为，但可能带来一些运行时开销。</li>
</ul>
<p>通常，C++开发中根据需要选择使用静态多态性或动态多态性，以满足特定的设计需求。</p>
<h3 id="什么是智能指针（Smart-Pointer）？在C-中有哪些智能指针？"><a href="#什么是智能指针（Smart-Pointer）？在C-中有哪些智能指针？" class="headerlink" title="什么是智能指针（Smart Pointer）？在C++中有哪些智能指针？"></a>什么是智能指针（Smart Pointer）？在C++中有哪些智能指针？</h3><p><strong>回答：</strong> 智能指针是C++中的一种数据类型，用于管理动态分配的内存，以帮助避免内存泄漏和悬挂指针等问题。C++标准库提供了以下几种智能指针：</p>
<ul>
<li><strong><code>std::unique_ptr</code>：</strong><ul>
<li><code>std::unique_ptr</code>表示独占所有权的智能指针，确保只有一个指针可以拥有和管理特定内存块。</li>
<li>移动语义允许将所有权从一个<code>unique_ptr</code>转移给另一个。</li>
<li>通常用于实现独占拥有的情况。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::unique_ptr&lt;<span class="type">int</span>&gt; ptr = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>std::shared_ptr</code>：</strong><ul>
<li><code>std::shared_ptr</code>表示多个智能指针可以共享相同内存块的所有权。</li>
<li>使用引用计数来跟踪共享对象的引用数，当引用计数为零时，自动释放内存。</li>
<li>适用于多个指针需要访问相同对象的情况。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; ptr1 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; ptr2 = ptr1; <span class="comment">// 共享所有权</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>std::weak_ptr</code>：</strong><ul>
<li><code>std::weak_ptr</code>是一种弱引用智能指针，它允许共享对象的引用但不增加引用计数。</li>
<li>主要用于解决<code>std::shared_ptr</code>的循环引用问题，防止内存泄漏。</li>
<li>可以通过<code>std::shared_ptr</code>转换为<code>std::weak_ptr</code>。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; shared = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line">std::weak_ptr&lt;<span class="type">int</span>&gt; weak = shared;</span><br></pre></td></tr></table></figure>

<p>智能指针的主要作用在于自动管理动态分配的内存，避免手动调用<code>new</code>和<code>delete</code>，从而提高代码的可维护性和安全性。</p>
<h3 id="什么是异常处理（Exception-Handling）？在C-中如何进行异常处理？"><a href="#什么是异常处理（Exception-Handling）？在C-中如何进行异常处理？" class="headerlink" title="什么是异常处理（Exception Handling）？在C++中如何进行异常处理？"></a>什么是异常处理（Exception Handling）？在C++中如何进行异常处理？</h3><p><strong>回答：</strong> 异常处理是一种程序设计和错误处理的方法，用于处理程序在运行时遇到的异常情况。异常是指不寻常的、不正常的情况，可能导致程序中断或不正常行为。在C++中，异常处理可以通过以下关键字和机制来实现：</p>
<ul>
<li><strong><code>try</code>：</strong> 使用<code>try</code>关键字来定义一个包含可能引发异常的代码块。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 可能引发异常的代码</span></span><br><span class="line">&#125; <span class="built_in">catch</span> (ExceptionType1 e1) &#123;</span><br><span class="line">    <span class="comment">// 处理 ExceptionType1 异常的代码</span></span><br><span class="line">&#125; <span class="built_in">catch</span> (ExceptionType2 e2) &#123;</span><br><span class="line">    <span class="comment">// 处理 ExceptionType2 异常的代码</span></span><br><span class="line">&#125; <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">    <span class="comment">// 处理其他异常的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>throw</code>：</strong> 使用<code>throw</code>关键字来引发异常。可以引发各种类型的异常，包括内置类型、自定义类型、标准库异常等。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (error_condition) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">MyException</span>(<span class="string">&quot;An error occurred&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong><code>catch</code>：</strong> 使用<code>catch</code>关键字来捕获并处理特定类型的异常。一个<code>try</code>块可以有多个<code>catch</code>块，用于处理不同类型的异常。</p>
</li>
<li><p><strong>自定义异常类型：</strong> 可以自定义异常类型，通过继承自<code>std::exception</code>或其派生类，来表示特定的异常情况，并提供异常信息。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyException</span> : <span class="keyword">public</span> std::exception &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyException</span>(<span class="type">const</span> <span class="type">char</span>* message) : <span class="built_in">message_</span>(message) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">what</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> message_.<span class="built_in">c_str</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string message_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>std::exception</code>：</strong> <code>std::exception</code>是C++标准库中定义的</li>
</ul>
<p>基本异常类，可以用作自定义异常类型的基类。</p>
<p>异常处理允许程序在遇到异常情况时从当前执行路径跳转到异常处理代码，从而实现错误处理和程序稳定性。合理的异常处理可以确保程序在发生异常时不会崩溃，并提供有关异常原因的信息，以便进行故障排除和修复。</p>
<h3 id="什么是静态多态性（Static-Polymorphism）和动态多态性（Dynamic-Polymorphism）？它们之间有什么区别？-1"><a href="#什么是静态多态性（Static-Polymorphism）和动态多态性（Dynamic-Polymorphism）？它们之间有什么区别？-1" class="headerlink" title="什么是静态多态性（Static Polymorphism）和动态多态性（Dynamic Polymorphism）？它们之间有什么区别？"></a>什么是静态多态性（Static Polymorphism）和动态多态性（Dynamic Polymorphism）？它们之间有什么区别？</h3><p><strong>回答：</strong> </p>
<ul>
<li><strong>静态多态性（Static Polymorphism）：</strong> 静态多态性也称为编译时多态性，是在编译时确定函数调用的方式。它通常与函数重载（Function Overloading）相关，其中编译器根据函数名称、参数类型和个数来选择正确的函数版本。静态多态性的优点在于效率高，因为函数调用在编译时就已经解析，不需要额外的运行时开销。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Printing integer: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">double</span> y)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Printing double: &quot;</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">42</span>;</span><br><span class="line">    <span class="type">double</span> b = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(a); <span class="comment">// 编译时确定调用 print(int)</span></span><br><span class="line">    <span class="built_in">print</span>(b); <span class="comment">// 编译时确定调用 print(double)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>动态多态性（Dynamic Polymorphism）：</strong> 动态多态性也称为运行时多态性，是在运行时根据对象的实际类型来确定函数调用的方式。它通常与虚函数（Virtual Function）和继承相关。通过虚函数，基类指针或引用可以调用派生类的函数，而具体的函数实现是在运行时根据对象的类型来选择的。动态多态性的优点在于它支持多态行为，允许基类接口处理派生类对象。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a shape&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a circle&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Shape* shapePtr = <span class="keyword">new</span> <span class="built_in">Circle</span>();</span><br><span class="line">    shapePtr-&gt;<span class="built_in">draw</span>(); <span class="comment">// 运行时确定调用 Circle 的 draw 函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> shapePtr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>区别：</p>
<ul>
<li>静态多态性在编译时确定函数调用，效率高，但不支持多态行为。</li>
<li>动态多态性在运行时确定函数调用，支持多态行为，但可能带来一些运行时开销。</li>
</ul>
<p>通常，C++开发中根据需要选择使用静态多态性或动态多态性，以满足特定的设计需求。</p>
<p>我明白了，让我为您提供一些新的问题和答案，以避免重复：</p>
<h3 id="什么是C-中的引用（Reference）？"><a href="#什么是C-中的引用（Reference）？" class="headerlink" title="什么是C++中的引用（Reference）？"></a>什么是C++中的引用（Reference）？</h3><p><strong>回答：</strong> 引用是C++中的一种数据类型，它允许一个变量引用（别名）另一个变量。引用提供了对变量的间接访问方式，使得可以通过不同的名字访问相同的内存位置。引用的主要特点包括：</p>
<ul>
<li>引用必须在定义时初始化，并且一旦初始化，就不能再引用其他对象。</li>
<li>引用在使用时不需要解引用操作（使用<code>*</code>符号），因为它们本身就是别名。</li>
<li>引用通常用于函数参数，以便通过引用传递参数，从而避免复制大量数据。</li>
</ul>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span>&amp; ref = x; <span class="comment">// 引用 x，ref 成为 x 的别名</span></span><br><span class="line"></span><br><span class="line">ref = <span class="number">10</span>;     <span class="comment">// 修改 x 的值，ref 也会跟着变成 10</span></span><br></pre></td></tr></table></figure>

<p>引用在C++中广泛用于函数参数传递、操作符重载和STL中，以提供更高效的代码和更自然的语法。</p>
<h3 id="什么是C-中的析构函数（Destructor）？"><a href="#什么是C-中的析构函数（Destructor）？" class="headerlink" title="什么是C++中的析构函数（Destructor）？"></a>什么是C++中的析构函数（Destructor）？</h3><p><strong>回答：</strong> 析构函数是C++中的一种特殊成员函数，它用于在对象生命周期结束时执行必要的清理和资源释放操作。析构函数的名称与类名相同，但前面加上波浪号（<code>~</code>）。</p>
<p>析构函数的主要作用包括：</p>
<ul>
<li>释放对象在其生命周期中分配的资源，如内存、文件句柄、数据库连接等。</li>
<li>控制对象的生命周期，确保在对象销毁时执行必要的操作。</li>
<li>处理对象生命周期中的异常情况，以确保资源不会泄漏。</li>
</ul>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FileHandler</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FileHandler</span>(<span class="type">const</span> std::string&amp; filename) &#123;</span><br><span class="line">        file = std::<span class="built_in">fopen</span>(filename.<span class="built_in">c_str</span>(), <span class="string">&quot;r&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!file) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to open file&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">FileHandler</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (file) &#123;</span><br><span class="line">            std::<span class="built_in">fclose</span>(file);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他成员函数，用于文件操作</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::FILE* file;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>FileHandler</code>类的析构函数用于关闭文件句柄，确保文件在对象生命周期结束时被正确关闭。</p>
<h3 id="C-中的多重继承是什么？它有什么特点和潜在的问题？"><a href="#C-中的多重继承是什么？它有什么特点和潜在的问题？" class="headerlink" title="C++中的多重继承是什么？它有什么特点和潜在的问题？"></a>C++中的多重继承是什么？它有什么特点和潜在的问题？</h3><p><strong>回答：</strong> 多重继承是C++中的一种面向对象编程概念，它允许一个类从多个基类继承属性和行为。多重继承的特点和潜在问题包括：</p>
<p>特点：</p>
<ul>
<li>一个派生类可以继承多个基类的成员，包括数据成员和成员函数。</li>
<li>可以实现不同类之间的复杂关系，例如混合多个不同类型的功能。</li>
</ul>
<p>潜在问题：</p>
<ul>
<li><strong>菱形继承问题（Diamond Inheritance Problem）：</strong> 当一个类通过多条路径继承同一个基类时，可能导致同一基类的多个实例被创建，引发二义性。</li>
<li><strong>函数名冲突：</strong> 如果多个基类具有相同名称的成员函数，可能导致函数名冲突，需要使用作用域解析运算符（<code>::</code>）来解决。</li>
<li><strong>复杂性增加：</strong> 多重继承会增加类之间的复杂性，使得代码更难理解和维护。</li>
</ul>
<p>解决多重继承问题的方法包括虚继承（使用<code>virtual</code>继承来解决菱形继承问题）、作用域解析运算符（<code>::</code>）、以及合理的设计，避免深层次和复杂的继承结构。</p>
<p>多重继承应慎重使用，通常在需要时才使用，以避免引发潜在问题。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>C/C++</tag>
        <tag>知识手册</tag>
      </tags>
  </entry>
  <entry>
    <title>C++面试题总结（分类版）</title>
    <url>/2023/08/23/C-%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93%EF%BC%88%E5%88%86%E7%B1%BB%E7%89%88%EF%BC%89/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>C++面试题分知识点重新排了一下</p>
<span id="more"></span>

<h3 id="C-x2F-C-基础"><a href="#C-x2F-C-基础" class="headerlink" title="C&#x2F;C++ 基础"></a>C&#x2F;C++ 基础</h3><ol>
<li><p><strong>什么是C++？</strong></p>
<p><strong>回答：</strong> C++是一种通用的、面向对象的编程语言，是C语言的扩展，它结合了高级语言的特性和低级语言的控制。C++支持面向对象编程、泛型编程和过程式编程，具有丰富的标准库。</p>
</li>
<li><p><strong>什么是C++的优点和特点？</strong></p>
<p><strong>回答：</strong> C++的优点包括：</p>
<ul>
<li>面向对象编程：支持类、继承、多态等面向对象特性。</li>
<li>性能：C++允许底层内存控制，可实现高性能的代码。</li>
<li>标准库：拥有强大的标准库，提供各种数据结构和算法。</li>
<li>多范式：支持多种编程范式，如面向对象和泛型编程。</li>
</ul>
</li>
<li><p><strong>什么是C++的缺点？</strong></p>
<p><strong>回答：</strong> C++的缺点包括：</p>
<ul>
<li>复杂性：语法复杂，学习曲线陡峭。</li>
<li>内存管理：需要手动管理内存，容易导致内存泄漏和悬挂指针。</li>
<li>安全性：不如一些其他语言（如Java）那样严格的安全性。</li>
<li>移植性：不同编译器和平台之间的移植性有时较差。</li>
</ul>
</li>
<li><p><strong>C++和C的主要区别是什么？</strong></p>
<p><strong>回答：</strong> C++在C的基础上引入了面向对象编程的特性，主要区别包括：</p>
<ul>
<li>面向对象：C++支持类、继承、多态等面向对象特性，C不支持。</li>
<li>标准库：C++拥有更丰富的标准库，包括STL等。</li>
<li>引入了新的关键字和语法，如<code>class</code>、<code>new</code>、<code>delete</code>等。</li>
<li>兼容性：C++可以使用C的代码，但C不一定能使用C++的代码。</li>
</ul>
</li>
<li><p><strong>什么是C++标准库？</strong></p>
<p><strong>回答：</strong> C++标准库是一组标准化的函数、对象和模板，提供了各种数据结构和算法，以便C++程序员更轻松地开发应用程序。它包括输入输出、容器、算法、文件操作等多个部分，如STL（Standard Template Library）。</p>
</li>
<li><p><strong>C++中的const关键字有什么作用？</strong></p>
<p><strong>回答：</strong> <code>const</code>关键字用于声明常量，它有以下作用：</p>
<ul>
<li>声明常量变量，一旦赋值后不能修改。</li>
<li>声明常量指针，指针指向的内容不能通过指针修改。</li>
<li>声明常量成员函数，不允许修改对象的成员变量。</li>
</ul>
</li>
<li><p><strong>C++中的static关键字有什么作用？</strong></p>
<p><strong>回答：</strong> <code>static</code>关键字在C++中的作用包括：</p>
<ul>
<li>声明静态变量，这些变量在函数调用之间保持其值。</li>
<li>声明静态成员变量，这些成员变量属于类而不是对象。</li>
<li>声明静态成员函数，这些函数不属于特定对象，可通过类名直接访问。</li>
</ul>
</li>
<li><p><strong>C++中的指针和引用有什么区别？</strong></p>
<p><strong>回答：</strong> 指针和引用的区别包括：</p>
<ul>
<li><strong>初始化和赋值：</strong> 指针需要初始化，并可以在后续重新赋值，而引用必须在声明时初始化，并不能重新绑定到其他对象。</li>
<li><strong>符号和操作：</strong> 指针使用<code>*</code>和<code>-&gt;</code>来访问对象，而引用直接使用对象名。</li>
<li><strong>空值：</strong> 指针可以为空（null），引用不能。</li>
</ul>
</li>
<li><p><strong>C++中的重载（Overloading）是什么？</strong></p>
<p><strong>回答：</strong> 重载是C++中的特性，允许在同一作用域内定义多个同名函数，但它们具有不同的参数列表（参数类型或个数）。编译器根据函数调用时提供的参数来选择正确的函数版本。</p>
</li>
<li><p><strong>什么是C++中的运算符重载？</strong></p>
<p><strong>回答：</strong> 运算符重载是C++中的特性，允许对标准运算符（如<code>+</code>、<code>-</code>、<code>*</code>等）进行自定义定义，以便用于自定义数据类型的操作。运算符重载通过函数重载来实现，重载函数的名称是运算符本身。</p>
</li>
</ol>
<h3 id="内存管理和指针"><a href="#内存管理和指针" class="headerlink" title="内存管理和指针"></a>内存管理和指针</h3><ol start="11">
<li><p><strong>什么是内存泄漏？如何避免内存泄漏？</strong></p>
<p><strong>回答：</strong> 内存泄漏是指程序分配的内存在不再使用时未被释放，导致系统的可用内存逐渐减少。要避免内存泄漏，可以采取以下措施：</p>
<ul>
<li>始终匹配<code>new</code>和<code>delete</code>、<code>malloc</code>和<code>free</code>。</li>
<li>使用智能指针来自动管理内存。</li>
<li>适时释放不再使用的资源，如文件句柄、数据库连接等。</li>
<li>使用内置数组或STL容器而不是手动分配内存。</li>
</ul>
</li>
<li><p><strong>什么是智能指针（Smart Pointer）？在C++中有哪些智能指针？</strong></p>
<p><strong>回答：</strong> 智能指针是C++中的一种数据类型，用于管理动态分配的内存，以避免内存泄漏和悬挂指针等问题。C++标准库提供了以下几种智能指针：</p>
<ul>
<li><code>std::unique_ptr</code>：表示独占所有权的智能指针。</li>
<li><code>std::shared_ptr</code>：表示多个智能指针可以共享相同内存块的所有权。</li>
<li><code>std::weak_ptr</code>：是一种弱引用智能指针，用于解决<code>std::shared_ptr</code>的循环引用问题。</li>
</ul>
</li>
<li><p><strong>什么是堆（Heap）和栈（Stack）？</strong></p>
<p><strong>回答：</strong> 堆和栈是计算机内存中的两个主要区域：</p>
<ul>
<li><strong>栈（Stack）：</strong> 用于存储函数调用、局部变量等短期存储的数据。它的管理由编译器自动处理，通常具有较小的固定大小。</li>
<li><strong>堆（Heap）：</strong> 用于存储动态分配的数据，如通过<code>new</code>、<code>malloc</code>等分配的内存。堆的管理需要显式释放，否则可能导致内存泄漏。</li>
</ul>
</li>
<li><p><strong>什么是指针和引用？它们之间有什么区别？</strong></p>
<p><strong>回答：</strong> 指针和引用的区别包括：</p>
<ul>
<li><strong>初始化和赋值：</strong> 指针需要初始化，并可以在后续重新赋值，而引用必须在声明时初始化，并不能重新绑定到其他对象。</li>
<li><strong>符号和操作：</strong> 指针使用<code>*</code>和<code>-&gt;</code>来访问对象，而引用直接使用对象名。</li>
<li><strong>空值：</strong> 指针可以为空（null），引用不能。</li>
</ul>
</li>
<li><p><strong>什么是野指针（Dangling Pointer）？如何避免野指针问题？</strong></p>
<p><strong>回答：</strong> 野指针是指指向已释放或未分配内存的指针，访问野指针会导致未定义的行为。为避免野指针问题，可以采取以下措施：</p>
<ul>
<li>在释放内存后，将指针设置为null或空指针。</li>
<li>避免使用未初始化的指针。</li>
<li>使用智能指针来自动管理内存。</li>
</ul>
</li>
</ol>
<h3 id="类和面向对象编程"><a href="#类和面向对象编程" class="headerlink" title="类和面向对象编程"></a>类和面向对象编程</h3><ol start="16">
<li><p><strong>什么是类和对象？</strong></p>
<p><strong>回答：</strong> 类是一种抽象数据类型，定义了数据成员和成员函数，对象是类的实例。类描述了对象的属性和行为。</p>
</li>
<li><p><strong>什么是封装（Encapsulation）？</strong></p>
<p><strong>回答：</strong> 封装是面向对象编程的原则，它将数据和操作数据的方法封装在一个单元中，防止外部直接访问数据，提供了数据隐藏和抽象。</p>
</li>
<li><p><strong>什么是继承（Inheritance）？C++支持多重继承吗？</strong></p>
<p><strong>回答：</strong> 继承是面向对象编程的概念，允许一个类（派生类）从另一个类（基类）继承属性和行为。C++支持多重继承，即一个派生类可以从多个基类继承。</p>
</li>
<li><p><strong>什么是多态性（Polymorphism）？C++中如何实现多态性？</strong></p>
<p><strong>回答：</strong> 多态性是面向对象编程的概念，它允许不同对象对相同的消息做出不同的响应。在C++中，多态性通过虚函数和函数重载来实现。</p>
</li>
<li><p><strong>什么是虚函数（Virtual Function）和纯虚函数（Pure Virtual Function）？</strong></p>
<p><strong>回答：</strong> 虚函数是用关键字<code>virtual</code>声明的类成员函数，它允许在派生类中进行重写（覆盖）。纯虚函数是一个没有实现的虚函数，它的声明以<code>= 0</code>结尾，用于定义接口。</p>
</li>
<li><p><strong>什么是构造函数和析构函数？它们的作用是什么？</strong></p>
<p><strong>回答：</strong> 构造函数是用于对象初始化的特殊成员函数，它在对象创建时自动调用。析构函数用于对象销毁时执行必要的清理和资源释放操作。构造函数和析构函数的名称与类名相同，但析构函数前面加上波浪号（<code>~</code>）。</p>
</li>
</ol>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><ol start="22">
<li><p><strong>什么是异常处理（Exception Handling）？在C++中如何进行异常处理？</strong></p>
<p><strong>回答：</strong> 异常处理是一种程序设计和错误处理的方法，用于处理程序在运行时遇到的异常情况。异常是指不寻常的、不正常的情况，可能导致程序中断或不正常行为。在C++中，异常处理可以通过<code>try</code>、<code>throw</code>和<code>catch</code>关键字来实现。</p>
</li>
<li><p><strong>什么是RAII（资源获取即初始化）？它在C++中有什么作用？</strong></p>
<p><strong>回答：</strong> RAII（Resource Acquisition Is Initialization）是C++中的一种编程范式，它强调资源的获取和释放应与对象的生命周期绑定。RAII的核心思想是在对象的构造函数中获取资源，在析构函数中释放资源，这样可以确保资源在对象生命周期结束时被正确释放，避免资源泄漏。RAII用于管理各种资源，包括内存、文件句柄、数据库连接等。</p>
</li>
</ol>
<h3 id="文件和输入输出"><a href="#文件和输入输出" class="headerlink" title="文件和输入输出"></a>文件和输入输出</h3><ol start="24">
<li><p><strong>如何在C++中读写文件？</strong></p>
<p><strong>回答：</strong> 在C++中，可以使用<code>&lt;fstream&gt;</code>头文件中的<code>ifstream</code>和<code>ofstream</code>类来进行文件的读写操作。通常的步骤包括打开文件、读写数据、关闭文件。同时，C++还提供了<code>&lt;iostream&gt;</code>中的输入输出流对象，如<code>cin</code>和<code>cout</code>，用于标准输入输出。</p>
</li>
<li><p><strong>什么是C++的流（Stream）？有哪些常用的流对象？</strong></p>
<p><strong>回答：</strong> 流是C++中用于输入和输出的抽象概念，它将数据流转化为字符流，使得数据的输入和输出都可以通过流进行。常用的流对象包括：</p>
<ul>
<li><code>cin</code>：标准输入流，用于从键盘读取输入。</li>
<li><code>cout</code>：标准输出流，用于向屏幕输出。</li>
<li><code>ifstream</code>：用于从文件读取输入。</li>
<li><code>ofstream</code>：用于向文件写入输出。</li>
<li><code>stringstream</code>：用于处理字符串的输入输出。</li>
</ul>
</li>
<li><p><strong>C++中的输入输出运算符是什么？如何重载它们？</strong></p>
<p><strong>回答：</strong> C++中的输入输出运算符是<code>&lt;&lt;</code>和<code>&gt;&gt;</code>，它们通常用于<code>cout</code>和<code>cin</code>对象以及文件流对象的输入输出。您可以通过运算符重载来自定义类的输入输出行为，重载函数的名称是运算符本身，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> MyClass&amp; obj) &#123;</span><br><span class="line">        os &lt;&lt; obj.data; <span class="comment">// 自定义输出行为</span></span><br><span class="line">        <span class="keyword">return</span> os;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> std::istream&amp; <span class="keyword">operator</span>&gt;&gt;(std::istream&amp; is, MyClass&amp; obj) &#123;</span><br><span class="line">        is &gt;&gt; obj.data; <span class="comment">// 自定义输入行为</span></span><br><span class="line">        <span class="keyword">return</span> is;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="模板和泛型编程"><a href="#模板和泛型编程" class="headerlink" title="模板和泛型编程"></a>模板和泛型编程</h3><ol start="27">
<li><p><strong>什么是模板（Template）？在C++中如何使用模板？</strong></p>
<p><strong>回答：</strong> 模板是C++中的一种机制，允许编写通用的代码以适应不同的数据类型。模板以<code>template</code>关键字开始，可以定义函数模板和类模板。</p>
</li>
<li><p><strong>什么是STL（Standard Template Library）？它包括哪些常见组件？</strong></p>
<p><strong>回答：</strong> STL是C++标准库的一部分，提供了许多常用的数据结构和算法，包括容器（如向量、链表、映射）、迭代器、算法（如排序、查找、遍历）等。STL使C++程序员能够更轻松地处理数据和执行常见的操作。</p>
</li>
</ol>
<h3 id="编译和预处理器"><a href="#编译和预处理器" class="headerlink" title="编译和预处理器"></a>编译和预处理器</h3><ol start="29">
<li><p><strong>什么是预处理器（Preprocessor）？它在C&#x2F;C++中有什么作用？</strong></p>
<p><strong>回答：</strong> 预处理器是C&#x2F;C++编译过程的一部分，用于在实际编译之前对源代码进行处理。它的主要作用包括：</p>
<ul>
<li>处理预处理指令，如<code>#include</code>、<code>#define</code>等。</li>
<li>进行宏替换。</li>
<li>条件编译，根据条件编译部分代码。</li>
<li>生成头文件的包含关系。<br>预处理器的工作是在实际编译之前进行的，它可以影响源代码的文本，但不会涉及编译后的机器代码生成。</li>
</ul>
</li>
</ol>
<h3 id="面试中常见问题"><a href="#面试中常见问题" class="headerlink" title="面试中常见问题"></a>面试中常见问题</h3><ol start="30">
<li><p><strong>为什么C++中需要析构函数？</strong></p>
<p><strong>回答：</strong> 析构函数是C++中的特殊成员函数，用于在对象生命周期结束时执行必要的清理和资源释放操作。它是必要的，因为C++允许手动管理资源，如内存、文件句柄等，析构函数确保这些资源在对象销毁时被正确释放，避免资源泄漏。</p>
</li>
<li><p><strong>什么是函数重载（Function Overloading）？举例说明。</strong></p>
<p><strong>回答：</strong> 函数重载是指在同一作用域内定义多个同名函数，但它们具有不同的参数列表（参数类型或个数）。编译器根据函数调用时提供的参数来选择正确的函数版本。示例如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Printing integer: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">double</span> y)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Printing double: &quot;</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">42</span>;</span><br><span class="line">    <span class="type">double</span> b = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(a); <span class="comment">// 编译时确定调用 print(int)</span></span><br><span class="line">    <span class="built_in">print</span>(b); <span class="comment">// 编译时确定调用 print(double)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>C++中的多重继承是什么？它有什么特点和潜在的问题？</strong></p>
<p><strong>回答：</strong> 多重继承是C++中的面向对象编程概念，允许一个类从多个基类继承属性和行为。多重继承的特点和潜在问题包括：<br>特点：</p>
<ul>
<li>一个派生类可以继承多个基类的成员，包括数据成员和成员函数。</li>
<li>可以实现不同类之间的复杂关系，例如混合多个不同类型的功能。<br>潜在问题：</li>
<li><strong>菱形继承问题（Diamond Inheritance Problem）：</strong> 当一个类通过多条路径继承同一个基类时，可能导致同一基类的多个实例被创建，引发二义性。</li>
<li><strong>函数名冲突：</strong> 如果多个基类具有相同名称的成员函数，可能导致函数名冲突，需要使用作用域解析运算符来解决。</li>
</ul>
</li>
<li><p><strong>什么是静态多态性（Static Polymorphism）和动态多态性（Dynamic Polymorphism）？它们之间有什么区别？</strong></p>
<p><strong>回答：</strong> </p>
<ul>
<li><p><strong>静态多态性（Static Polymorphism）：</strong> 静态多态性是在编译时确定函数调用的多态性，通常通过函数重载和运算符重载实现。编译器在编译时选择正确的函数版本。</p>
</li>
<li><p><strong>动态多态性（Dynamic Polymorphism）：</strong> 动态多态性是在运行时确定函数调用的多态性，通常通过虚函数实现。运行时根据对象的实际类型来调用适当的函数版本。这通常涉及基类指针或引用指向派生类对象。</p>
</li>
</ul>
</li>
<li><p><strong>什么是C++中的引用（Reference）？</strong></p>
<p><strong>回答：</strong> 引用是C++中的一种数据类型，用于创建变量的别名。它允许在不使用指针的情况下对变量进行操作，并且必须在声明时进行初始化。引用通常用于函数参数传递和返回值，以避免复制大型对象。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>C/C++</tag>
        <tag>知识手册</tag>
      </tags>
  </entry>
  <entry>
    <title>线程与协程异同比较</title>
    <url>/2023/08/19/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%8D%8F%E7%A8%8B%E5%BC%82%E5%90%8C%E6%AF%94%E8%BE%83/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>线程和协程都是用于多任务并发编程的概念，但它们有很大的不同之处。在本文中，我们将深入讨论线程和协程的异同点，并提供一些示例代码来说明它们的用法。</p>
<span id="more"></span>

<h2 id="线程（Threads）"><a href="#线程（Threads）" class="headerlink" title="线程（Threads）"></a>线程（Threads）</h2><p>线程是操作系统级别的并发执行单位，它是多任务编程的一种方式。每个线程都有自己的堆栈和程序计数器，可以独立运行。线程之间可以并行执行，共享进程的内存空间，因此可以访问相同的全局变量和数据结构。</p>
<h3 id="线程的特点"><a href="#线程的特点" class="headerlink" title="线程的特点"></a>线程的特点</h3><ol>
<li><p><strong>并行执行</strong>：线程可以并行执行，利用多核处理器的优势，提高程序性能。</p>
</li>
<li><p><strong>共享内存</strong>：线程可以访问相同进程的内存空间，因此可以轻松共享数据。</p>
</li>
<li><p><strong>适用于长时间任务</strong>：线程适用于执行长时间运行的任务，例如网络通信、文件读写等。</p>
</li>
</ol>
<h3 id="线程的示例代码"><a href="#线程的示例代码" class="headerlink" title="线程的示例代码"></a>线程的示例代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello from thread!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(hello)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="协程（Coroutines）"><a href="#协程（Coroutines）" class="headerlink" title="协程（Coroutines）"></a>协程（Coroutines）</h2><p>协程是一种更轻量级的并发编程概念，它允许函数在执行过程中暂停并在稍后恢复执行，而不需要创建新的线程。协程通常在函数级别上实现，而不是线程级别。</p>
<h3 id="协程的特点"><a href="#协程的特点" class="headerlink" title="协程的特点"></a>协程的特点</h3><ol>
<li><p><strong>轻量级</strong>：协程比线程更轻量级，创建和销毁协程的开销较小。</p>
</li>
<li><p><strong>避免并发问题</strong>：协程通常不会涉及共享内存，因此避免了许多并发问题，如竞态条件和死锁。</p>
</li>
<li><p><strong>适用于 I&#x2F;O 密集型任务</strong>：协程适用于执行 I&#x2F;O 密集型任务，如网络请求、文件操作等。</p>
</li>
</ol>
<h3 id="协程的示例代码"><a href="#协程的示例代码" class="headerlink" title="协程的示例代码"></a>协程的示例代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;coroutine&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Task</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">auto</span> <span class="title">get_return_object</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Task&#123;&#125;; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">auto</span> <span class="title">initial_suspend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> std::suspend_always&#123;&#125;; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">auto</span> <span class="title">final_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> std::suspend_always&#123;&#125;; &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">return_void</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">await_suspend</span><span class="params">(std::coroutine_handle&lt;&gt; h)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Task is suspended&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        h.<span class="built_in">resume</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Task <span class="title">myCoroutine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">co_await</span> std::suspend_always&#123;&#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Coroutine resumed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">myCoroutine</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="异同点比较"><a href="#异同点比较" class="headerlink" title="异同点比较"></a>异同点比较</h2><h3 id="1-并发级别"><a href="#1-并发级别" class="headerlink" title="1. 并发级别"></a>1. 并发级别</h3><ul>
<li><strong>线程</strong>：线程是操作系统级别的并发执行单位，可以并行执行在多核处理器上。</li>
<li><strong>协程</strong>：协程是函数级别的并发单位，通常在单个线程内执行，不能并行执行。</li>
</ul>
<h3 id="2-内存和开销"><a href="#2-内存和开销" class="headerlink" title="2. 内存和开销"></a>2. 内存和开销</h3><ul>
<li><strong>线程</strong>：线程的创建和销毁开销较大，因为每个线程都有自己的堆栈和上下文。线程通常需要更多的内存。</li>
<li><strong>协程</strong>：协程轻量级，创建和销毁开销小。协程通常需要较少的内存。</li>
</ul>
<h3 id="3-共享状态"><a href="#3-共享状态" class="headerlink" title="3. 共享状态"></a>3. 共享状态</h3><ul>
<li><strong>线程</strong>：线程之间可以轻松共享内存，但需要考虑同步和竞态条件。</li>
<li><strong>协程</strong>：协程通常不涉及共享内存，因此避免了大部分并发问题。</li>
</ul>
<h3 id="4-适用场景"><a href="#4-适用场景" class="headerlink" title="4. 适用场景"></a>4. 适用场景</h3><ul>
<li><strong>线程</strong>：适用于长时间运行的任务，利用多核处理器的并行性。</li>
<li><strong>协程</strong>：适用于 I&#x2F;O 密集型任务，避免了线程的开销和并发问题。</li>
</ul>
<p>综上所述，线程和协程在多任务编程中有不同的优势和用途。线程适用于需要并行执行的长时间任务，而协程适用于避免共享内存和处理 I&#x2F;O 密集型任务。在实际应用中，可以根据具体的需求选择合适的并发模型。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>内联函数和函数调用之间的主要区别</title>
    <url>/2023/08/15/%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E4%B9%8B%E9%97%B4%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>内联函数和普通函数调用之间有一些关键区别，它们影响了编译器如何处理函数以及程序的性能。下面是内联函数和函数调用之间的主要区别：</p>
<span id="more"></span>

<p><strong>1.编译时机制：</strong></p>
<ul>
<li>内联函数：内联函数是在编译时展开的，编译器会将函数体的代码复制到每个调用点，并消除函数调用的开销。</li>
<li>函数调用：普通函数调用是在运行时进行的，程序在运行时跳转到函数的地址执行代码。</li>
</ul>
<p><strong>2. 调用开销：</strong></p>
<ul>
<li>内联函数：由于内联函数是在调用点展开的，所以没有函数调用的开销，没有函数栈帧的创建和销毁，通常比函数调用更高效。</li>
<li>函数调用：函数调用涉及跳转到函数的地址、保存上下文、分配函数栈帧、传递参数等开销，相对较慢。</li>
</ul>
<p><strong>3. 代码膨胀：</strong></p>
<ul>
<li>内联函数：内联函数的代码会在每个调用点都复制一份，可能导致代码膨胀，增加可执行文件的大小。</li>
<li>函数调用：函数调用不会导致代码膨胀，函数的代码只有一份。</li>
</ul>
<p><strong>4. 适用场景：</strong></p>
<ul>
<li>内联函数：适用于短小、频繁调用的函数，如简单的getter和setter函数、数学运算等。</li>
<li>函数调用：适用于复杂的函数或递归函数。</li>
</ul>
<p><strong>5. 代码可读性：</strong></p>
<ul>
<li>内联函数：内联函数通常将函数体的代码嵌入到调用点，可能会导致可读性较差的代码。</li>
<li>函数调用：函数调用可以提高代码的可读性，因为它将具体的实现分离出来。</li>
</ul>
<p><strong>6. 语法：</strong></p>
<ul>
<li>内联函数：使用 <code>inline</code> 关键字进行声明和定义。</li>
<li>函数调用：直接调用函数名。</li>
</ul>
<p>下面是一个示例，演示了内联函数和函数调用之间的区别：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 内联函数</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数调用</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">subtract</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">5</span>, y = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> result1 = <span class="built_in">add</span>(x, y);        <span class="comment">// 内联函数展开为 x + y</span></span><br><span class="line">    <span class="type">int</span> result2 = <span class="built_in">subtract</span>(x, y);   <span class="comment">// 函数调用 subtract(x, y)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总之，内联函数和函数调用之间的选择取决于代码的需求和性能优化。内联函数可以提高性能，但可能导致代码膨胀，而函数调用具有更好的代码结构和可读性。在实际编程中，需要根据具体情况权衡二者的利弊。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中string相加为什么有时中间会出现E</title>
    <url>/2023/12/28/C-%E4%B8%ADstring%E7%9B%B8%E5%8A%A0%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E6%97%B6%E4%B8%AD%E9%97%B4%E4%BC%9A%E5%87%BA%E7%8E%B0E/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><span id="more"></span>

<p>在C++中，使用 <code>+</code> 运算符进行字符串相加时，不会出现额外的字符如 “E”。如果字符串相加的结果中看到 “E”，可能是因为其中的一个字符串是以 null 字符 (<code>&#39;\0&#39;</code>) 结尾的 C 风格字符串，而另一个是使用 C++ 的 <code>std::string</code> 表示的。</p>
<p>在 C 风格字符串中，字符串的结束是由 null 字符 (<code>&#39;\0&#39;</code>) 来标志的。如果一个字符串的末尾没有 null 字符，C++ 在处理时可能会导致错误。</p>
<p>例如，考虑以下情况：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* cString = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    std::string cppString = <span class="string">&quot;World&quot;</span>;</span><br><span class="line"></span><br><span class="line">    std::string result = cString + cppString;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>cString</code> 是一个 C 风格字符串，而 <code>cppString</code> 是一个 <code>std::string</code>。由于 <code>cString</code> 是以 null 字符结尾的，当它与 <code>cppString</code> 相加时，<code>+</code> 运算符会继续附加 <code>cppString</code> 的内容，但是在结果字符串中可能会有问题。</p>
<p>为了避免这种问题，可以确保 C++ 中的字符串都是使用 <code>std::string</code> 类型表示。如果需要将 C 风格字符串与 <code>std::string</code> 进行操作，可以使用 <code>std::string</code> 的构造函数来显式地创建 <code>std::string</code> 对象：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::string result = std::<span class="built_in">string</span>(cString) + cppString;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>2024新年快乐</title>
    <url>/2024/01/01/2024%E6%96%B0%E5%B9%B4%E5%BF%AB%E4%B9%90/</url>
    <content><![CDATA[<p><img src="/../images/IMG_2717290966EE-1-4099087.jpg" alt="IMG_2717290966EE-1"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>2023真是转瞬即逝啊！</p>
<span id="more"></span>



<p>每次到总结的时候又不知道该说些什么，不顾我觉得过去的2023年还是挺充实的。对于保持记录这种事情上，我不知道为啥有种莫名的抗拒，是不是觉得说出来的话就不是心里话了，哈哈，正经人谁写日记呢。23年确实是不断思索和启发的一年，上半年处于半摆烂状态，每天都能躺着刷视频从早看到晚，对于今后的人生选择也懒得去思索。</p>
<img src="../images/image-20240101170742181.png" alt="image-20240101170742181" >

<img src="../images/image-20240101170826336.png" alt="image-20240101170826336" >





<p>后面也慢慢开始尝试各种新的生活方式，目前仍处于并将长期处于探索新生活的阶段。尤其是重拾了一些多年前的兴趣，比如重拾了毛笔字。。。</p>
<p><img src="/../images/IMG_AC502EFCC7B2-1.jpeg" alt="IMG_AC502EFCC7B2-1"></p>
<p>（混进去了兰亭序。。。）</p>
<p>用多邻国学了粤语，感觉实在没学到啥东西</p>
<img src="../images/E74FE849-81BC-4C31-ADF7-2405673FB3C5_1_105_c.jpeg" alt="E74FE849-81BC-4C31-ADF7-2405673FB3C5_1_105_c">

<p>重拾了吉他，还粗略地学习了一下音阶，没图就不放了。</p>
<p>2024打算再系统学习一下乐理知识和电钢琴，目前要说的流水账就这些。</p>
]]></content>
  </entry>
</search>
