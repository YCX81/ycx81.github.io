<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"ycx81.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":true,"version":"8.17.1","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"disqus","storage":true,"lazyload":false,"nav":{"disqus":{"text":"Disqus","order":-2}}},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="前言">
<meta property="og:type" content="article">
<meta property="og:title" content="Qt C++语言进阶详解">
<meta property="og:url" content="http://ycx81.github.io/2024/12/26/Qt-C-%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6%E8%AF%A6%E8%A7%A3/index.html">
<meta property="og:site_name" content="YCX-Blog">
<meta property="og:description" content="前言">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-12-26T13:30:42.000Z">
<meta property="article:modified_time" content="2024-12-26T13:30:50.673Z">
<meta property="article:author" content="YCX">
<meta property="article:tag" content="　&#39;blog&#39;">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://ycx81.github.io/2024/12/26/Qt-C-%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6%E8%AF%A6%E8%A7%A3/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://ycx81.github.io/2024/12/26/Qt-C-%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6%E8%AF%A6%E8%A7%A3/","path":"2024/12/26/Qt-C-语言进阶详解/","title":"Qt C++语言进阶详解"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Qt C++语言进阶详解 | YCX-Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">YCX-Blog</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">YCX的个人博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a></li><li class="menu-item menu-item-commonweal"><a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Qt-C-%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6%E8%AF%A6%E8%A7%A3"><span class="nav-number">2.</span> <span class="nav-text">Qt C++语言进阶详解</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%8D%95%E7%BB%A7%E6%89%BF%EF%BC%88Single-Inheritance%EF%BC%89"><span class="nav-number">2.1.</span> <span class="nav-text">1. 单继承（Single Inheritance）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E5%8D%95%E7%BB%A7%E6%89%BF%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">2.1.1.</span> <span class="nav-text">1.1 单继承的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E5%8D%95%E7%BB%A7%E6%89%BF%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="nav-number">2.1.2.</span> <span class="nav-text">1.2 单继承的实现方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E5%8D%95%E7%BB%A7%E6%89%BF%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">2.1.3.</span> <span class="nav-text">1.3 单继承的应用场景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%A4%9A%E7%BB%A7%E6%89%BF%EF%BC%88Multiple-Inheritance%EF%BC%89"><span class="nav-number">2.2.</span> <span class="nav-text">2. 多继承（Multiple Inheritance）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E5%A4%9A%E7%BB%A7%E6%89%BF%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">2.2.1.</span> <span class="nav-text">2.1 多继承的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E5%A4%9A%E7%BB%A7%E6%89%BF%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="nav-number">2.2.2.</span> <span class="nav-text">2.2 多继承的实现方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E5%A4%9A%E7%BB%A7%E6%89%BF%E7%9A%84%E4%BC%98%E7%82%B9"><span class="nav-number">2.2.3.</span> <span class="nav-text">2.3 多继承的优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-%E5%A4%9A%E7%BB%A7%E6%89%BF%E7%9A%84%E6%BD%9C%E5%9C%A8%E9%97%AE%E9%A2%98"><span class="nav-number">2.2.4.</span> <span class="nav-text">2.4 多继承的潜在问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-1-%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF%EF%BC%88Diamond-Inheritance%EF%BC%89"><span class="nav-number">2.2.4.1.</span> <span class="nav-text">2.4.1 菱形继承（Diamond Inheritance）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-2-%E4%BA%8C%E4%B9%89%E6%80%A7%E9%97%AE%E9%A2%98"><span class="nav-number">2.2.4.2.</span> <span class="nav-text">2.4.2 二义性问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-%E5%A4%9A%E7%BB%A7%E6%89%BF%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-number">2.2.5.</span> <span class="nav-text">2.5 多继承的最佳实践</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E8%99%9A%E7%BB%A7%E6%89%BF%E5%8F%8A%E5%85%B6%E4%BB%96%E7%89%B9%E6%80%A7%EF%BC%88Virtual-Inheritance-and-Other-Features%EF%BC%89"><span class="nav-number">2.3.</span> <span class="nav-text">3. 虚继承及其他特性（Virtual Inheritance and Other Features）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E8%99%9A%E7%BB%A7%E6%89%BF%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">2.3.1.</span> <span class="nav-text">3.1 虚继承的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E8%99%9A%E7%BB%A7%E6%89%BF%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="nav-number">2.3.2.</span> <span class="nav-text">3.2 虚继承的实现方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E5%85%B6%E4%BB%96%E9%AB%98%E7%BA%A7%E7%BB%A7%E6%89%BF%E7%89%B9%E6%80%A7"><span class="nav-number">2.3.3.</span> <span class="nav-text">3.3 其他高级继承特性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-1-%E5%A4%9A%E7%BA%A7%E7%BB%A7%E6%89%BF%EF%BC%88Multilevel-Inheritance%EF%BC%89"><span class="nav-number">2.3.3.1.</span> <span class="nav-text">3.3.1 多级继承（Multilevel Inheritance）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-2-%E8%99%9A%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E7%BA%A7%E7%BB%A7%E6%89%BF%E7%9A%84%E7%BB%93%E5%90%88"><span class="nav-number">2.3.3.2.</span> <span class="nav-text">3.3.2 虚继承与多级继承的结合</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E8%99%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB%EF%BC%88Virtual-Functions-and-Abstract-Classes%EF%BC%89"><span class="nav-number">2.4.</span> <span class="nav-text">4. 虚函数与抽象类（Virtual Functions and Abstract Classes）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">2.4.1.</span> <span class="nav-text">4.1 虚函数的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="nav-number">2.4.2.</span> <span class="nav-text">4.2 虚函数的实现与使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E7%94%A8%E9%80%94"><span class="nav-number">2.4.3.</span> <span class="nav-text">4.3 抽象类的定义与用途</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-1-%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="nav-number">2.4.3.1.</span> <span class="nav-text">4.3.1 纯虚函数的声明</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-%E5%A4%9A%E6%80%81%E6%80%A7%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8E%E5%BA%94%E7%94%A8"><span class="nav-number">2.4.4.</span> <span class="nav-text">4.4 多态性的实现与应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">2.4.5.</span> <span class="nav-text">4.5 抽象类的应用场景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E4%B8%8E%E6%A8%A1%E6%9D%BF%EF%BC%88Namespaces-and-Templates%EF%BC%89"><span class="nav-number">2.5.</span> <span class="nav-text">5. 命名空间与模板（Namespaces and Templates）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%EF%BC%88Namespaces%EF%BC%89"><span class="nav-number">2.5.1.</span> <span class="nav-text">5.1 命名空间（Namespaces）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-1-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">2.5.1.1.</span> <span class="nav-text">5.1.1 命名空间的概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-2-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="nav-number">2.5.1.2.</span> <span class="nav-text">5.1.2 命名空间的定义与使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-3-%E4%BD%BF%E7%94%A8using%E5%A3%B0%E6%98%8E"><span class="nav-number">2.5.1.3.</span> <span class="nav-text">5.1.3 使用using声明</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-%E6%A8%A1%E6%9D%BF%EF%BC%88Templates%EF%BC%89"><span class="nav-number">2.5.2.</span> <span class="nav-text">5.2 模板（Templates）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-1-%E6%A8%A1%E6%9D%BF%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">2.5.2.1.</span> <span class="nav-text">5.2.1 模板的概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-2-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="nav-number">2.5.2.2.</span> <span class="nav-text">5.2.2 函数模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-3-%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="nav-number">2.5.2.3.</span> <span class="nav-text">5.2.3 类模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-4-%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%8C%96"><span class="nav-number">2.5.2.4.</span> <span class="nav-text">5.2.4 模板特化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-%E6%80%BB%E7%BB%93"><span class="nav-number">2.5.3.</span> <span class="nav-text">5.3 总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-C-IO%E6%B5%81%E7%B1%BB%E5%BA%93%EF%BC%88C-IO-Stream-Library%EF%BC%89"><span class="nav-number">2.6.</span> <span class="nav-text">6. C++ IO流类库（C++ IO Stream Library）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-IO%E6%B5%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">2.6.1.</span> <span class="nav-text">6.1 IO流的基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.6.2.</span> <span class="nav-text">6.2 输入输出流对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-%E4%BD%BF%E7%94%A8std-cin%E5%92%8Cstd-cout"><span class="nav-number">2.6.3.</span> <span class="nav-text">6.3 使用std::cin和std::cout</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%EF%BC%88File-I-x2F-O%EF%BC%89"><span class="nav-number">2.6.4.</span> <span class="nav-text">6.4 文件输入输出（File I&#x2F;O）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-4-1-%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6"><span class="nav-number">2.6.4.1.</span> <span class="nav-text">6.4.1 写入文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-4-2-%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6"><span class="nav-number">2.6.4.2.</span> <span class="nav-text">6.4.2 读取文件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-%E5%85%B6%E4%BB%96IO%E6%B5%81%E5%8A%9F%E8%83%BD"><span class="nav-number">2.6.5.</span> <span class="nav-text">6.5 其他IO流功能</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-5-1-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA"><span class="nav-number">2.6.5.1.</span> <span class="nav-text">6.5.1 格式化输出</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-6-%E6%80%BB%E7%BB%93"><span class="nav-number">2.6.6.</span> <span class="nav-text">6.6 总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93%EF%BC%88STL%EF%BC%89%E2%80%94%E2%80%94vector%E3%80%81deque%E4%B8%8Estack"><span class="nav-number">2.7.</span> <span class="nav-text">7. 标准模板库（STL）——vector、deque与stack</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-vector"><span class="nav-number">2.7.1.</span> <span class="nav-text">7.1 vector</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#7-1-1-vector%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">2.7.1.1.</span> <span class="nav-text">7.1.1 vector的概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-1-2-vector%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="nav-number">2.7.1.2.</span> <span class="nav-text">7.1.2 vector的基本用法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-1-3-vector%E7%9A%84%E9%AB%98%E7%BA%A7%E6%93%8D%E4%BD%9C"><span class="nav-number">2.7.1.3.</span> <span class="nav-text">7.1.3 vector的高级操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-deque"><span class="nav-number">2.7.2.</span> <span class="nav-text">7.2 deque</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#7-2-1-deque%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">2.7.2.1.</span> <span class="nav-text">7.2.1 deque的概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-2-2-deque%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="nav-number">2.7.2.2.</span> <span class="nav-text">7.2.2 deque的基本用法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-2-3-deque%E7%9A%84%E9%AB%98%E7%BA%A7%E6%93%8D%E4%BD%9C"><span class="nav-number">2.7.2.3.</span> <span class="nav-text">7.2.3 deque的高级操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-stack"><span class="nav-number">2.7.3.</span> <span class="nav-text">7.3 stack</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#7-3-1-stack%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">2.7.3.1.</span> <span class="nav-text">7.3.1 stack的概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-3-2-stack%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="nav-number">2.7.3.2.</span> <span class="nav-text">7.3.2 stack的基本用法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-3-3-stack%E7%9A%84%E9%99%90%E5%88%B6"><span class="nav-number">2.7.3.3.</span> <span class="nav-text">7.3.3 stack的限制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-4-%E6%80%BB%E7%BB%93"><span class="nav-number">2.7.4.</span> <span class="nav-text">7.4 总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93%EF%BC%88STL%EF%BC%89%E2%80%94%E2%80%94queue%E3%80%81set%E4%B8%8Emap"><span class="nav-number">2.8.</span> <span class="nav-text">8. 标准模板库（STL）——queue、set与map</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1-queue"><span class="nav-number">2.8.1.</span> <span class="nav-text">8.1 queue</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#8-1-1-queue%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">2.8.1.1.</span> <span class="nav-text">8.1.1 queue的概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-1-2-queue%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="nav-number">2.8.1.2.</span> <span class="nav-text">8.1.2 queue的基本用法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-1-3-queue%E7%9A%84%E9%AB%98%E7%BA%A7%E6%93%8D%E4%BD%9C"><span class="nav-number">2.8.1.3.</span> <span class="nav-text">8.1.3 queue的高级操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-set"><span class="nav-number">2.8.2.</span> <span class="nav-text">8.2 set</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#8-2-1-set%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">2.8.2.1.</span> <span class="nav-text">8.2.1 set的概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-2-2-set%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="nav-number">2.8.2.2.</span> <span class="nav-text">8.2.2 set的基本用法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-2-3-set%E7%9A%84%E9%AB%98%E7%BA%A7%E6%93%8D%E4%BD%9C"><span class="nav-number">2.8.2.3.</span> <span class="nav-text">8.2.3 set的高级操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-3-map"><span class="nav-number">2.8.3.</span> <span class="nav-text">8.3 map</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#8-3-1-map%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">2.8.3.1.</span> <span class="nav-text">8.3.1 map的概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-3-2-map%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="nav-number">2.8.3.2.</span> <span class="nav-text">8.3.2 map的基本用法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-3-3-map%E7%9A%84%E9%AB%98%E7%BA%A7%E6%93%8D%E4%BD%9C"><span class="nav-number">2.8.3.3.</span> <span class="nav-text">8.3.3 map的高级操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-4-%E6%80%BB%E7%BB%93"><span class="nav-number">2.8.4.</span> <span class="nav-text">8.4 总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-C-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%EF%BC%88Exception-Handling%EF%BC%89"><span class="nav-number">2.9.</span> <span class="nav-text">9. C++异常处理（Exception Handling）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#9-1-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">2.9.1.</span> <span class="nav-text">9.1 异常处理的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-2-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="nav-number">2.9.2.</span> <span class="nav-text">9.2 异常处理的基本语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-3-%E4%BD%BF%E7%94%A8try%E3%80%81catch%E5%92%8Cthrow"><span class="nav-number">2.9.3.</span> <span class="nav-text">9.3 使用try、catch和throw</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-4-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E7%B1%BB"><span class="nav-number">2.9.4.</span> <span class="nav-text">9.4 自定义异常类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-5-%E5%BC%82%E5%B8%B8%E5%AE%89%E5%85%A8%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-number">2.9.5.</span> <span class="nav-text">9.5 异常安全性与最佳实践</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-6-%E6%80%BB%E7%BB%93"><span class="nav-number">2.9.6.</span> <span class="nav-text">9.6 总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">2.10.</span> <span class="nav-text">总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E5%86%85%E5%AE%B9%E5%9B%9E%E9%A1%BE%EF%BC%9A"><span class="nav-number">2.10.1.</span> <span class="nav-text">主要内容回顾：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8B%E4%B8%80%E6%AD%A5%E5%AD%A6%E4%B9%A0%E5%BB%BA%E8%AE%AE%EF%BC%9A"><span class="nav-number">2.10.2.</span> <span class="nav-text">下一步学习建议：</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="YCX"
      src="/images/avatar1.jpg">
  <p class="site-author-name" itemprop="name">YCX</p>
  <div class="site-description" itemprop="description">YCX的个人博客，每日(不一定)更新</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">20</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ycx81.github.io/2024/12/26/Qt-C-%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.jpg">
      <meta itemprop="name" content="YCX">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YCX-Blog">
      <meta itemprop="description" content="YCX的个人博客，每日(不一定)更新">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Qt C++语言进阶详解 | YCX-Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Qt C++语言进阶详解
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-12-26 21:30:42" itemprop="dateCreated datePublished" datetime="2024-12-26T21:30:42+08:00">2024-12-26</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>11k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>40 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><span id="more"></span>

<h1 id="Qt-C-语言进阶详解"><a href="#Qt-C-语言进阶详解" class="headerlink" title="Qt C++语言进阶详解"></a>Qt C++语言进阶详解</h1><p>在掌握了Qt C++语言编程的基础知识后，进一步深入C++的高级特性是提升编程能力的关键。本篇文章将详细介绍Qt C++语言编程进阶的多个重要知识点，包括单继承、多继承、虚继承及其他特性、虚函数与抽象类、命名空间与模板等。这些内容不仅能够帮助您更好地理解C++的面向对象编程（OOP）理念，还能为后续学习Qt框架打下坚实的基础。</p>
<hr>
<h2 id="1-单继承（Single-Inheritance）"><a href="#1-单继承（Single-Inheritance）" class="headerlink" title="1. 单继承（Single Inheritance）"></a>1. 单继承（Single Inheritance）</h2><h3 id="1-1-单继承的概念"><a href="#1-1-单继承的概念" class="headerlink" title="1.1 单继承的概念"></a>1.1 单继承的概念</h3><p>单继承是指一个派生类仅继承自一个基类。这是C++中最基本的继承形式，通过单继承，可以实现代码的复用和类层次结构的构建。</p>
<h3 id="1-2-单继承的实现方式"><a href="#1-2-单继承的实现方式" class="headerlink" title="1.2 单继承的实现方式"></a>1.2 单继承的实现方式</h3><p>在C++中，单继承通过在类定义中使用冒号（<code>:</code>）和继承访问控制符（<code>public</code>、<code>protected</code>或<code>private</code>）来实现。常用的继承方式是公共继承（<code>public</code>），它确保基类的<code>public</code>和<code>protected</code>成员在派生类中保持其访问权限。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Animal</span>(<span class="type">const</span> std::string&amp; name) : <span class="built_in">name_</span>(name) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; name_ &lt;&lt; <span class="string">&quot; is eating.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::string name_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Dog</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> std::string&amp; breed)</span><br><span class="line">        : <span class="built_in">Animal</span>(name), <span class="built_in">breed_</span>(breed) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bark</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; name_ &lt;&lt; <span class="string">&quot; the &quot;</span> &lt;&lt; breed_ &lt;&lt; <span class="string">&quot; is barking.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string breed_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Dog <span class="title">myDog</span><span class="params">(<span class="string">&quot;Buddy&quot;</span>, <span class="string">&quot;Golden Retriever&quot;</span>)</span></span>;</span><br><span class="line">    myDog.<span class="built_in">eat</span>();  <span class="comment">// 调用基类的成员函数</span></span><br><span class="line">    myDog.<span class="built_in">bark</span>(); <span class="comment">// 调用派生类的成员函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Buddy is eating.</span><br><span class="line">Buddy the Golden Retriever is barking.</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>Animal</code>类是基类，包含一个公有成员函数<code>eat</code>和一个受保护的成员变量<code>name_</code>。</li>
<li><code>Dog</code>类是派生类，使用<code>public</code>继承自<code>Animal</code>，并添加了一个新的成员函数<code>bark</code>和一个私有成员变量<code>breed_</code>。</li>
<li>在<code>main</code>函数中，通过<code>Dog</code>类的实例<code>myDog</code>可以调用基类<code>Animal</code>的<code>eat</code>函数以及派生类<code>Dog</code>的<code>bark</code>函数，实现了代码的复用和功能的扩展。</li>
</ul>
<h3 id="1-3-单继承的应用场景"><a href="#1-3-单继承的应用场景" class="headerlink" title="1.3 单继承的应用场景"></a>1.3 单继承的应用场景</h3><p>单继承适用于简单的类层次结构，当一个类只需要继承自另一个类时，单继承能够有效地组织代码，提升可读性和维护性。例如：</p>
<ul>
<li><strong>动物分类</strong>：<code>Animal</code>（基类）→ <code>Dog</code>、<code>Cat</code>（派生类）</li>
<li><strong>图形形状</strong>：<code>Shape</code>（基类）→ <code>Circle</code>、<code>Rectangle</code>（派生类）</li>
</ul>
<p>单继承能够清晰地表达类之间的“是一个”关系，符合面向对象设计的基本原则。</p>
<hr>
<h2 id="2-多继承（Multiple-Inheritance）"><a href="#2-多继承（Multiple-Inheritance）" class="headerlink" title="2. 多继承（Multiple Inheritance）"></a>2. 多继承（Multiple Inheritance）</h2><h3 id="2-1-多继承的概念"><a href="#2-1-多继承的概念" class="headerlink" title="2.1 多继承的概念"></a>2.1 多继承的概念</h3><p>多继承是指一个派生类同时继承自多个基类。这使得派生类能够组合多个基类的功能，实现更为复杂和灵活的类层次结构。然而，多继承也带来了一些潜在的问题，如菱形继承导致的二义性。</p>
<h3 id="2-2-多继承的实现方式"><a href="#2-2-多继承的实现方式" class="headerlink" title="2.2 多继承的实现方式"></a>2.2 多继承的实现方式</h3><p>在C++中，多继承通过在类定义中列出多个基类，并用逗号分隔它们来实现。每个基类可以有不同的继承访问控制符。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Flyer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fly</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Flying in the sky.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Swimmer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swim</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Swimming in the water.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类，多继承自Flyer和Swimmer</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Duck</span> : <span class="keyword">public</span> Flyer, <span class="keyword">public</span> Swimmer &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">quack</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Quack quack!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Duck daffy;</span><br><span class="line">    daffy.<span class="built_in">fly</span>();    <span class="comment">// 调用Flyer的成员函数</span></span><br><span class="line">    daffy.<span class="built_in">swim</span>();   <span class="comment">// 调用Swimmer的成员函数</span></span><br><span class="line">    daffy.<span class="built_in">quack</span>();  <span class="comment">// 调用Duck的成员函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Flying in the sky.</span><br><span class="line">Swimming in the water.</span><br><span class="line">Quack quack!</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>Flyer</code>和<code>Swimmer</code>是两个独立的基类，分别提供<code>fly</code>和<code>swim</code>功能。</li>
<li><code>Duck</code>类通过<code>public</code>多继承自<code>Flyer</code>和<code>Swimmer</code>，因此<code>Duck</code>类的对象可以同时调用两个基类的成员函数。</li>
<li>这种方式实现了功能的组合，使得<code>Duck</code>类具备飞行和游泳的能力。</li>
</ul>
<h3 id="2-3-多继承的优点"><a href="#2-3-多继承的优点" class="headerlink" title="2.3 多继承的优点"></a>2.3 多继承的优点</h3><ul>
<li><strong>功能组合</strong>：通过多继承，派生类可以组合多个基类的功能，避免重复代码。</li>
<li><strong>灵活性</strong>：多继承提供了更高的灵活性，允许类以多种方式组合和扩展功能。</li>
<li><strong>模型表达力增强</strong>：能够更准确地表达现实世界中事物的多重特性。</li>
</ul>
<h3 id="2-4-多继承的潜在问题"><a href="#2-4-多继承的潜在问题" class="headerlink" title="2.4 多继承的潜在问题"></a>2.4 多继承的潜在问题</h3><p>尽管多继承带来了功能的强大组合，但也引入了一些复杂性和潜在问题，主要包括：</p>
<h4 id="2-4-1-菱形继承（Diamond-Inheritance）"><a href="#2-4-1-菱形继承（Diamond-Inheritance）" class="headerlink" title="2.4.1 菱形继承（Diamond Inheritance）"></a>2.4.1 菱形继承（Diamond Inheritance）</h4><p>菱形继承是多继承中最常见的问题之一，指的是一个派生类通过多个路径继承自同一个基类，导致基类的成员出现二义性。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Animal is eating.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mammal</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类，多继承自Mammal和Bird</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bat</span> : <span class="keyword">public</span> Mammal, <span class="keyword">public</span> Bird &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fly</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Bat is flying.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Bat bat;</span><br><span class="line">    <span class="comment">// bat.eat(); // 编译错误，二义性</span></span><br><span class="line">    bat.Mammal::<span class="built_in">eat</span>(); <span class="comment">// 指定调用Mammal路径的eat</span></span><br><span class="line">    bat.Bird::<span class="built_in">eat</span>();    <span class="comment">// 指定调用Bird路径的eat</span></span><br><span class="line">    bat.<span class="built_in">fly</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Animal is eating.</span><br><span class="line">Animal is eating.</span><br><span class="line">Bat is flying.</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>Bat</code>类通过<code>Mammal</code>和<code>Bird</code>两个路径继承自<code>Animal</code>类，导致<code>Bat</code>类中存在两个<code>Animal</code>类的子对象。</li>
<li>当尝试调用<code>bat.eat()</code>时，编译器无法确定调用哪个<code>Animal::eat()</code>版本，导致二义性错误。</li>
<li>需要明确指定调用哪个基类路径的成员函数，如<code>bat.Mammal::eat()</code>或<code>bat.Bird::eat()</code>。</li>
</ul>
<h4 id="2-4-2-二义性问题"><a href="#2-4-2-二义性问题" class="headerlink" title="2.4.2 二义性问题"></a>2.4.2 二义性问题</h4><p>除了菱形继承，其他多继承场景中也可能出现二义性问题，如不同基类中存在同名成员函数或变量时，派生类需要明确指定访问哪个基类的成员。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base1 show()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base2 show()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类，多继承自Base1和Base2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// show(); // 编译错误，二义性</span></span><br><span class="line">        Base1::<span class="built_in">show</span>(); <span class="comment">// 指定调用Base1的show</span></span><br><span class="line">        Base2::<span class="built_in">show</span>(); <span class="comment">// 指定调用Base2的show</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derived obj;</span><br><span class="line">    obj.<span class="built_in">display</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Base1 show()</span><br><span class="line">Base2 show()</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>Derived</code>类继承自<code>Base1</code>和<code>Base2</code>，两者都定义了<code>show</code>成员函数。</li>
<li>调用<code>show()</code>时，编译器无法确定应调用哪个基类的<code>show</code>函数，导致二义性错误。</li>
<li>需要明确指定调用哪个基类的<code>show</code>函数，如<code>Base1::show()</code>或<code>Base2::show()</code>。</li>
</ul>
<h3 id="2-5-多继承的最佳实践"><a href="#2-5-多继承的最佳实践" class="headerlink" title="2.5 多继承的最佳实践"></a>2.5 多继承的最佳实践</h3><p>为了避免多继承带来的复杂性和潜在问题，以下是一些最佳实践：</p>
<ol>
<li><strong>优先使用组合而非继承</strong>：在可能的情况下，优先选择组合（对象内部包含另一个对象）而非继承，以降低类之间的耦合度。</li>
<li><strong>明确类层次结构</strong>：设计清晰的类层次结构，避免不必要的多继承，特别是菱形继承。</li>
<li><strong>使用虚继承解决菱形继承</strong>：当必须使用多继承且存在菱形继承时，采用虚继承来共享基类的单一实例，避免二义性。</li>
<li><strong>避免同名成员</strong>：尽量避免不同基类中存在同名成员函数或变量，减少二义性问题。</li>
<li><strong>合理使用访问控制符</strong>：合理选择继承的访问控制符（<code>public</code>、<code>protected</code>、<code>private</code>），控制基类成员在派生类中的可见性。</li>
</ol>
<hr>
<h2 id="3-虚继承及其他特性（Virtual-Inheritance-and-Other-Features）"><a href="#3-虚继承及其他特性（Virtual-Inheritance-and-Other-Features）" class="headerlink" title="3. 虚继承及其他特性（Virtual Inheritance and Other Features）"></a>3. 虚继承及其他特性（Virtual Inheritance and Other Features）</h2><h3 id="3-1-虚继承的概念"><a href="#3-1-虚继承的概念" class="headerlink" title="3.1 虚继承的概念"></a>3.1 虚继承的概念</h3><p>虚继承是一种C++中的继承机制，用于解决多继承中菱形继承带来的二义性问题。通过虚继承，派生类共享同一个基类的实例，避免了多个基类子对象的出现。</p>
<h3 id="3-2-虚继承的实现方式"><a href="#3-2-虚继承的实现方式" class="headerlink" title="3.2 虚继承的实现方式"></a>3.2 虚继承的实现方式</h3><p>在C++中，使用<code>virtual</code>关键字在继承时指定虚继承。具体来说，在派生类继承基类时，使用<code>virtual</code>关键字修饰基类名。</p>
<p><strong>示例：解决菱形继承的二义性问题</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Animal</span>(<span class="type">const</span> std::string&amp; name) : <span class="built_in">name_</span>(name) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; name_ &lt;&lt; <span class="string">&quot; is eating.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::string name_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 虚继承基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mammal</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Mammal</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> std::string&amp; furColor)</span><br><span class="line">        : <span class="built_in">Animal</span>(name), <span class="built_in">furColor_</span>(furColor) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showFur</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; name_ &lt;&lt; <span class="string">&quot; has &quot;</span> &lt;&lt; furColor_ &lt;&lt; <span class="string">&quot; fur.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string furColor_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 虚继承基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Bird</span>(<span class="type">const</span> std::string&amp; name, <span class="type">double</span> wingSpan)</span><br><span class="line">        : <span class="built_in">Animal</span>(name), <span class="built_in">wingSpan_</span>(wingSpan) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showWings</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; name_ &lt;&lt; <span class="string">&quot; has a wingspan of &quot;</span> &lt;&lt; wingSpan_ &lt;&lt; <span class="string">&quot; meters.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> wingSpan_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类，多继承自Mammal和Bird</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bat</span> : <span class="keyword">public</span> Mammal, <span class="keyword">public</span> Bird &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Bat</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> std::string&amp; furColor, <span class="type">double</span> wingSpan, <span class="type">bool</span> echolocation)</span><br><span class="line">        : <span class="built_in">Animal</span>(name), <span class="built_in">Mammal</span>(name, furColor), <span class="built_in">Bird</span>(name, wingSpan), <span class="built_in">echolocation_</span>(echolocation) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">eat</span>();           <span class="comment">// 唯一的Animal::eat()</span></span><br><span class="line">        <span class="built_in">showFur</span>();</span><br><span class="line">        <span class="built_in">showWings</span>();</span><br><span class="line">        std::cout &lt;&lt; name_ &lt;&lt; <span class="string">&quot; uses &quot;</span> &lt;&lt; (echolocation_ ? <span class="string">&quot;echolocation.&quot;</span> : <span class="string">&quot;other navigation methods.&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">bool</span> echolocation_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Bat <span class="title">bat</span><span class="params">(<span class="string">&quot;Bruce&quot;</span>, <span class="string">&quot;brown&quot;</span>, <span class="number">1.5</span>, <span class="literal">true</span>)</span></span>;</span><br><span class="line">    bat.<span class="built_in">display</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Bruce is eating.</span><br><span class="line">Bruce has brown fur.</span><br><span class="line">Bruce has a wingspan of 1.5 meters.</span><br><span class="line">Bruce uses echolocation.</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>Mammal</code>和<code>Bird</code>类通过<code>virtual</code>关键字虚继承自<code>Animal</code>类，确保<code>Bat</code>类中只有一个<code>Animal</code>基类子对象。</li>
<li>在<code>Bat</code>类的构造函数中，必须显式调用<code>Animal</code>类的构造函数，以初始化共享的<code>Animal</code>子对象。</li>
<li>通过虚继承，<code>Bat</code>类能够避免菱形继承带来的二义性问题，<code>eat</code>函数调用变得明确且无歧义。</li>
</ul>
<h3 id="3-3-其他高级继承特性"><a href="#3-3-其他高级继承特性" class="headerlink" title="3.3 其他高级继承特性"></a>3.3 其他高级继承特性</h3><p>除了虚继承，C++还提供了其他一些高级继承特性，以增强类层次结构的表达能力和灵活性。</p>
<h4 id="3-3-1-多级继承（Multilevel-Inheritance）"><a href="#3-3-1-多级继承（Multilevel-Inheritance）" class="headerlink" title="3.3.1 多级继承（Multilevel Inheritance）"></a>3.3.1 多级继承（Multilevel Inheritance）</h4><p>多级继承是指一个派生类继承自另一个派生类，形成一个继承链。它有助于构建更为复杂和有层次的类结构。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Vehicle</span>(<span class="type">const</span> std::string&amp; brand) : <span class="built_in">brand_</span>(brand) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">honk</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; brand_ &lt;&lt; <span class="string">&quot; vehicle is honking.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::string brand_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> : <span class="keyword">public</span> Vehicle &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Car</span>(<span class="type">const</span> std::string&amp; brand, <span class="type">int</span> doors)</span><br><span class="line">        : <span class="built_in">Vehicle</span>(brand), <span class="built_in">doors_</span>(doors) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">displayDoors</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; brand_ &lt;&lt; <span class="string">&quot; car has &quot;</span> &lt;&lt; doors_ &lt;&lt; <span class="string">&quot; doors.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> doors_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类2，多级继承自Car</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ElectricCar</span> : <span class="keyword">public</span> Car &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ElectricCar</span>(<span class="type">const</span> std::string&amp; brand, <span class="type">int</span> doors, <span class="type">double</span> batteryCapacity)</span><br><span class="line">        : <span class="built_in">Car</span>(brand, doors), <span class="built_in">batteryCapacity_</span>(batteryCapacity) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">displayBattery</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; brand_ &lt;&lt; <span class="string">&quot; electric car has a battery capacity of &quot;</span> &lt;&lt; batteryCapacity_ &lt;&lt; <span class="string">&quot; kWh.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> batteryCapacity_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ElectricCar <span class="title">tesla</span><span class="params">(<span class="string">&quot;Tesla&quot;</span>, <span class="number">4</span>, <span class="number">75.0</span>)</span></span>;</span><br><span class="line">    tesla.<span class="built_in">honk</span>();</span><br><span class="line">    tesla.<span class="built_in">displayDoors</span>();</span><br><span class="line">    tesla.<span class="built_in">displayBattery</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Tesla vehicle is honking.</span><br><span class="line">Tesla car has 4 doors.</span><br><span class="line">Tesla electric car has a battery capacity of 75 kWh.</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>ElectricCar</code>类通过多级继承从<code>Car</code>继承，<code>Car</code>又从<code>Vehicle</code>继承。</li>
<li>这种继承方式形成了一个清晰的层次结构，<code>ElectricCar</code>不仅拥有<code>Car</code>的属性和行为，还继承了<code>Vehicle</code>的功能。</li>
</ul>
<h4 id="3-3-2-虚继承与多级继承的结合"><a href="#3-3-2-虚继承与多级继承的结合" class="headerlink" title="3.3.2 虚继承与多级继承的结合"></a>3.3.2 虚继承与多级继承的结合</h4><p>在多级继承中，如果存在菱形继承关系，同样需要使用虚继承来避免二义性问题。通过合理设计继承关系，可以构建稳定且高效的类层次结构。</p>
<hr>
<h2 id="4-虚函数与抽象类（Virtual-Functions-and-Abstract-Classes）"><a href="#4-虚函数与抽象类（Virtual-Functions-and-Abstract-Classes）" class="headerlink" title="4. 虚函数与抽象类（Virtual Functions and Abstract Classes）"></a>4. 虚函数与抽象类（Virtual Functions and Abstract Classes）</h2><h3 id="4-1-虚函数的概念"><a href="#4-1-虚函数的概念" class="headerlink" title="4.1 虚函数的概念"></a>4.1 虚函数的概念</h3><p>虚函数是基类中声明为<code>virtual</code>的成员函数，允许派生类对其进行重写（Override）。通过虚函数，可以实现多态性，使得基类指针或引用能够调用派生类的重写函数。</p>
<h3 id="4-2-虚函数的实现与使用"><a href="#4-2-虚函数的实现与使用" class="headerlink" title="4.2 虚函数的实现与使用"></a>4.2 虚函数的实现与使用</h3><p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Shape</span>(<span class="type">const</span> std::string&amp; name) : <span class="built_in">name_</span>(name) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a generic shape.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Shape</span>() = <span class="keyword">default</span>; <span class="comment">// 虚析构函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::string name_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Circle</span>(<span class="type">double</span> radius) : <span class="built_in">Shape</span>(<span class="string">&quot;Circle&quot;</span>), <span class="built_in">radius_</span>(radius) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a circle with radius &quot;</span> &lt;&lt; radius_ &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> radius_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rectangle</span>(<span class="type">double</span> width, <span class="type">double</span> height)</span><br><span class="line">        : <span class="built_in">Shape</span>(<span class="string">&quot;Rectangle&quot;</span>), <span class="built_in">width_</span>(width), <span class="built_in">height_</span>(height) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a rectangle with width &quot;</span> &lt;&lt; width_</span><br><span class="line">                  &lt;&lt; <span class="string">&quot; and height &quot;</span> &lt;&lt; height_ &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> width_;</span><br><span class="line">    <span class="type">double</span> height_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Shape* shape1 = <span class="keyword">new</span> <span class="built_in">Circle</span>(<span class="number">5.0</span>);</span><br><span class="line">    Shape* shape2 = <span class="keyword">new</span> <span class="built_in">Rectangle</span>(<span class="number">4.0</span>, <span class="number">6.0</span>);</span><br><span class="line"></span><br><span class="line">    shape1-&gt;<span class="built_in">draw</span>(); <span class="comment">// 调用Circle的draw</span></span><br><span class="line">    shape2-&gt;<span class="built_in">draw</span>(); <span class="comment">// 调用Rectangle的draw</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> shape1;</span><br><span class="line">    <span class="keyword">delete</span> shape2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Drawing a circle with radius 5.</span><br><span class="line">Drawing a rectangle with width 4 and height 6.</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>Shape</code>类中声明了一个虚函数<code>draw</code>，并在派生类<code>Circle</code>和<code>Rectangle</code>中进行了重写。</li>
<li>在<code>main</code>函数中，通过基类指针<code>shape1</code>和<code>shape2</code>指向派生类对象，调用<code>draw</code>函数时，实际执行的是派生类中重写的版本，实现了运行时多态性。</li>
<li>虚析构函数确保在删除基类指针指向的派生类对象时，正确调用派生类的析构函数，防止资源泄漏。</li>
</ul>
<h3 id="4-3-抽象类的定义与用途"><a href="#4-3-抽象类的定义与用途" class="headerlink" title="4.3 抽象类的定义与用途"></a>4.3 抽象类的定义与用途</h3><p>抽象类是包含至少一个纯虚函数（Pure Virtual Function）的类，不能被实例化，只能作为基类使用。抽象类定义了接口规范，派生类必须实现这些纯虚函数，才能被实例化。</p>
<h4 id="4-3-1-纯虚函数的声明"><a href="#4-3-1-纯虚函数的声明" class="headerlink" title="4.3.1 纯虚函数的声明"></a>4.3.1 纯虚函数的声明</h4><p>纯虚函数通过在函数声明后加上<code>= 0</code>来表示。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractShape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AbstractShape</span>(<span class="type">const</span> std::string&amp; name) : <span class="built_in">name_</span>(name) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 纯虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">AbstractShape</span>() = <span class="keyword">default</span>; <span class="comment">// 虚析构函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::string name_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Triangle</span> : <span class="keyword">public</span> AbstractShape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Triangle</span>(<span class="type">double</span> base, <span class="type">double</span> height)</span><br><span class="line">        : <span class="built_in">AbstractShape</span>(<span class="string">&quot;Triangle&quot;</span>), <span class="built_in">base_</span>(base), <span class="built_in">height_</span>(height) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a triangle with base &quot;</span> &lt;&lt; base_</span><br><span class="line">                  &lt;&lt; <span class="string">&quot; and height &quot;</span> &lt;&lt; height_ &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> base_;</span><br><span class="line">    <span class="type">double</span> height_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span> : <span class="keyword">public</span> AbstractShape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Square</span>(<span class="type">double</span> side) : <span class="built_in">AbstractShape</span>(<span class="string">&quot;Square&quot;</span>), <span class="built_in">side_</span>(side) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a square with side &quot;</span> &lt;&lt; side_ &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> side_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// AbstractShape shape; // 错误，无法实例化抽象类</span></span><br><span class="line"></span><br><span class="line">    AbstractShape* shape1 = <span class="keyword">new</span> <span class="built_in">Triangle</span>(<span class="number">3.0</span>, <span class="number">4.0</span>);</span><br><span class="line">    AbstractShape* shape2 = <span class="keyword">new</span> <span class="built_in">Square</span>(<span class="number">5.0</span>);</span><br><span class="line"></span><br><span class="line">    shape1-&gt;<span class="built_in">draw</span>(); <span class="comment">// 调用Triangle的draw</span></span><br><span class="line">    shape2-&gt;<span class="built_in">draw</span>(); <span class="comment">// 调用Square的draw</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> shape1;</span><br><span class="line">    <span class="keyword">delete</span> shape2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Drawing a triangle with base 3 and height 4.</span><br><span class="line">Drawing a square with side 5.</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>AbstractShape</code>类包含一个纯虚函数<code>draw</code>，因此成为抽象类，不能被实例化。</li>
<li><code>Triangle</code>和<code>Square</code>类继承自<code>AbstractShape</code>并实现了纯虚函数<code>draw</code>，使得它们成为具体类，可以被实例化。</li>
<li>通过基类指针调用<code>draw</code>函数时，实际执行的是派生类中重写的版本，实现了多态性。</li>
</ul>
<h3 id="4-4-多态性的实现与应用"><a href="#4-4-多态性的实现与应用" class="headerlink" title="4.4 多态性的实现与应用"></a>4.4 多态性的实现与应用</h3><p>多态性是面向对象编程的核心特性之一，通过基类指针或引用调用派生类的重写函数，实现不同对象的不同行为。多态性增强了代码的灵活性和可扩展性，特别适用于需要处理不同类型对象的场景。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Animal</span>(<span class="type">const</span> std::string&amp; name) : <span class="built_in">name_</span>(name) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>; <span class="comment">// 纯虚函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Animal</span>() = <span class="keyword">default</span>; <span class="comment">// 虚析构函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::string name_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Dog</span>(<span class="type">const</span> std::string&amp; name) : <span class="built_in">Animal</span>(name) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; name_ &lt;&lt; <span class="string">&quot; says: Woof!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Cat</span>(<span class="type">const</span> std::string&amp; name) : <span class="built_in">Animal</span>(name) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; name_ &lt;&lt; <span class="string">&quot; says: Meow!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类3</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Bird</span>(<span class="type">const</span> std::string&amp; name) : <span class="built_in">Animal</span>(name) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; name_ &lt;&lt; <span class="string">&quot; says: Tweet!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;std::unique_ptr&lt;Animal&gt;&gt; animals;</span><br><span class="line">    animals.<span class="built_in">emplace_back</span>(std::<span class="built_in">make_unique</span>&lt;Dog&gt;(<span class="string">&quot;Buddy&quot;</span>));</span><br><span class="line">    animals.<span class="built_in">emplace_back</span>(std::<span class="built_in">make_unique</span>&lt;Cat&gt;(<span class="string">&quot;Whiskers&quot;</span>));</span><br><span class="line">    animals.<span class="built_in">emplace_back</span>(std::<span class="built_in">make_unique</span>&lt;Bird&gt;(<span class="string">&quot;Tweety&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; animal : animals) &#123;</span><br><span class="line">        animal-&gt;<span class="built_in">speak</span>(); <span class="comment">// 调用各自的speak函数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Buddy says: Woof!</span><br><span class="line">Whiskers says: Meow!</span><br><span class="line">Tweety says: Tweet!</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>Animal</code>是一个抽象基类，定义了纯虚函数<code>speak</code>。</li>
<li><code>Dog</code>、<code>Cat</code>和<code>Bird</code>类继承自<code>Animal</code>并实现了<code>speak</code>函数。</li>
<li>在<code>main</code>函数中，通过<code>std::unique_ptr&lt;Animal&gt;</code>存储不同类型的动物对象，并通过基类指针调用<code>speak</code>函数，实际执行的是各自派生类中的实现，实现了多态性。</li>
<li>使用智能指针（<code>std::unique_ptr</code>）自动管理对象的生命周期，避免手动管理内存。</li>
</ul>
<h3 id="4-5-抽象类的应用场景"><a href="#4-5-抽象类的应用场景" class="headerlink" title="4.5 抽象类的应用场景"></a>4.5 抽象类的应用场景</h3><p>抽象类主要用于定义接口规范，强制派生类实现特定的功能。常见的应用场景包括：</p>
<ul>
<li><strong>接口定义</strong>：定义一组相关的操作，确保所有派生类实现这些操作。</li>
<li><strong>框架设计</strong>：在软件框架中，抽象类作为基类，定义框架所需的基本功能，派生类实现具体的业务逻辑。</li>
<li><strong>多态性实现</strong>：通过抽象类实现多态性，处理不同类型的对象时无需了解具体类型，只需依赖基类接口。</li>
</ul>
<p><strong>示例：图形绘制框架</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Drawable</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>; <span class="comment">// 纯虚函数</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Drawable</span>() = <span class="keyword">default</span>;  <span class="comment">// 虚析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Line</span> : <span class="keyword">public</span> Drawable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a line.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Drawable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a circle.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类3</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">public</span> Drawable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a rectangle.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘图工具</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DrawingTool</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addShape</span><span class="params">(std::unique_ptr&lt;Drawable&gt; shape)</span> </span>&#123;</span><br><span class="line">        shapes_.<span class="built_in">emplace_back</span>(std::<span class="built_in">move</span>(shape));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">render</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; shape : shapes_) &#123;</span><br><span class="line">            shape-&gt;<span class="built_in">draw</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;std::unique_ptr&lt;Drawable&gt;&gt; shapes_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DrawingTool tool;</span><br><span class="line">    tool.<span class="built_in">addShape</span>(std::<span class="built_in">make_unique</span>&lt;Line&gt;());</span><br><span class="line">    tool.<span class="built_in">addShape</span>(std::<span class="built_in">make_unique</span>&lt;Circle&gt;());</span><br><span class="line">    tool.<span class="built_in">addShape</span>(std::<span class="built_in">make_unique</span>&lt;Rectangle&gt;());</span><br><span class="line"></span><br><span class="line">    tool.<span class="built_in">render</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Drawing a line.</span><br><span class="line">Drawing a circle.</span><br><span class="line">Drawing a rectangle.</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>Drawable</code>是一个抽象基类，定义了纯虚函数<code>draw</code>。</li>
<li><code>Line</code>、<code>Circle</code>和<code>Rectangle</code>类继承自<code>Drawable</code>并实现了<code>draw</code>函数，具体绘制不同的图形。</li>
<li><code>DrawingTool</code>类通过存储<code>Drawable</code>类型的智能指针，管理和渲染各种图形对象，实现了绘图工具的多态性和扩展性。</li>
</ul>
<hr>
<h2 id="5-命名空间与模板（Namespaces-and-Templates）"><a href="#5-命名空间与模板（Namespaces-and-Templates）" class="headerlink" title="5. 命名空间与模板（Namespaces and Templates）"></a>5. 命名空间与模板（Namespaces and Templates）</h2><h3 id="5-1-命名空间（Namespaces）"><a href="#5-1-命名空间（Namespaces）" class="headerlink" title="5.1 命名空间（Namespaces）"></a>5.1 命名空间（Namespaces）</h3><h4 id="5-1-1-命名空间的概念"><a href="#5-1-1-命名空间的概念" class="headerlink" title="5.1.1 命名空间的概念"></a>5.1.1 命名空间的概念</h4><p>命名空间是C++中用于组织代码并避免命名冲突的机制。通过将相关的类、函数、变量等封装在一个命名空间中，可以确保不同模块之间的标识符不会相互干扰。</p>
<h4 id="5-1-2-命名空间的定义与使用"><a href="#5-1-2-命名空间的定义与使用" class="headerlink" title="5.1.2 命名空间的定义与使用"></a>5.1.2 命名空间的定义与使用</h4><p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义命名空间Math</span></span><br><span class="line"><span class="keyword">namespace</span> Math &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> PI = <span class="number">3.141592653589793</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">square</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义命名空间Utils</span></span><br><span class="line"><span class="keyword">namespace</span> Utils &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printMessage</span><span class="params">(<span class="type">const</span> std::string&amp; message)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Message: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> radius = <span class="number">5.0</span>;</span><br><span class="line">    <span class="type">double</span> area = Math::PI * Math::<span class="built_in">square</span>(radius);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Area of circle: &quot;</span> &lt;&lt; area &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    Utils::<span class="built_in">printMessage</span>(<span class="string">&quot;Hello, Namespaces!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Area of circle: 78.5398</span><br><span class="line">Message: Hello, Namespaces!</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><strong>命名空间的定义</strong>：通过<code>namespace Math &#123; ... &#125;</code>和<code>namespace Utils &#123; ... &#125;</code>定义了两个命名空间<code>Math</code>和<code>Utils</code>。</li>
<li><strong>命名空间成员的访问</strong>：使用<code>Math::PI</code>和<code>Math::square(radius)</code>访问<code>Math</code>命名空间中的成员，使用<code>Utils::printMessage</code>访问<code>Utils</code>命名空间中的函数。</li>
<li><strong>避免命名冲突</strong>：即使不同命名空间中存在相同名称的函数或变量，通过命名空间前缀可以明确区分它们。</li>
</ul>
<h4 id="5-1-3-使用using声明"><a href="#5-1-3-使用using声明" class="headerlink" title="5.1.3 使用using声明"></a>5.1.3 使用<code>using</code>声明</h4><p>为了简化命名空间成员的访问，可以使用<code>using</code>声明。然而，过度使用<code>using</code>可能会引入命名冲突，需谨慎使用。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Alpha &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">greet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Hello from Alpha!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Beta &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">greet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Hello from Beta!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> Alpha::greet; <span class="comment">// 引入Alpha命名空间的greet函数</span></span><br><span class="line">    <span class="built_in">greet</span>(); <span class="comment">// 调用Alpha::greet</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// greet(); // 仍然只能调用Alpha::greet，Beta::greet不会被引入</span></span><br><span class="line"></span><br><span class="line">    Beta::<span class="built_in">greet</span>(); <span class="comment">// 通过命名空间前缀调用Beta::greet</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello from Alpha!</span><br><span class="line">Hello from Beta!</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>using Alpha::greet;</code>引入了<code>Alpha</code>命名空间的<code>greet</code>函数，使得可以直接调用<code>greet()</code>而不需要前缀。</li>
<li><code>Beta::greet();</code>仍然需要使用命名空间前缀来调用<code>Beta</code>命名空间的<code>greet</code>函数，避免了命名冲突。</li>
</ul>
<h3 id="5-2-模板（Templates）"><a href="#5-2-模板（Templates）" class="headerlink" title="5.2 模板（Templates）"></a>5.2 模板（Templates）</h3><h4 id="5-2-1-模板的概念"><a href="#5-2-1-模板的概念" class="headerlink" title="5.2.1 模板的概念"></a>5.2.1 模板的概念</h4><p>模板是C++中的一种泛型编程机制，允许编写与类型无关的代码。通过模板，可以实现函数和类的泛型化，提高代码的复用性和灵活性。</p>
<h4 id="5-2-2-函数模板"><a href="#5-2-2-函数模板" class="headerlink" title="5.2.2 函数模板"></a>5.2.2 函数模板</h4><p>函数模板使得同一函数可以处理不同类型的数据。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个函数模板，用于交换两个变量的值</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapValues</span><span class="params">(T&amp; a, T&amp; b)</span> </span>&#123;</span><br><span class="line">    T temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>, y = <span class="number">20</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Before swap: x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, y = &quot;</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">swapValues</span>(x, y);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After swap: x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, y = &quot;</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> m = <span class="number">1.5</span>, n = <span class="number">2.5</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Before swap: m = &quot;</span> &lt;&lt; m &lt;&lt; <span class="string">&quot;, n = &quot;</span> &lt;&lt; n &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">swapValues</span>(m, n);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After swap: m = &quot;</span> &lt;&lt; m &lt;&lt; <span class="string">&quot;, n = &quot;</span> &lt;&lt; n &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::string s1 = <span class="string">&quot;Hello&quot;</span>, s2 = <span class="string">&quot;World&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Before swap: s1 = &quot;</span> &lt;&lt; s1 &lt;&lt; <span class="string">&quot;, s2 = &quot;</span> &lt;&lt; s2 &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">swapValues</span>(s1, s2);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After swap: s1 = &quot;</span> &lt;&lt; s1 &lt;&lt; <span class="string">&quot;, s2 = &quot;</span> &lt;&lt; s2 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Before swap: x = 10, y = 20</span><br><span class="line">After swap: x = 20, y = 10</span><br><span class="line">Before swap: m = 1.5, n = 2.5</span><br><span class="line">After swap: m = 2.5, n = 1.5</span><br><span class="line">Before swap: s1 = Hello, s2 = World</span><br><span class="line">After swap: s1 = World, s2 = Hello</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>swapValues</code>是一个函数模板，使用<code>template &lt;typename T&gt;</code>定义。</li>
<li>可以将<code>swapValues</code>应用于不同类型的数据，如<code>int</code>、<code>double</code>、<code>std::string</code>，无需为每种类型编写单独的交换函数。</li>
</ul>
<h4 id="5-2-3-类模板"><a href="#5-2-3-类模板" class="headerlink" title="5.2.3 类模板"></a>5.2.3 类模板</h4><p>类模板允许定义与类型无关的类，适用于实现容器类和其他泛型类。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个类模板，用于存储一对值</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Pair</span>(T1 first, T2 second) : <span class="built_in">first_</span>(first), <span class="built_in">second_</span>(second) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">T1 <span class="title">getFirst</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> first_; &#125;</span><br><span class="line">    <span class="function">T2 <span class="title">getSecond</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> second_; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setFirst</span><span class="params">(T1 first)</span> </span>&#123; first_ = first; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setSecond</span><span class="params">(T2 second)</span> </span>&#123; second_ = second; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T1 first_;</span><br><span class="line">    T2 second_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用Pair模板存储int和double</span></span><br><span class="line">    <span class="function">Pair&lt;<span class="type">int</span>, <span class="type">double</span>&gt; <span class="title">p1</span><span class="params">(<span class="number">1</span>, <span class="number">3.14</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Pair1: (&quot;</span> &lt;&lt; p1.<span class="built_in">getFirst</span>() &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; p1.<span class="built_in">getSecond</span>() &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用Pair模板存储std::string和char</span></span><br><span class="line">    <span class="function">Pair&lt;std::string, <span class="type">char</span>&gt; <span class="title">p2</span><span class="params">(<span class="string">&quot;Hello&quot;</span>, <span class="string">&#x27;A&#x27;</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Pair2: (&quot;</span> &lt;&lt; p2.<span class="built_in">getFirst</span>() &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; p2.<span class="built_in">getSecond</span>() &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Pair1: (1, 3.14)</span><br><span class="line">Pair2: (Hello, A)</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>Pair</code>是一个类模板，使用<code>template &lt;typename T1, typename T2&gt;</code>定义。</li>
<li>可以创建不同类型的<code>Pair</code>对象，如<code>Pair&lt;int, double&gt;</code>和<code>Pair&lt;std::string, char&gt;</code>，实现了类型的灵活组合。</li>
</ul>
<h4 id="5-2-4-模板特化"><a href="#5-2-4-模板特化" class="headerlink" title="5.2.4 模板特化"></a>5.2.4 模板特化</h4><p>模板特化允许针对特定类型定制模板的行为。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通用模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Printer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> T&amp; data)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Data: &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板特化，针对std::string类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Printer</span>&lt;std::string&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> std::string&amp; data)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;String Data: \&quot;&quot;</span> &lt;&lt; data &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Printer&lt;<span class="type">int</span>&gt; intPrinter;</span><br><span class="line">    intPrinter.<span class="built_in">print</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    Printer&lt;<span class="type">double</span>&gt; doublePrinter;</span><br><span class="line">    doublePrinter.<span class="built_in">print</span>(<span class="number">3.14159</span>);</span><br><span class="line"></span><br><span class="line">    Printer&lt;std::string&gt; stringPrinter;</span><br><span class="line">    stringPrinter.<span class="built_in">print</span>(<span class="string">&quot;Hello, Templates!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Data: 100</span><br><span class="line">Data: 3.14159</span><br><span class="line">String Data: &quot;Hello, Templates!&quot;</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>通用模板<code>Printer&lt;T&gt;</code>定义了如何打印不同类型的数据。</li>
<li>针对<code>std::string</code>类型，进行了模板特化，定制了不同的打印格式。</li>
<li>当使用<code>Printer&lt;std::string&gt;</code>时，调用的是特化后的<code>Printer&lt;std::string&gt;</code>版本，而不是通用模板。</li>
</ul>
<h3 id="5-3-总结"><a href="#5-3-总结" class="headerlink" title="5.3 总结"></a>5.3 总结</h3><p>命名空间和模板是C++中非常重要的高级特性。命名空间帮助组织代码，避免命名冲突，而模板则支持泛型编程，提升代码的复用性和灵活性。通过合理使用命名空间和模板，可以编写出更清晰、更高效、更可维护的代码。</p>
<hr>
<h2 id="6-C-IO流类库（C-IO-Stream-Library）"><a href="#6-C-IO流类库（C-IO-Stream-Library）" class="headerlink" title="6. C++ IO流类库（C++ IO Stream Library）"></a>6. C++ IO流类库（C++ IO Stream Library）</h2><h3 id="6-1-IO流的基本概念"><a href="#6-1-IO流的基本概念" class="headerlink" title="6.1 IO流的基本概念"></a>6.1 IO流的基本概念</h3><p>C++标准库中的IO流（Input&#x2F;Output Streams）提供了用于处理输入和输出的机制。通过IO流，可以实现与控制台、文件、字符串等不同数据源和目标的交互。</p>
<h3 id="6-2-输入输出流对象"><a href="#6-2-输入输出流对象" class="headerlink" title="6.2 输入输出流对象"></a>6.2 输入输出流对象</h3><p>C++标准库主要提供以下IO流对象：</p>
<ul>
<li><code>std::cin</code>：标准输入流，通常与键盘关联。</li>
<li><code>std::cout</code>：标准输出流，通常与控制台关联。</li>
<li><code>std::cerr</code>：标准错误输出流，用于输出错误信息。</li>
<li><code>std::clog</code>：标准日志输出流，用于输出日志信息。</li>
</ul>
<h3 id="6-3-使用std-cin和std-cout"><a href="#6-3-使用std-cin和std-cout" class="headerlink" title="6.3 使用std::cin和std::cout"></a>6.3 使用<code>std::cin</code>和<code>std::cout</code></h3><p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;请输入您的姓名: &quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; name;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;请输入您的年龄: &quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; age;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;您好, &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;! 您今年 &quot;</span> &lt;&lt; age &lt;&lt; <span class="string">&quot; 岁。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">请输入您的姓名: 张三</span><br><span class="line">请输入您的年龄: 25</span><br><span class="line">您好, 张三! 您今年 25 岁。</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>std::cout</code>用于输出提示信息到控制台。</li>
<li><code>std::cin</code>用于从控制台读取用户输入的数据。</li>
<li>使用插入运算符<code>&lt;&lt;</code>和提取运算符<code>&gt;&gt;</code>实现数据的输出和输入。</li>
</ul>
<h3 id="6-4-文件输入输出（File-I-x2F-O）"><a href="#6-4-文件输入输出（File-I-x2F-O）" class="headerlink" title="6.4 文件输入输出（File I&#x2F;O）"></a>6.4 文件输入输出（File I&#x2F;O）</h3><p>C++标准库提供了<code>&lt;fstream&gt;</code>头文件中的<code>std::ifstream</code>和<code>std::ofstream</code>类，用于文件的读取和写入。</p>
<h4 id="6-4-1-写入文件"><a href="#6-4-1-写入文件" class="headerlink" title="6.4.1 写入文件"></a>6.4.1 写入文件</h4><p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::ofstream <span class="title">outFile</span><span class="params">(<span class="string">&quot;example.txt&quot;</span>)</span></span>; <span class="comment">// 打开文件用于写入</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!outFile) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;无法打开文件进行写入。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::string data = <span class="string">&quot;这是写入文件的第一行。\n这是写入文件的第二行。&quot;</span>;</span><br><span class="line">    outFile &lt;&lt; data;</span><br><span class="line"></span><br><span class="line">    outFile.<span class="built_in">close</span>(); <span class="comment">// 关闭文件</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;数据已成功写入文件。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据已成功写入文件。</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>创建一个<code>std::ofstream</code>对象并指定文件名<code>example.txt</code>，以打开文件进行写入。</li>
<li>使用插入运算符<code>&lt;&lt;</code>将字符串写入文件。</li>
<li>关闭文件以释放资源。</li>
</ul>
<h4 id="6-4-2-读取文件"><a href="#6-4-2-读取文件" class="headerlink" title="6.4.2 读取文件"></a>6.4.2 读取文件</h4><p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::ifstream <span class="title">inFile</span><span class="params">(<span class="string">&quot;example.txt&quot;</span>)</span></span>; <span class="comment">// 打开文件用于读取</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!inFile) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;无法打开文件进行读取。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::string line;</span><br><span class="line">    <span class="keyword">while</span> (std::<span class="built_in">getline</span>(inFile, line)) &#123; <span class="comment">// 逐行读取文件</span></span><br><span class="line">        std::cout &lt;&lt; line &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    inFile.<span class="built_in">close</span>(); <span class="comment">// 关闭文件</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这是写入文件的第一行。</span><br><span class="line">这是写入文件的第二行。</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>创建一个<code>std::ifstream</code>对象并指定文件名<code>example.txt</code>，以打开文件进行读取。</li>
<li>使用<code>std::getline</code>逐行读取文件内容，并输出到控制台。</li>
<li>关闭文件以释放资源。</li>
</ul>
<h3 id="6-5-其他IO流功能"><a href="#6-5-其他IO流功能" class="headerlink" title="6.5 其他IO流功能"></a>6.5 其他IO流功能</h3><h4 id="6-5-1-格式化输出"><a href="#6-5-1-格式化输出" class="headerlink" title="6.5.1 格式化输出"></a>6.5.1 格式化输出</h4><p>C++ IO流支持多种格式化操作，如控制宽度、对齐方式、数值格式等。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> pi = <span class="number">3.141592653589793</span>;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;默认格式:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;pi = &quot;</span> &lt;&lt; pi &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n设置宽度和精度:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; std::fixed &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">4</span>) &lt;&lt; pi &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n科学计数法:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; std::scientific &lt;&lt; pi &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">默认格式:</span><br><span class="line">pi = 3.14159</span><br><span class="line">num = 42</span><br><span class="line"></span><br><span class="line">设置宽度和精度:</span><br><span class="line">    3.1416</span><br><span class="line">        42</span><br><span class="line"></span><br><span class="line">科学计数法:</span><br><span class="line">3.141593e+00</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>std::setw(10)</code>设置输出宽度为10个字符。</li>
<li><code>std::fixed</code>和<code>std::setprecision(4)</code>设置浮点数的固定小数点格式和精度为4位。</li>
<li><code>std::scientific</code>将浮点数以科学计数法格式输出。</li>
</ul>
<h3 id="6-6-总结"><a href="#6-6-总结" class="headerlink" title="6.6 总结"></a>6.6 总结</h3><p>C++的IO流类库提供了强大且灵活的输入输出功能，支持与控制台、文件和其他数据源的交互。通过掌握IO流的基本用法和格式化输出技巧，可以高效地处理各种输入输出需求，编写出功能丰富的应用程序。</p>
<hr>
<h2 id="7-标准模板库（STL）——vector、deque与stack"><a href="#7-标准模板库（STL）——vector、deque与stack" class="headerlink" title="7. 标准模板库（STL）——vector、deque与stack"></a>7. 标准模板库（STL）——<code>vector</code>、<code>deque</code>与<code>stack</code></h2><p>标准模板库（STL）是C++标准库的重要组成部分，提供了一系列通用的数据结构和算法。STL中的容器类（如<code>vector</code>、<code>deque</code>、<code>stack</code>）使得数据管理和操作更加便捷和高效。</p>
<h3 id="7-1-vector"><a href="#7-1-vector" class="headerlink" title="7.1 vector"></a>7.1 <code>vector</code></h3><h4 id="7-1-1-vector的概念"><a href="#7-1-1-vector的概念" class="headerlink" title="7.1.1 vector的概念"></a>7.1.1 <code>vector</code>的概念</h4><p><code>std::vector</code>是一个动态数组，支持随机访问、高效的元素插入和删除操作。<code>vector</code>能够根据需要自动调整大小，是最常用的STL容器之一。</p>
<h4 id="7-1-2-vector的基本用法"><a href="#7-1-2-vector的基本用法" class="headerlink" title="7.1.2 vector的基本用法"></a>7.1.2 <code>vector</code>的基本用法</h4><p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers; <span class="comment">// 创建一个空的vector</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加元素</span></span><br><span class="line">    numbers.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    numbers.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    numbers.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Vector elements: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; numbers.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; numbers[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用迭代器访问</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Using iterators: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = numbers.<span class="built_in">begin</span>(); it != numbers.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改元素</span></span><br><span class="line">    numbers[<span class="number">1</span>] = <span class="number">25</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After modification: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除最后一个元素</span></span><br><span class="line">    numbers.<span class="built_in">pop_back</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After pop_back: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vector elements: 10 20 30 </span><br><span class="line">Using iterators: 10 20 30 </span><br><span class="line">After modification: 10 25 30 </span><br><span class="line">After pop_back: 10 25 </span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>使用<code>push_back</code>向<code>vector</code>中添加元素。</li>
<li>通过下标和迭代器访问和修改元素。</li>
<li>使用<code>pop_back</code>删除<code>vector</code>的最后一个元素。</li>
</ul>
<h4 id="7-1-3-vector的高级操作"><a href="#7-1-3-vector的高级操作" class="headerlink" title="7.1.3 vector的高级操作"></a>7.1.3 <code>vector</code>的高级操作</h4><p><strong>示例：插入和删除元素</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;std::string&gt; fruits = &#123;<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Cherry&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在第二个位置插入元素</span></span><br><span class="line">    fruits.<span class="built_in">insert</span>(fruits.<span class="built_in">begin</span>() + <span class="number">1</span>, <span class="string">&quot;Blueberry&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After insert: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; fruit : fruits) &#123;</span><br><span class="line">        std::cout &lt;&lt; fruit &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除第三个元素</span></span><br><span class="line">    fruits.<span class="built_in">erase</span>(fruits.<span class="built_in">begin</span>() + <span class="number">2</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After erase: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; fruit : fruits) &#123;</span><br><span class="line">        std::cout &lt;&lt; fruit &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空vector</span></span><br><span class="line">    fruits.<span class="built_in">clear</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After clear, size: &quot;</span> &lt;&lt; fruits.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">After insert: Apple Blueberry Banana Cherry </span><br><span class="line">After erase: Apple Blueberry Cherry </span><br><span class="line">After clear, size: 0</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>insert</code>用于在指定位置插入元素。</li>
<li><code>erase</code>用于删除指定位置的元素。</li>
<li><code>clear</code>用于移除<code>vector</code>中的所有元素。</li>
</ul>
<h3 id="7-2-deque"><a href="#7-2-deque" class="headerlink" title="7.2 deque"></a>7.2 <code>deque</code></h3><h4 id="7-2-1-deque的概念"><a href="#7-2-1-deque的概念" class="headerlink" title="7.2.1 deque的概念"></a>7.2.1 <code>deque</code>的概念</h4><p><code>std::deque</code>（双端队列）是一个可以在两端高效插入和删除元素的序列容器。相比<code>vector</code>，<code>deque</code>在两端的操作更高效，但随机访问性能略低。</p>
<h4 id="7-2-2-deque的基本用法"><a href="#7-2-2-deque的基本用法" class="headerlink" title="7.2.2 deque的基本用法"></a>7.2.2 <code>deque</code>的基本用法</h4><p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::deque&lt;<span class="type">int</span>&gt; d;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在前端和后端添加元素</span></span><br><span class="line">    d.<span class="built_in">push_back</span>(<span class="number">100</span>);</span><br><span class="line">    d.<span class="built_in">push_front</span>(<span class="number">50</span>);</span><br><span class="line">    d.<span class="built_in">push_back</span>(<span class="number">150</span>);</span><br><span class="line">    d.<span class="built_in">push_front</span>(<span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Deque elements: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : d) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改元素</span></span><br><span class="line">    d[<span class="number">1</span>] = <span class="number">75</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After modification: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : d) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除前端和后端元素</span></span><br><span class="line">    d.<span class="built_in">pop_front</span>();</span><br><span class="line">    d.<span class="built_in">pop_back</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After pop operations: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : d) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Deque elements: 25 50 100 150 </span><br><span class="line">After modification: 25 75 100 150 </span><br><span class="line">After pop operations: 75 100 </span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>push_back</code>和<code>push_front</code>用于在<code>deque</code>的后端和前端添加元素。</li>
<li><code>pop_back</code>和<code>pop_front</code>用于从后端和前端删除元素。</li>
<li>通过下标访问和修改元素。</li>
</ul>
<h4 id="7-2-3-deque的高级操作"><a href="#7-2-3-deque的高级操作" class="headerlink" title="7.2.3 deque的高级操作"></a>7.2.3 <code>deque</code>的高级操作</h4><p><strong>示例：插入和删除多个元素</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::deque&lt;<span class="type">int</span>&gt; d = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在位置2插入多个元素</span></span><br><span class="line">    d.<span class="built_in">insert</span>(d.<span class="built_in">begin</span>() + <span class="number">2</span>, <span class="number">3</span>, <span class="number">99</span>); <span class="comment">// 插入三个99</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After insert: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : d) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除范围内的元素</span></span><br><span class="line">    d.<span class="built_in">erase</span>(d.<span class="built_in">begin</span>() + <span class="number">1</span>, d.<span class="built_in">begin</span>() + <span class="number">4</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After erase: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : d) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">After insert: 1 2 99 99 99 3 4 5 </span><br><span class="line">After erase: 1 99 3 4 5 </span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>insert</code>可以插入多个相同的元素或一个范围的元素。</li>
<li><code>erase</code>可以删除指定范围内的元素。</li>
</ul>
<h3 id="7-3-stack"><a href="#7-3-stack" class="headerlink" title="7.3 stack"></a>7.3 <code>stack</code></h3><h4 id="7-3-1-stack的概念"><a href="#7-3-1-stack的概念" class="headerlink" title="7.3.1 stack的概念"></a>7.3.1 <code>stack</code>的概念</h4><p><code>std::stack</code>是一种容器适配器，提供后进先出（LIFO）的数据结构。它默认基于<code>std::deque</code>实现，但也可以使用其他容器（如<code>std::vector</code>、<code>std::list</code>）。</p>
<h4 id="7-3-2-stack的基本用法"><a href="#7-3-2-stack的基本用法" class="headerlink" title="7.3.2 stack的基本用法"></a>7.3.2 <code>stack</code>的基本用法</h4><p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::stack&lt;std::string&gt; s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 压入元素</span></span><br><span class="line">    s.<span class="built_in">push</span>(<span class="string">&quot;Apple&quot;</span>);</span><br><span class="line">    s.<span class="built_in">push</span>(<span class="string">&quot;Banana&quot;</span>);</span><br><span class="line">    s.<span class="built_in">push</span>(<span class="string">&quot;Cherry&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看栈顶元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;栈顶元素: &quot;</span> &lt;&lt; s.<span class="built_in">top</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 弹出元素</span></span><br><span class="line">    s.<span class="built_in">pop</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;弹出后栈顶元素: &quot;</span> &lt;&lt; s.<span class="built_in">top</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查栈是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;栈不为空，大小: &quot;</span> &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">栈顶元素: Cherry</span><br><span class="line">弹出后栈顶元素: Banana</span><br><span class="line">栈不为空，大小: 2</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>push</code>用于向栈顶添加元素。</li>
<li><code>top</code>用于查看栈顶元素。</li>
<li><code>pop</code>用于移除栈顶元素。</li>
<li><code>empty</code>和<code>size</code>用于检查栈的状态。</li>
</ul>
<h4 id="7-3-3-stack的限制"><a href="#7-3-3-stack的限制" class="headerlink" title="7.3.3 stack的限制"></a>7.3.3 <code>stack</code>的限制</h4><p><code>std::stack</code>仅支持有限的操作，如<code>push</code>、<code>pop</code>、<code>top</code>等，不能直接访问栈中的中间元素。如果需要更灵活的访问，可以选择其他容器（如<code>std::vector</code>或<code>std::deque</code>）或使用迭代器。</p>
<h3 id="7-4-总结"><a href="#7-4-总结" class="headerlink" title="7.4 总结"></a>7.4 总结</h3><p>STL中的<code>vector</code>、<code>deque</code>和<code>stack</code>提供了高效、灵活的容器选择，适用于不同的应用场景。通过熟练掌握这些容器的使用，可以显著提升C++程序的性能和可维护性。在Qt开发中，这些容器类同样广泛应用于数据管理、界面构建等方面，是每个Qt开发者必备的工具。</p>
<hr>
<h2 id="8-标准模板库（STL）——queue、set与map"><a href="#8-标准模板库（STL）——queue、set与map" class="headerlink" title="8. 标准模板库（STL）——queue、set与map"></a>8. 标准模板库（STL）——<code>queue</code>、<code>set</code>与<code>map</code></h2><p>标准模板库（STL）中的<code>queue</code>、<code>set</code>和<code>map</code>是常用的容器类型，适用于不同的数据组织和管理需求。理解它们的特性和应用场景，可以有效地提升编程效率和代码质量。</p>
<h3 id="8-1-queue"><a href="#8-1-queue" class="headerlink" title="8.1 queue"></a>8.1 <code>queue</code></h3><h4 id="8-1-1-queue的概念"><a href="#8-1-1-queue的概念" class="headerlink" title="8.1.1 queue的概念"></a>8.1.1 <code>queue</code>的概念</h4><p><code>std::queue</code>是一个先进先出（FIFO）的容器适配器，基于底层容器（如<code>std::deque</code>或<code>std::list</code>）实现。它主要用于需要按顺序处理元素的场景，如任务调度、消息队列等。</p>
<h4 id="8-1-2-queue的基本用法"><a href="#8-1-2-queue的基本用法" class="headerlink" title="8.1.2 queue的基本用法"></a>8.1.2 <code>queue</code>的基本用法</h4><p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::queue&lt;std::string&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入队</span></span><br><span class="line">    q.<span class="built_in">push</span>(<span class="string">&quot;First&quot;</span>);</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="string">&quot;Second&quot;</span>);</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="string">&quot;Third&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问队首元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;队首元素: &quot;</span> &lt;&lt; q.<span class="built_in">front</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问队尾元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;队尾元素: &quot;</span> &lt;&lt; q.<span class="built_in">back</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出队</span></span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;出队后新的队首元素: &quot;</span> &lt;&lt; q.<span class="built_in">front</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查队列是否为空</span></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;出队元素: &quot;</span> &lt;&lt; q.<span class="built_in">front</span>() &lt;&lt; std::endl;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">队首元素: First</span><br><span class="line">队尾元素: Third</span><br><span class="line">出队后新的队首元素: Second</span><br><span class="line">出队元素: Second</span><br><span class="line">出队元素: Third</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>push</code>用于向队尾添加元素。</li>
<li><code>front</code>和<code>back</code>分别用于访问队首和队尾元素。</li>
<li><code>pop</code>用于移除队首元素。</li>
<li><code>empty</code>用于检查队列是否为空。</li>
</ul>
<h4 id="8-1-3-queue的高级操作"><a href="#8-1-3-queue的高级操作" class="headerlink" title="8.1.3 queue的高级操作"></a>8.1.3 <code>queue</code>的高级操作</h4><p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入队多个元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        q.<span class="built_in">push</span>(i * <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用循环处理队列</span></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Processing element: &quot;</span> &lt;&lt; q.<span class="built_in">front</span>() &lt;&lt; std::endl;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Processing element: 10</span><br><span class="line">Processing element: 20</span><br><span class="line">Processing element: 30</span><br><span class="line">Processing element: 40</span><br><span class="line">Processing element: 50</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>使用循环入队和出队元素，实现对队列的批量处理。</li>
</ul>
<h3 id="8-2-set"><a href="#8-2-set" class="headerlink" title="8.2 set"></a>8.2 <code>set</code></h3><h4 id="8-2-1-set的概念"><a href="#8-2-1-set的概念" class="headerlink" title="8.2.1 set的概念"></a>8.2.1 <code>set</code>的概念</h4><p><code>std::set</code>是一个关联容器，存储唯一的、有序的元素。<code>set</code>基于平衡二叉树（通常是红黑树）实现，提供高效的查找、插入和删除操作。</p>
<h4 id="8-2-2-set的基本用法"><a href="#8-2-2-set的基本用法" class="headerlink" title="8.2.2 set的基本用法"></a>8.2.2 <code>set</code>的基本用法</h4><p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::set&lt;std::string&gt; fruits;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    fruits.<span class="built_in">insert</span>(<span class="string">&quot;Apple&quot;</span>);</span><br><span class="line">    fruits.<span class="built_in">insert</span>(<span class="string">&quot;Banana&quot;</span>);</span><br><span class="line">    fruits.<span class="built_in">insert</span>(<span class="string">&quot;Cherry&quot;</span>);</span><br><span class="line">    fruits.<span class="built_in">insert</span>(<span class="string">&quot;Apple&quot;</span>); <span class="comment">// 重复元素，不会被插入</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历set</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Fruits set contains:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; fruit : fruits) &#123;</span><br><span class="line">        std::cout &lt;&lt; fruit &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找元素</span></span><br><span class="line">    <span class="keyword">auto</span> it = fruits.<span class="built_in">find</span>(<span class="string">&quot;Banana&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != fruits.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Found: &quot;</span> &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Banana not found.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除元素</span></span><br><span class="line">    fruits.<span class="built_in">erase</span>(<span class="string">&quot;Cherry&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After erasing Cherry:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; fruit : fruits) &#123;</span><br><span class="line">        std::cout &lt;&lt; fruit &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Fruits set contains:</span><br><span class="line">Apple</span><br><span class="line">Banana</span><br><span class="line">Cherry</span><br><span class="line">Found: Banana</span><br><span class="line">After erasing Cherry:</span><br><span class="line">Apple</span><br><span class="line">Banana</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>insert</code>用于向<code>set</code>中添加元素，重复元素不会被插入。</li>
<li><code>find</code>用于查找元素，返回指向元素的迭代器或<code>end</code>迭代器。</li>
<li><code>erase</code>用于删除指定元素。</li>
</ul>
<h4 id="8-2-3-set的高级操作"><a href="#8-2-3-set的高级操作" class="headerlink" title="8.2.3 set的高级操作"></a>8.2.3 <code>set</code>的高级操作</h4><p><strong>示例：集合运算</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; setA = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; setB = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;;</span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; intersection;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算交集</span></span><br><span class="line">    std::<span class="built_in">set_intersection</span>(setA.<span class="built_in">begin</span>(), setA.<span class="built_in">end</span>(),</span><br><span class="line">                          setB.<span class="built_in">begin</span>(), setB.<span class="built_in">end</span>(),</span><br><span class="line">                          std::<span class="built_in">inserter</span>(intersection, intersection.<span class="built_in">begin</span>()));</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Intersection of setA and setB:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : intersection) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Intersection of setA and setB:</span><br><span class="line">4 5 </span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>使用<code>std::set_intersection</code>算法计算两个<code>set</code>的交集。</li>
<li>通过<code>std::inserter</code>将结果插入到<code>intersection</code>集合中。</li>
</ul>
<h3 id="8-3-map"><a href="#8-3-map" class="headerlink" title="8.3 map"></a>8.3 <code>map</code></h3><h4 id="8-3-1-map的概念"><a href="#8-3-1-map的概念" class="headerlink" title="8.3.1 map的概念"></a>8.3.1 <code>map</code>的概念</h4><p><code>std::map</code>是一个关联容器，存储键值对（key-value pairs），并根据键进行有序存储。<code>map</code>基于平衡二叉树实现，键是唯一的，提供高效的查找、插入和删除操作。</p>
<h4 id="8-3-2-map的基本用法"><a href="#8-3-2-map的基本用法" class="headerlink" title="8.3.2 map的基本用法"></a>8.3.2 <code>map</code>的基本用法</h4><p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::map&lt;std::string, <span class="type">int</span>&gt; ageMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入键值对</span></span><br><span class="line">    ageMap[<span class="string">&quot;Alice&quot;</span>] = <span class="number">30</span>;</span><br><span class="line">    ageMap[<span class="string">&quot;Bob&quot;</span>] = <span class="number">25</span>;</span><br><span class="line">    ageMap[<span class="string">&quot;Charlie&quot;</span>] = <span class="number">35</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历map</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Age Map:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : ageMap) &#123;</span><br><span class="line">        std::cout &lt;&lt; pair.first &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; pair.second &lt;&lt; <span class="string">&quot; years old.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找键</span></span><br><span class="line">    std::string name = <span class="string">&quot;Bob&quot;</span>;</span><br><span class="line">    <span class="keyword">auto</span> it = ageMap.<span class="built_in">find</span>(name);</span><br><span class="line">    <span class="keyword">if</span> (it != ageMap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="string">&quot; years old.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; name &lt;&lt; <span class="string">&quot; not found in the map.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除键值对</span></span><br><span class="line">    ageMap.<span class="built_in">erase</span>(<span class="string">&quot;Charlie&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After erasing Charlie:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : ageMap) &#123;</span><br><span class="line">        std::cout &lt;&lt; pair.first &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; pair.second &lt;&lt; <span class="string">&quot; years old.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Age Map:</span><br><span class="line">Alice is 30 years old.</span><br><span class="line">Bob is 25 years old.</span><br><span class="line">Charlie is 35 years old.</span><br><span class="line">Bob is 25 years old.</span><br><span class="line">After erasing Charlie:</span><br><span class="line">Alice is 30 years old.</span><br><span class="line">Bob is 25 years old.</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>使用下标运算符<code>[]</code>向<code>map</code>中插入或更新键值对。</li>
<li><code>find</code>用于查找特定键，返回指向键值对的迭代器或<code>end</code>迭代器。</li>
<li><code>erase</code>用于删除指定键值对。</li>
</ul>
<h4 id="8-3-3-map的高级操作"><a href="#8-3-3-map的高级操作" class="headerlink" title="8.3.3 map的高级操作"></a>8.3.3 <code>map</code>的高级操作</h4><p><strong>示例：遍历和条件插入</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::map&lt;std::string, <span class="type">int</span>&gt; scoreMap = &#123;</span><br><span class="line">        &#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">85</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">92</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Charlie&quot;</span>, <span class="number">78</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Diana&quot;</span>, <span class="number">88</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历并输出成绩高于80的学生</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Students with scores above 80:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : scoreMap) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pair.second &gt; <span class="number">80</span>) &#123;</span><br><span class="line">            std::cout &lt;&lt; pair.first &lt;&lt; <span class="string">&quot; scored &quot;</span> &lt;&lt; pair.second &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用insert方法插入新键值对</span></span><br><span class="line">    <span class="keyword">auto</span> result = scoreMap.<span class="built_in">insert</span>(&#123;<span class="string">&quot;Eve&quot;</span>, <span class="number">95</span>&#125;);</span><br><span class="line">    <span class="keyword">if</span> (result.second) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Inserted Eve with score &quot;</span> &lt;&lt; result.first-&gt;second &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to insert Eve, key already exists.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试插入已存在的键</span></span><br><span class="line">    result = scoreMap.<span class="built_in">insert</span>(&#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">90</span>&#125;);</span><br><span class="line">    <span class="keyword">if</span> (result.second) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Inserted Alice with score &quot;</span> &lt;&lt; result.first-&gt;second &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to insert Alice, key already exists.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Students with scores above 80:</span><br><span class="line">Alice scored 85</span><br><span class="line">Bob scored 92</span><br><span class="line">Diana scored 88</span><br><span class="line">Inserted Eve with score 95</span><br><span class="line">Failed to insert Alice, key already exists.</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>使用<code>insert</code>方法插入新的键值对，<code>insert</code>返回一个<code>pair</code>，其中<code>second</code>表示插入是否成功。</li>
<li>尝试插入已存在的键（如<code>&quot;Alice&quot;</code>）会失败，避免了键的重复。</li>
</ul>
<h3 id="8-4-总结"><a href="#8-4-总结" class="headerlink" title="8.4 总结"></a>8.4 总结</h3><p>STL中的<code>queue</code>、<code>set</code>和<code>map</code>为C++开发者提供了高效、可靠的数据结构，适用于各种编程需求。通过深入理解它们的特性和应用场景，可以大大提升程序的性能和可维护性。在Qt开发中，这些容器类同样发挥着重要作用，特别是在数据管理和界面交互等方面。</p>
<hr>
<h2 id="9-C-异常处理（Exception-Handling）"><a href="#9-C-异常处理（Exception-Handling）" class="headerlink" title="9. C++异常处理（Exception Handling）"></a>9. C++异常处理（Exception Handling）</h2><h3 id="9-1-异常处理的概念"><a href="#9-1-异常处理的概念" class="headerlink" title="9.1 异常处理的概念"></a>9.1 异常处理的概念</h3><p>异常处理是C++中用于处理运行时错误和意外情况的机制。通过异常处理，可以在程序中优雅地应对错误，避免程序崩溃，并提供恢复或清理资源的机会。</p>
<h3 id="9-2-异常处理的基本语法"><a href="#9-2-异常处理的基本语法" class="headerlink" title="9.2 异常处理的基本语法"></a>9.2 异常处理的基本语法</h3><p>C++提供了<code>try</code>、<code>catch</code>和<code>throw</code>三个关键字来实现异常处理。</p>
<p><strong>基本结构：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 可能抛出异常的代码</span></span><br><span class="line">&#125; <span class="built_in">catch</span> (ExceptionType1 e1) &#123;</span><br><span class="line">    <span class="comment">// 处理ExceptionType1类型的异常</span></span><br><span class="line">&#125; <span class="built_in">catch</span> (ExceptionType2 e2) &#123;</span><br><span class="line">    <span class="comment">// 处理ExceptionType2类型的异常</span></span><br><span class="line">&#125; <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">    <span class="comment">// 处理所有其他类型的异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-3-使用try、catch和throw"><a href="#9-3-使用try、catch和throw" class="headerlink" title="9.3 使用try、catch和throw"></a>9.3 使用<code>try</code>、<code>catch</code>和<code>throw</code></h3><p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数，计算两个数的除法</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">divide</span><span class="params">(<span class="type">double</span> numerator, <span class="type">double</span> denominator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (denominator == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;分母不能为零。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numerator / denominator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> a = <span class="number">10.0</span>, b = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">double</span> result = <span class="built_in">divide</span>(a, b);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;结果: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::invalid_argument&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;异常捕获: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;未知异常发生。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;程序继续运行...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">异常捕获: 分母不能为零。</span><br><span class="line">程序继续运行...</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>divide</code>函数在分母为零时，通过<code>throw</code>抛出<code>std::invalid_argument</code>异常。</li>
<li><code>try</code>块中调用<code>divide</code>函数，可能抛出异常。</li>
<li><code>catch</code>块捕获并处理<code>std::invalid_argument</code>类型的异常，输出错误信息。</li>
<li>程序在异常处理后继续运行，避免了崩溃。</li>
</ul>
<h3 id="9-4-自定义异常类"><a href="#9-4-自定义异常类" class="headerlink" title="9.4 自定义异常类"></a>9.4 自定义异常类</h3><p>除了使用标准库中的异常类外，还可以定义自定义异常类，以提供更具体的错误信息。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义异常类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyException</span> : <span class="keyword">public</span> std::exception &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyException</span>(<span class="type">const</span> std::string&amp; message) : <span class="built_in">msg_</span>(message) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">what</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> msg_.<span class="built_in">c_str</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string msg_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数，模拟错误</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">riskyFunction</span><span class="params">(<span class="type">bool</span> triggerError)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (triggerError) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">MyException</span>(<span class="string">&quot;自定义错误发生！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;函数正常执行。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">riskyFunction</span>(<span class="literal">true</span>);</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> MyException&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;捕获到自定义异常: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;捕获到标准异常: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">捕获到自定义异常: 自定义错误发生！</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>MyException</code>继承自<code>std::exception</code>，并重写了<code>what</code>函数以返回自定义的错误信息。</li>
<li><code>riskyFunction</code>根据参数决定是否抛出<code>MyException</code>。</li>
<li><code>main</code>函数中的<code>try</code>块调用<code>riskyFunction</code>，并通过<code>catch</code>块捕获和处理自定义异常。</li>
</ul>
<h3 id="9-5-异常安全性与最佳实践"><a href="#9-5-异常安全性与最佳实践" class="headerlink" title="9.5 异常安全性与最佳实践"></a>9.5 异常安全性与最佳实践</h3><p>在编写异常处理代码时，应遵循以下最佳实践，确保程序的异常安全性和健壮性：</p>
<ol>
<li><strong>提供有意义的错误信息</strong>：异常对象应包含足够的上下文信息，帮助调试和问题定位。</li>
<li><strong>尽量减少异常的抛出</strong>：只在真正需要时抛出异常，避免在性能敏感的代码中频繁抛出异常。</li>
<li><strong>遵循RAII原则</strong>：通过资源获取即初始化（RAII）管理资源，确保在异常发生时资源被正确释放。</li>
<li><strong>避免资源泄漏</strong>：确保所有资源（如内存、文件句柄）在异常发生时都能被释放，可以使用智能指针和容器类来管理资源。</li>
<li><strong>捕获异常的适当范围</strong>：尽量在需要的地方捕获异常，避免在过大的范围内捕获异常，导致难以理解的错误处理。</li>
<li><strong>使用特定的异常类型</strong>：尽量捕获具体的异常类型，而不是使用通配符<code>catch(...)</code>，以便进行针对性的错误处理。</li>
<li><strong>保持异常规范</strong>：函数应明确声明可能抛出的异常类型，并遵循一致的异常处理策略。</li>
</ol>
<p><strong>示例：使用RAII和智能指针确保异常安全</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 资源类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Resource</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Resource</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;资源已分配。&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    ~<span class="built_in">Resource</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;资源已释放。&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;资源正在使用。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数，使用资源并可能抛出异常</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">useResource</span><span class="params">(<span class="type">bool</span> triggerError)</span> </span>&#123;</span><br><span class="line">    std::unique_ptr&lt;Resource&gt; res = std::<span class="built_in">make_unique</span>&lt;Resource&gt;();</span><br><span class="line">    res-&gt;<span class="built_in">doSomething</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (triggerError) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;在使用资源时发生错误。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// res在函数结束时自动释放，无需手动delete</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">useResource</span>(<span class="literal">true</span>);</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;异常捕获: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">资源已分配。</span><br><span class="line">资源正在使用。</span><br><span class="line">异常捕获: 在使用资源时发生错误。</span><br><span class="line">资源已释放。</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>使用<code>std::unique_ptr</code>管理<code>Resource</code>对象，确保即使在异常发生时，资源也能被自动释放。</li>
<li><code>useResource</code>函数中，当<code>triggerError</code>为<code>true</code>时，抛出<code>std::runtime_error</code>异常。</li>
<li>在<code>main</code>函数中，通过<code>try-catch</code>块捕获并处理异常，避免程序崩溃。</li>
</ul>
<h3 id="9-6-总结"><a href="#9-6-总结" class="headerlink" title="9.6 总结"></a>9.6 总结</h3><p>异常处理是C++中确保程序健壮性和稳定性的重要机制。通过合理使用<code>try</code>、<code>catch</code>和<code>throw</code>，并结合自定义异常类和RAII原则，可以有效地应对运行时错误，提升程序的可靠性。在Qt开发中，异常处理同样至关重要，特别是在处理文件操作、网络通信和动态内存管理等可能出现错误的场景中。</p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章详细介绍了Qt C++语言编程进阶的下半部分内容，涵盖了命名空间与模板、C++ IO流类库、STL容器（<code>vector</code>、<code>deque</code>、<code>stack</code>、<code>queue</code>、<code>set</code>、<code>map</code>）以及C++异常处理机制。这些高级特性和工具不仅丰富了C++的编程能力，也为Qt开发提供了强大的支持，使得开发者能够编写出更加高效、灵活和可维护的应用程序。</p>
<h3 id="主要内容回顾："><a href="#主要内容回顾：" class="headerlink" title="主要内容回顾："></a>主要内容回顾：</h3><ol>
<li><p><strong>命名空间与模板</strong>：</p>
<ul>
<li>命名空间用于组织代码，避免命名冲突。</li>
<li>模板支持泛型编程，实现函数和类的类型泛化和复用。</li>
</ul>
</li>
<li><p><strong>C++ IO流类库</strong>：</p>
<ul>
<li>提供了与控制台和文件的高效输入输出机制。</li>
<li>支持格式化输出，满足各种数据展示需求。</li>
</ul>
</li>
<li><p><strong>STL容器</strong>：</p>
<ul>
<li>**<code>vector</code>**：动态数组，支持随机访问和高效的元素操作。</li>
<li>**<code>deque</code>**：双端队列，支持两端的高效插入和删除。</li>
<li>**<code>stack</code>**：后进先出（LIFO）容器适配器。</li>
<li>**<code>queue</code>**：先进先出（FIFO）容器适配器。</li>
<li>**<code>set</code>**：有序的唯一元素集合，支持高效的查找和集合运算。</li>
<li>**<code>map</code>**：键值对的有序集合，适用于快速查找和关联数据管理。</li>
</ul>
</li>
<li><p><strong>C++异常处理</strong>：</p>
<ul>
<li>通过<code>try</code>、<code>catch</code>和<code>throw</code>实现运行时错误处理。</li>
<li>支持自定义异常类，结合RAII和智能指针确保异常安全性。</li>
</ul>
</li>
</ol>
<h3 id="下一步学习建议："><a href="#下一步学习建议：" class="headerlink" title="下一步学习建议："></a>下一步学习建议：</h3><p>掌握了C++的进阶特性后，建议继续深入以下内容，以全面提升Qt C++编程能力：</p>
<ul>
<li><strong>Qt框架核心概念</strong>：如信号与槽机制、事件处理、Qt的容器类等。</li>
<li><strong>Qt GUI开发</strong>：学习Qt Widgets、Qt Quick等用于构建用户界面的模块。</li>
<li><strong>Qt多线程编程</strong>：掌握Qt提供的多线程类和机制，实现高性能和响应式应用。</li>
<li><strong>Qt网络编程</strong>：了解Qt的网络模块，构建网络应用和服务。</li>
<li><strong>Qt项目实战</strong>：通过实际项目的开发，结合理论知识，巩固和应用所学内容。</li>
</ul>
<p>持续关注，我们将在后续的文章中详细介绍这些内容，帮助您全面掌握Qt C++编程的高级技能，提升开发效率，构建高质量的Qt应用程序。</p>
<hr>
<p><em>如果您对本文内容有任何疑问或建议，欢迎在评论区留言与我们交流。感谢您的阅读与支持！</em></p>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2024/12/26/Qt-C-%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/" rel="prev" title="Qt C++语言编程基础">
                  <i class="fa fa-chevron-left"></i> Qt C++语言编程基础
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2024/12/26/Qt-C-%E8%AF%AD%E8%A8%80%E6%96%B0%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3/" rel="next" title="Qt C++语言新特性详解">
                  Qt C++语言新特性详解 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">YCX</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">86k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">5:13</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  





</body>
</html>
